<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>CyberInfra</title>

  <link rel="stylesheet" href="/css/main.css">
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>CyberInfra | Sistemas Operacionais, Redes de Computadores, Cibersegurança…</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="CyberInfra" />
<meta name="author" content="Luiz Arthur Feitosa dos Santos" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Sistemas Operacionais, Redes de Computadores, Cibersegurança…" />
<meta property="og:description" content="Sistemas Operacionais, Redes de Computadores, Cibersegurança…" />
<link rel="canonical" href="http://localhost:4000/docs/docker/docker-imagens" />
<meta property="og:url" content="http://localhost:4000/docs/docker/docker-imagens" />
<meta property="og:site_name" content="CyberInfra" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="CyberInfra" />
<script type="application/ld+json">
{"@type":"WebPage","author":{"@type":"Person","name":"Luiz Arthur Feitosa dos Santos"},"description":"Sistemas Operacionais, Redes de Computadores, Cibersegurança…","headline":"CyberInfra","url":"http://localhost:4000/docs/docker/docker-imagens","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WJPJ7DKEWG"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WJPJ7DKEWG');
</script>

  
<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>luiz@CyberInfra:~#</h1>
    </a>
    <h3>Sistemas Operacionais, Redes de Computadores, Cibersegurança...</h3>
    <div class="header-links">
      <a href="/docs"><h2 class="header-link">Documentos</h2></a>
<a href="/videos"><h2 class="header-link">Videos</h2></a>
<a href="/archive"><h2 class="header-link">Postagens</h2></a>
<a href="/about"><h2 class="header-link">Sobre</h2></a>
<!-- <a href="/atom.xml"><h2 class="header-link">RSS</h2></a> -->

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <h1 id="imagens">Imagens</h1>

<p>No texto a respeido de <a href="docker-container">Container</a>, foi apresentado o conceito de container, que é
onde os aplicativos/serviços que estão sendo providos via Docker
efetivamente são executados. Todavia, já foi citado que o
container é criado utilizando-se imagens. Por exemplo, no comando:
“<code class="language-plaintext highlighter-rouge">docker run -i -t ubuntu /bin/bash</code>”, o parâmetro “<code class="language-plaintext highlighter-rouge">ubuntu</code>” representa
a imagem que serve de base para a criação do container Docker. Assim,
neste texto, vamos entender o que é uma imagem, como ela é utilizada
pelo container, quais são as vantagens do uso das imagens Docker, bem
como criar e gerenciar imagens Docker.</p>

<p>Em resumo, uma imagem Docker, nada mais é do que uma camada de sistema
de arquivos, que pode ser empilhada uma sobre a outra. Ou seja,
inicialmente podemos pensar na imagem Docker, como sendo o sistema de
arquivos que utilizaremos dentro do container Docker, tal como uma
imagem ou HD virtual de VM completa (ex. VM do VirtualBox ou VMWare).
Entretanto, é preciso ter em mente que há uma grande diferença entre uma
imagem Docker e uma imagem de VM completa.</p>

<p>Por exemplo, imagine que criamos uma VM completa, utilizando VirtualBox,
nesta VM instalamos o Arch Linux para ser o SO (Sistema Operacional),
vamos chamar essa VM de VM0, e tal VM servirá de base para a criação de
duas outras VMs. Desta forma, clonamos duas vezes a VM0 e criamos agora
a VM1 e VM2 (ver Figura 1). Sendo que, na VM1 instalaremos o MariaDB
para ser nosso banco de dados. Já na VM2, instalaremos o HTTP Apache.</p>

<p>Neste exemplo anterior, utilizando virtualização completa (<em>full
virtualization</em>), perceba que agora temos três VMs e cada uma tem um HD
virtual independente, no qual está instalado o sistema de arquivo, que é
a base do Arch Linux. Tais HDs virtuais, na verdade, são arquivos do
computador hospedeiro, esses arquivos normalmente têm alguns <em>gigabytes</em>
de tamanho. Continuando o exemplo, vamos supor que o HD da VM0 tem 5GB,
ai clonamos ele para criar a VM1 que por ser um clone da VM0 já tem 5GB,
somado a mais 5GB do MariaDB, o que totaliza um uso de 10GB do HD
virtual. Já para VM2, temos os 5GB iniciais do Arch (que já veio de
“herança”) e vamos imaginar que foram instalados e armazenados mais uns
3GB de dados, então teremos o HD virtual da VM2 com 8GB. Assim sendo,
neste exemplo temos três HDs virtuais com 5GB, 10GB e 8GB, o que
totaliza 23GB que são consumidos por esses HDs virtuais do HD real da
máquina hospedeira, tal como ilustrado na Figura 1. Concluindo esse
exemplo, em um sistema de virtualização completa, cada VM tem um HD
completo e isolado, não importa se isso veio de uma cópia/clone de outra
VM, a nova VM será um sistema único ocupando os recursos do hospedeiro
de forma completa e exclusiva.</p>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    <p>Os espaços citados no exemplo para :Arch Linux, MariaDB e Apache
HTTP, são meramente ilustrativos, ou seja, não correspondem ao mundo
real.</p></div></div>

<p><img src="imagens/virtualBox.png" alt="Figura 1: Virtualização completa com VirtualBox e HDs virtuais" /></p>

<p>Todavia, o conceito de imagem utilizada no Docker é ligeiramente
diferente do utilizado normalmente em sistemas de virtualização
completa. Desta forma, podemos até pensar nas imagens Docker como se
fossem HDs virtuais, mas é mais correto chamar de sistema de arquivos
(vamos fazer isso a partir de agora). Assim, é possível criar um sistema
de arquivos base e ir acoplando/sobrepondo outros sistemas de arquivos,
sendo que neste contexto cada sistema de arquivos vai ser uma nova
imagem e então teremos imagens sobrepostas.</p>

<p>Portanto, se pegarmos o mesmo exemplo anterior, só que utilizando
imagens Docker, o cenários ficaria da seguinte forma: teríamos a imagem
Arch Linux, que chamaremos de IMG0, com 5GB, que serviria de base para a
criação da IMG1 e IMG2. Tais imagens são respectivamente equivalentes à
VM0, VM1 e VM2. Então, pegamos de base a IMG0, instalamos o MariaDB e
criamos a IMG1. Da mesma forma, pegamos a IMG0 de base, instalamos o
Apache HTTP e criamos a VM2. Só que fazendo isso com imagens Docker, vai
haver uma grande diferença quando comparado ao exemplo anterior com o
VirtualBox, pois a IMG0 utiliza 5GB. Na IMG1, com a instalação do
MariaDB e dados, tal imagem consumirá apenas 5GB no total e não 10GB (do
exemplo com virtualização completa). Por fim, a IMG2 terá somente 3GB no
total (e não 8GB), tal como ilustra a Figura 2. Ou seja, todas as
imagens (IMG0, IMG1 e IMG2), consumirão da máquina hospedeira apenas
13GB de espaço em disco e não 23G, como foi feito utilizando o
VirtualBox, sendo que isso é possível graças ao conceito de UFS (Union
File System).</p>

<p><img src="imagens/docker1.png" alt="Figura 2: Docker e imagens" /></p>

<h2 id="union-file-system---union-mount">Union File System - <em>union mount</em></h2>

<p>Para compreender como as imagens Docker funcionam é necessário entender
o conceito de UFS (Union File System), comumente chamado de <em>union
mount</em>.</p>

<p>Para falar de <em>union mount</em> é necessário primeiro lembrar que montar
(<em>mount</em>) em ambientes Like-Unix, significa disponibilizar em um
diretório do sistema, o conteúdo de partições de HDs, SSDs, <em>pendrives</em>,
DVDs, etc. Assim, quando se monta uma partição de um HD, por exemplo no
diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, o conteúdo desta partição (arquivos e
diretórios) aparecerão dentro do diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>. A Figura 3-a
apresenta o diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, sem nenhum conteúdo (diretório
vazio) antes da montagem. Já a Figura 3-b, mostra o diretório
<code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code> após a montagem da partição de um HD, neste caso tal
diretório apresenta conteúdo da partição do HD, que são os arquivos
<code class="language-plaintext highlighter-rouge">Texto.txt</code> e <code class="language-plaintext highlighter-rouge">video.mp4</code>.</p>

<pre><code class="language-{=html}">&lt;!--
![(a) Antes de montar partição do HD (b) Depois de montar partição do HD](imagens/mount1.png)
--&gt;
</code></pre>
<p>É muito importante saber, que se já houvesse algum conteúdo dentro de
<code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, antes da montagem, tal conteúdo ficaria oculto,
indisponível e intocável durante todo o tempo que tal diretório
permanecer montado. Desta forma, se enquanto o conteúdo da partição do
HD estiver montada em <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code> e posteriormente for montada o
conteúdo de um <em>pendrive</em> no mesmo diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, tudo que
for feito no diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code> afetará somente os arquivos do
<em>pendrive</em>, pois o conteúdo da partição do HD estará oculta e protegida
pelo processo de montagem. A Figura 3-c mostra como ficará aos olhos do
usuário o conteúdo do diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, quando montando o
conteúdo de um <em>pendrive</em> no mesmo diretório onde já estava montada a
partição do HD. Já a Figura 3-d, apresenta que na verdade o conteúdo do
HD ainda está associado ao diretório, mas o mesmo não fica acessível
enquanto o <em>pendrive</em> permanecer montado. Todavia, quando o conteúdo da
partição do HD volta a aparecer no diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, asim que o
<em>pendrive</em> for desmontado, como se nada houvesse acontecido.</p>

<pre><code class="language-{=html}">&lt;!--
![(a) Pendrive montado (b) Arquivos da partição do HD ficam indisponíveis](imagens/mount2.png)
--&gt;
</code></pre>
<p>A diferença do <em>union mount</em> para o <em>mount</em> tradicional, é que o <em>union
mount</em> permite montar vários sistemas de arquivos em um ponto de
montagem (diretório), deixando o conteúdo de todos esses sistemas de
arquivos disponíveis simultaneamente. Ou seja, utilizando o <em>union
mount</em> é possível montar, o conteúdo de uma partição de HD no diretório
<code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, mas agora se for montado o conteúdo de um <em>pendrive</em> no
mesmo diretório (<code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>), ficará visível e acessível tanto o
conteúdo da partição do HD, quanto o conteúdo do <em>pendrive</em>, desta forma
o usuário deste sistema poderia trabalhar em ambos dispositivos de
armazenamento (<em>pendrive</em> e partição do HD) simultaneamente no mesmo
diretório (o que não era possível no <em>mount</em> tradicional). A Figura 3-e,
apresenta esse comportamento do <em>union mount</em>. É importante entender
aqui, que caso exista arquivos com o mesmo <em>path</em>, por exemplo
<code class="language-plaintext highlighter-rouge">/texto.txt</code> na partição do HD e um arquivo <code class="language-plaintext highlighter-rouge">/texto.txt</code> no pendrive,
ficará acessível apenas o arquivo do dispositivo que foi montado por
último. <code class="language-plaintext highlighter-rouge">&lt;!--
![Com *union mount* arquivos de HD e pendrive ficam disponíveis simultaneamente](imagens/mount3.png)
--&gt;</code>{=html}</p>

<p><img src="imagens/mount0.svg" alt="Figura 3: (a) Antes de montar partição do HD (b) Depois de montar
partição do HD (c) Pendrive montado (d) Arquivos do HD ficam
indisponíveis no diretório (e) *union
mount*" /></p>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    <p>Para realizar um <em>union mount</em> no Linux, é possível utilizar,
por exemplo, o <code>unionfs</code>, tal como:</p>
<pre class="console"><code># unionfs -o cow teste1/=RW:teste2/=RO testeTodos/</code></pre>
<p>Neste exemplo, o conteúdo dos diretórios <code>teste1/</code> e
<code>teste2/</code> são montados dentro de <code>testeTodos/</code>,
tudo que for alterado em <code>testeTodos/</code> será gravado em
<code>teste1/</code>, que foi definido com permissão de leitura e
gravação (<code>RW</code>).</p></div></div>

<p>O Docker suporta várias implementações do <em>mount union</em>, tais como:
AUFS, Overlay, devicemapper, BTRFS e ZFS. A implementação utilizada por
cada Docker pode ser vista com o comando <code class="language-plaintext highlighter-rouge">docker info</code>, na saída procure
por <code class="language-plaintext highlighter-rouge">Storage Driver</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker info | <span class="nb">grep</span> <span class="nt">-i</span> <span class="s2">"storage driver"</span>
<span class="go"> Storage Driver: overlay2
</span></code></pre></div></div>

<p>Na saída anterior, a máquina na qual o comando foi executado, está
utilizando o Overlay para tecnologia UFS, ou seja, para realizar <em>union
mount</em>.</p>

<p>Agora, sabendo como funciona o UFS ou <em>union mount</em>, podemos dizer que o
Docker utiliza tal técnica para agregar imagens e assim economizar
espaço em disco, bem como facilitar a distribuições e escalabilidade
dessas imagens, o que torna o Docker muito eficiente em comparação com
sistemas de virtualização completos (ex. VirtualBox, VMWare, etc).</p>

<p>Desta forma, utilizando UFS, os containers Docker normalmente têm várias
camadas de imagens, visando compor o container final de forma mais
prática e eficiente. Veja na Figura 4 como poderia ser composta as
camadas de imagens de um container, bem como a descrição dessas no texto
a seguir:</p>

<ul>
  <li>A primeira camada, ou seja imagem, será o sistema de arquivos de
<em>boot</em>, conhecido como <em>bootfs</em>. De forma simplista, vamos imaginar
que nesta imagem está apenas o <em>kernel</em> Linux;</li>
  <li>A próxima camada será, por exemplo, a base de alguma distribuição
Linux, tal como o Arch, Ubuntu, CentOS, etc;</li>
  <li>Na sequência poderia ter uma camada com as ferramentas/comandos que
o administrador acha que deve ter em todos os container, tais como:
<code class="language-plaintext highlighter-rouge">vim</code>, <code class="language-plaintext highlighter-rouge">iproute2</code>, <code class="language-plaintext highlighter-rouge">tcpdump</code>, <code class="language-plaintext highlighter-rouge">htop</code>, etc;</li>
  <li>Depois, pode vir o serviço que se espera daquela imagem, tal como o
Apache HTTP;</li>
  <li>Por fim, viria a camada na qual o container pode gravar/alterar
arquivos/diretórios.</li>
</ul>

<p><img src="imagens/imagensCamadas.svg" alt="Figura 4: Exemplo de camadas de imagens Docker em um
container" /></p>

<p>Levando em consideração o exemplo da Figura 4, note que a primeira
camada (Camada 1 da Figura 4) é o <em>kernel</em>, que na verdade é
compartilhado com o sistema hospedeiro. Já a Camada 2. Desta forma, o
<em>kernel</em> sempre será compartilhado do hospedeiro com todos os
containers, já a distribuição Linux pode ser qualquer uma (a gosto do
administrador). Após o <em>kernel</em> e a base da distribuição, normalmente
começam a surgir várias camadas, conforme a necessidade/estratégia do
administrador do sistema, por exemplo, caso ele queira que determinadas
ferramentas estejam em todos os containers derivados, ele pode instalar
tais ferramentas neste momento, tal como foi feito na Camada 3. Ainda
seguindo o exemplo, a próxima camada (Camada 4) contém a instalação do
Apache HTTP, então essa imagem provavelmente é de um servidor HTTP, que
poderia por exemplo, receber mais imagens, para formar servidores PHP,
JSP, JavaScript, etc. Da mesma forma, o administrador, poderia pegar a
partir da Camada 3 e adicionar uma imagem para um servidor de banco de
dados, etc. Já no topo das imagens, quando o container for iniciado, vai
ficar uma imagem com permissão de leitura e gravação, que será o espaço
no qual os arquivos criados ou alterados pelo container serão
armazenados, essa técnica chama-se CoW (<em>Copy-on-Write</em>), ver Camada 5
da Figura 4. Lembrando que aqui estamos apresentando só um exemplo de
como poderiam ser organizadas as camadas, ou seja, cada imagem de
container pode seguir uma ordem de sequência de imagem diferente.</p>

<h3 id="cow-copy-on-write">CoW (<em>Copy-on-Write</em>)</h3>

<p>No conceito de <strong><em>Copy-on-Write</em></strong>, todas as imagens abaixo da última,
estarão com permissão de somente leitura (RO), isso vai proteger a
imagem de alterações e garantir que a imagem é a mesma para todos que a
utilizarem. Já a última camada, tem permissão de leitura e gravação
(RW). Desta forma, arquivos novos são gravados nesta imagem, da mesma
forma, se algum arquivo das imagens a baixo forem alterados, será criado
uma cópia deste arquivo na imagem superior, que então ocultará o arquivo
da imagem original e apresentará para o sistema/usuário apenas o arquivo
alterado que agora está na imagem com permissão de leitura e gravação. O
CoW trabalha em conjunto com a técnica de <em>union mount</em>, explicada
anteriormente.</p>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/important.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
    <div>
    <p>O <em>union mount</em> permite montar várias imagens de forma que
todas fiquem acessíveis simultaneamente em um mesmo ponto de montagem
(diretório), só que normalmente apenas a última imagem é que terá
permissão de gravação e escrita, já as camadas abaixo dessa terão
permissão apenas de leitura. Quando algum arquivo/diretório de uma
camada abaixo precisar ser alterado/escrito, a técnica de CoW copiará
tal arquivo alterado para a última imagem, que normalmente representa o
container. Isso garante a integridade dos arquivo para containers que
utilizam as mesmas imagens e da mesma forma permite que o container
tenha a capacidade de alterar completamente e livremente a estrutura de
arquivos e diretórios ele está trabalhando.</p></div></div>

<p>Então containers mantém as alterações realizadas no sistema de arquivos
deles, permitindo assim salvar por exemplo configurações referentes
aquele container (ex. IP, rota padrão, usuários, etc), bem como
alterações realizadas por aquele container em arquivos que inicialmente
eram da imagem, mas que agora fazem parte daquele container. Já a imagem
utilizada para criar o container fica intocada, pois uma imagem Docker é
imutável.</p>

<p>Agora sabendo como funcionam as imagens Docker e quais são as técnicas
empregadas nessas imagens, vamos abordar como utilizar e configurar tais
imagens na prática.</p>

<h2 id="listando-imagens-images">Listando imagens (<code class="language-plaintext highlighter-rouge">images</code>)</h2>

<p>Para listar as imagens disponíveis no próprio <em>host</em> hospedeiro, é
possível utilizar o comando <code class="language-plaintext highlighter-rouge">docker images</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker images
<span class="go">REPOSITORY              TAG           IMAGE ID       CREATED        SIZE
ubuntu                  latest        35a88802559d   2 months ago   78MB
luizarthur/cyberinfra   routerDeb11   28b009432f01   4 months ago   391MB
luizarthur/cyberinfra   hostDeb11     da504d85c4c9   4 months ago   278MB
debian                  11            57a92962dbeb   4 months ago   124MB
archlinux               latest        0cda8061254a   5 months ago   436MB
</span></code></pre></div></div>

<p>A saída da listagem de imagens apresentada no exemplo anterior, mostra
as imagens por linhas, sendo que cada coluna apresenta as seguintes
informações:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">REPOSITORY</code>: é o repositório de onde a imagem foi derivada;</li>
  <li><code class="language-plaintext highlighter-rouge">TAG</code>: é um nome para identificar/nomear o repositório, isso pode
por exemplo ajudar a controlar versões;</li>
  <li><code class="language-plaintext highlighter-rouge">IMAGE ID</code>: identificador único da imagem, em nível global (é um
<em>hash</em>);</li>
  <li><code class="language-plaintext highlighter-rouge">CREATED</code>: informa a data que a imagem foi criada;</li>
  <li><code class="language-plaintext highlighter-rouge">SIZE</code>: tamanho da imagem - quanto ela ocupa no disco.</li>
</ul>

<p>As imagens ficam armazenadas normalmente dentro do diretório
<code class="language-plaintext highlighter-rouge">/usr/lib/docker</code>, sendo que dentro deste diretório as imagens devem
estar dentro dos subdiretórios <code class="language-plaintext highlighter-rouge">overlay2</code>, <code class="language-plaintext highlighter-rouge">aufs</code>, <code class="language-plaintext highlighter-rouge">btrfs</code>, dentre
outros, dependendo o tipo de armazenamento Docker utilizado.</p>

<p>Por exemplo, o conteúdo do diretório <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code>, do <em>host</em> a
seguir é:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">ls</span> /var/lib/docker/
<span class="go">buildkit  containerd  containers  engine-id  image  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes
</span></code></pre></div></div>

<p>Dentro do subdiretório <code class="language-plaintext highlighter-rouge">/var/lib/docker/overlay2/</code> ficará as camadas das
imagens utilizadas no Docker (neste caso o <em>host</em> utiliza o <code class="language-plaintext highlighter-rouge">overlay2</code>),
então um exemplo de saída deste diretório seria:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">ls</span> /var/lib/docker/overlay2/
<span class="go">00b33f7e6620ec4c3b874db4dbdac73e4ac79b3ba28414376be5641182c1381e       9b41a116168f228375439a9a3cd637171657966d91a1322df6ec8ec41778663c
032c162f754771188907fdb019c3e48df5965e05dd05100b08f999b644e266fb       9b41a116168f228375439a9a3cd637171657966d91a1322df6ec8ec41778663c-init
046c72f791a385eff6aea070a3acd52a47b9b8b815a82ee71436e1278a6e3d5d       9f9d469612856b3ba95bd9257b971b8bb821457c862c50c4f11353f9e7510452
046c72f791a385eff6aea070a3acd52a47b9b8b815a82ee71436e1278a6e3d5d-init  a4da83df821bbaaa6f2833864b3cf765713a2919039547966283bb5e4e1f5541
</span><span class="c">...
</span></code></pre></div></div>

<p>Já o diretório <code class="language-plaintext highlighter-rouge">/var/lib/docker/image/</code> contém metadados a respeito das
imagens. No exemplo a seguir é possível ver que o <em>host</em> têm como
subdiretório de <code class="language-plaintext highlighter-rouge">image</code> um diretório chamado <code class="language-plaintext highlighter-rouge">overlay2</code>, que por sua vez
tem diretórios e arquivos com os dados a respeito das imagens:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">ls</span> /var/lib/docker/image/
<span class="go">overlay2

</span><span class="gp">#</span><span class="w"> </span><span class="nb">ls</span> <span class="nt">-l</span> /var/lib/docker/image/overlay2/
<span class="go">total 16
drwx------ 4 root root 4096 Jun 21  2021 distribution
drwx------ 4 root root 4096 Jun 21  2021 imagedb
drwx------ 5 root root 4096 Jun 21  2021 layerdb
-rw------- 1 root root 2214 Aug 13 11:20 repositories.json
</span></code></pre></div></div>

<p>A princípio, tais arquivos não devem ser editados manualmente, pois são
mantidos de forma automática pelo próprio Docker.</p>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    <p>Os arquivos dos containers ficam normalmente no diretório
<code>/var/lib/docker/containers/</code>.</p></div></div>

<h2 id="de-onde-vêm-as-imagens-docker">De onde vêm as imagens Docker?</h2>

<p>Estamos falando das imagens Docker, mas como fazer ou obter uma imagem
Docker?</p>

<p>A reposta é: “você pode fazer a sua própria imagem, ou baixá-las de
algum repositório”.</p>

<p>Então há basicamente duas formas obter e utilizar imagens Docker, que
são:</p>

<ul>
  <li>
    <p><strong>Obtendo imagens de repositórios</strong>, tais como o <a href="https://hub.docker.com/">Docker
Hub</a>. Neste exemplo o Docker Hub, é um
repositório para imagens Dockers, no qual é possível compartilhar,
armazenar e distribuir imagens Dockers utilizando, repositórios
públicos ou privados;</p>
  </li>
  <li>
    <p><strong>Criando sua própria imagem</strong>. Para criar-se uma imagem,
normalmente é utilizada imagem pré-existente geralmente obtida de um
repositório. É claro que é possível criar uma imagem Docker do zero,
sem utilizar outra imagem pré-existente, todavia uma das grandes
vantagens do Docker é justamente poder reutilizar imagens já
criadas, o que torna tudo muito mais fácil.</p>
  </li>
</ul>

<p>É necessário observar que o conceito de repositórios de imagens Docker
são um grande atrativo para o uso do Docker, pois torna-se muito fácil
criar, gerenciar e distribuir imagens. Dada essa afirmação/constatação,
não faz muito sentido não utilizar os repositórios. Assim, o texto a
seguir mescla a criação de imagens manualmente com o uso de
repositórios, já que isso é o mais natural dentro do mundo Docker.</p>

<h2 id="procurando-imagens-no-docker-hub-search">Procurando imagens no Docker Hub (<code class="language-plaintext highlighter-rouge">search</code>)</h2>

<p>O <a href="https://hub.docker.com/">Docker Hub</a> é similar ao
<a href="https://github.com/">GitHub</a>, só que o GitHub é uma plataforma que
mantém códigos-fonte, ou seja, repositórios de projetos de programação.
Já o Docker Hub faz a mesma coisa, só que com imagens Dockers, que podem
ser simplesmente a imagem de um Linux básico (que serve de base para
outras imagens) ou de imagens mais complexas contento por exemplo um
sistema completo de uma empresa.</p>

<p>Ainda comparando o GitHub com o Docker Hub, uma das grandes vantagens de
se disponibilizar um projeto de software via Docker Hub e não GitHub, é
que quem baixar a imagem já tem o ambiente completo e funcional para
executar tal projeto. O que não acontece no GitHub, pois nesse é
necessário geralmente, baixar o projeto, resolver as dependências
(instalar softwares e bibliotecas necessários para o projeto) e só então
tentar executá-lo. É claro que na prática, o objetivo do GitHub e do
Docker Hub são diferentes (eles não competem entre-si), na verdade um
complementa o outro.</p>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    <p>Há outros repositórios similares ao Docker Hub, tais como: <a href="https://quay.io/">Quay</a>, <a href="https://cloud.google.com/artifact-registry?hl=pt-br">Google
Container Registry - GCR</a>, <a href="https://aws.amazon.com/pt/ecr/">Amazon Elastic Container Registry
- ECR</a>, <a href="https://azure.microsoft.com/en-us/products/container-registry/">Azure
Container Registry - ACR</a>, <a href="https://docs.gitlab.com/ee/user/packages/container_registry/">GitLab
Container Registry</a> e <a href="https://goharbor.io/">Harbor</a>.
Todavia neste texto vamos nos concentrar no Docker Hub.</p></div></div>

<p>Assim, para obter imagens do Docker Hub é possível pesquisar por essas
no sítio Web do Docker Hub (<a href="https://hub.docker.com/search">https://hub.docker.com/search</a>). A Figura 5
ilustra a busca por imagens Dockers relacionadas com “Fedora” na
tentativa de encontrar uma imagem do Fedora Linux.</p>

<p><img src="imagens/dockerHub1.png" alt="Figura 5: Busca por imagens no Docker
Hub" /></p>

<p>Já a Figura 5 mostra as informações do repositório Docker escolhido após
a busca anterior.</p>

<p><img src="imagens/dockerHub2.png" alt="Figura 6: Imagem do Fedora Linux no Docker
Hub" /></p>

<p>Além de realizar a busca direta no sítio Web, também é possível realizar
tal busca utilizando o comando <code class="language-plaintext highlighter-rouge">docker search</code> seguido do termo de
busca. No exemplo a seguir buscamos novamente por “fedora”, só que agora
via console:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span>docker search fedora
<span class="go">NAME                         DESCRIPTION                                     STARS     OFFICIAL
fedora                       Official Docker builds of Fedora                1213      [OK]
ustclug/fedora               Official Fedora Image with USTC Mirror          0
srcml/fedora                 Build, package, and test srcml on Fedora        0
mdsplus/fedora                                                               0
kasmweb/fedora-39-desktop    Fedora 39 desktop for Kasm Workspaces           0
kasmweb/fedora-40-desktop    Fedora 40 desktop for Kasm Workspaces           1
</span></code></pre></div></div>

<h2 id="obtendo-imagens-do-docker-hub-pull">Obtendo imagens do Docker Hub (<code class="language-plaintext highlighter-rouge">pull</code>)</h2>

<p>Bem, depois de encontrar a imagem via sítio Web ou repositório, é
possível obter essa imagem Docker realizando um <code class="language-plaintext highlighter-rouge">docker pull</code>. Note que
na Figura 5, via sítio Web, que há uma opção para já copiar (<em>copy</em>) o
comando necessário para baixar a imagem do <code class="language-plaintext highlighter-rouge">fedora</code> encontrada, então
vamos executar tal comando:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker pull fedora
<span class="go">Using default tag: latest
latest: Pulling from library/fedora
f7bb57d05c2a: Pull complete
Digest: sha256:b7b4b222c2a433e831c006a49a397009640cc30e097824410a35b160be4a176b
Status: Downloaded newer image for fedora:latest
docker.io/library/fedora:latest
</span></code></pre></div></div>

<p>A saída do comando anterior mostra que a imagem Docker, foi do Docker
Hub com sucesso. Para constatar isso podemos pedir para listar as
imagens, e lá deve aparecer uma linha do repositório do <code class="language-plaintext highlighter-rouge">fedora</code>, tal
como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker images
<span class="go">REPOSITORY              TAG           IMAGE ID       CREATED        SIZE
fedora                  latest        9146ee7fcff0   3 days ago     222MB
ubuntu                  latest        35a88802559d   2 months ago   78MB
luizarthur/cyberinfra   routerDeb11   28b009432f01   4 months ago   391MB
</span><span class="c">...
</span></code></pre></div></div>

<p>Depois de obter a imagem é possível utilizá-la, por exemplo iniciando um
container, tal como já fizemos nos textos anteriores:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--name</span> meuFedora <span class="nt">-ti</span> fedora /bin/bash
<span class="gp">[root@19bad3150dfa /]#</span><span class="w"> </span>yum <span class="nt">--version</span>
<span class="go">4.19.0
  Installed: dnf-0:4.19.0-1.fc40.noarch at Sun Apr 14 22:54:24 2024
  Built    : Fedora Project at Thu Feb  8 16:33:42 2024

  Installed: rpm-0:4.19.1.1-1.fc40.x86_64 at Sun Apr 14 22:54:24 2024
  Built    : Fedora Project at Wed Feb  7 15:55:53 2024
</span><span class="gp">[root@19bad3150dfa /]#</span><span class="w"> </span><span class="nb">uname</span> <span class="nt">-a</span>
<span class="gp">Linux 19bad3150dfa 6.10.6-arch1-1 #</span>1 SMP PREEMPT_DYNAMIC Mon, 19 Aug 2024 17:02:39 +0000 x86_64 GNU/Linux
<span class="gp">[root@19bad3150dfa /]#</span><span class="w">
</span></code></pre></div></div>

<p>No comando anterior, ligamos um container chamado <code class="language-plaintext highlighter-rouge">meuFedora</code> com a
imagem do Fedora Linux, que obtivemos anteriormente. Nesta foi executado
o comando <code class="language-plaintext highlighter-rouge">yum</code> o que mostra que estamos em um ambiente que utiliza
ferramentas de instalação do Fedora, mesmo estando em um <em>host</em> que é
Arch Linux (ou seja, não tem <code class="language-plaintext highlighter-rouge">yum</code>).</p>

<h2 id="criando-imagens-commit-e-build">Criando imagens (<code class="language-plaintext highlighter-rouge">commit</code> e <code class="language-plaintext highlighter-rouge">build</code>)</h2>

<p>Como vimos anteriormente é possível obter uma imagem existente de um
repositório, tal como o Docker Hub, todavia em algum momento será
necessário modificar a imagem para que essa atenda necessidades
específicas de empresas ou pessoas. Neste caso há duas formar de criar
imagens:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">docker commit</code>, sendo que este método cria uma imagem a partir de
um container existente. Tal método permite que se faça alterações
manuais dentro do container (interagindo com o <code class="language-plaintext highlighter-rouge">bash</code>, por exemplo).
Após todas as alterações necessárias, o administrador salvará o
estado atual desse container, gerando uma nova imagem;</li>
  <li><code class="language-plaintext highlighter-rouge">docker build</code>, nesta forma a imagem será criada a partir das
instruções contidas em um arquivo chamado Dockerfile, tal arquivo é
basicamente um <em>script</em> que contém sequências de instruções para
configurar a imagem Docker.</li>
</ul>

<p>Note que o <code class="language-plaintext highlighter-rouge">commit</code> a principio pode ser mais simples que o <code class="language-plaintext highlighter-rouge">build</code>,
todavia ele não documenta as alterações feitas na imagem, isso
compromete o registro das alterações da imagem e pode atrapalhar o
gerenciamento da imagem. Já o <code class="language-plaintext highlighter-rouge">build</code>, inicialmente é mais complexo,
pois exige que o administrador do sistema compreenda os comandos do
arquivo Dockerfile, mas a longo prazo o gerenciamento dessas imagens
ficam mais simples. Desta forma, o método mais recomendado para criar
imagem é o <code class="language-plaintext highlighter-rouge">build</code>.</p>

<h3 id="criando-imagens-com-o-commit">Criando imagens com o <code class="language-plaintext highlighter-rouge">commit</code></h3>

<p>Vamos iniciar criando imagens utilizando o <code class="language-plaintext highlighter-rouge">commit</code>, pois isso é mais
intuitivo a principio. Desta forma, espera-se que tenhamos um container
em execução e que vamos alterar coisas dentro desse container (na imagem
dele) e depois vamos salvar essa imagem alterada.</p>

<p>Então como exemplo, vamos iniciar um container e depois vamos instalar
alguns pacotes nele, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--name</span> meuFedoraApache <span class="nt">-ti</span> fedora /bin/bash
<span class="go">
</span><span class="gp">[root@f768497f72b7 /]#</span><span class="w"> </span>dnf update
<span class="c">...
</span><span class="gp">[root@f768497f72b7 /]#</span><span class="w"> </span>dnf <span class="nb">install </span>httpd
<span class="c">...
</span><span class="gp">[root@f768497f72b7 /]#</span><span class="w"> </span>dnf <span class="nb">install </span>net-tools
<span class="c">...
</span><span class="gp">[root@f768497f72b7 /]#</span><span class="w"> </span>/usr/sbin/httpd
</code></pre></div></div>

<p>No container anterior, utilizamos a imagem do <code class="language-plaintext highlighter-rouge">fedora</code> para iniciar um
container chamado <code class="language-plaintext highlighter-rouge">meuFedoraApache</code>, depois utilizando o comando <code class="language-plaintext highlighter-rouge">dnf</code>,
realizamos uma atualização do sistema e em seguida instalamos os pacotes
<code class="language-plaintext highlighter-rouge">httpd</code> e <code class="language-plaintext highlighter-rouge">net-tools</code>, esses respectivamente são: o servidor Apache HTTP
e alguns comandos de rede (<code class="language-plaintext highlighter-rouge">ifconfig</code>, <code class="language-plaintext highlighter-rouge">netstat</code>, etc). Por fim,
iniciamos o <code class="language-plaintext highlighter-rouge">httpd</code> que acabamos de instalar.</p>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    <p>Não precisaria instalar o <code>net-tools</code> para o Apache
funcionar, isso só foi feito para poder ver o IP do container e se o
Apache está em execução com o <code>netstat</code>.</p>
<p>Com esses passos podemos ver o servidor HTTP em execução no container
em questão (veja o IP do container e digite esse em seu navegador
Web).</p></div></div>

<p>Agora, com o container já configurado da forma que esperávamos, vamos
gerar uma imagem a partir desse container. Para isso precisamos abrir
outro terminal (<strong>não no terminal do container</strong>) e executar:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker commit meuFedoraApache servidor/fedora_apache
<span class="go">sha256:8bcfdd9d6660954b2645e72185fb086071e1aeca519c93b3bd50aa6b0b363ff7
</span></code></pre></div></div>

<p>No exemplo que estamos seguindo, utilizamos o container
<code class="language-plaintext highlighter-rouge">meuFedoraApache</code>, para criar uma imagem chamada
<code class="language-plaintext highlighter-rouge">servidor/fedora_apache</code>. Tal imagem agora pode ser vista na lista de
imagens que temos localmente, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker images
<span class="go">REPOSITORY               TAG           IMAGE ID       CREATED         SIZE
servidor/fedora_apache   latest        8bcfdd9d6660   5 minutes ago   512MB
fedora                   latest        9146ee7fcff0   3 days ago      222MB
ubuntu                   latest        35a88802559d   2 months ago    78MB
luizarthur/cyberinfra    routerDeb11   28b009432f01   4 months ago    391MB
</span><span class="c">...
</span></code></pre></div></div>

<p>Agora podemos utilizá-la para por exemplo iniciar um novo container com
um servidor Apache em execução, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> servidorFedApache <span class="nt">-d</span> servidor/fedora_apache /usr/sbin/httpd <span class="nt">-DFOREGROUND</span>
<span class="go">4d76b05803d3757975f58199b97c023240763577884bec435d6fc1eec6bd6784
</span></code></pre></div></div>

<p>Então o comando anterior, executa um container chamado
<code class="language-plaintext highlighter-rouge">servidorFedApache</code>, a partir da imagem <code class="language-plaintext highlighter-rouge">servidor/fedora_apache</code> (que
criamos via <code class="language-plaintext highlighter-rouge">commit</code>) e executa o servidor HTTP
(<code class="language-plaintext highlighter-rouge">/usr/sbin/httpd -DFOREGROUND</code>).</p>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/important.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
    <div>
    <p>Note que foi necessário utilizar a opção <code>-DFOREGROUND</code>,
para o container não terminar devido ao Apache executar em plano de
fundo.</p></div></div>

<p>Após isso podemos ver tal container em execução:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS     NAMES
4d76b05803d3   servidor/fedora_apache   "/usr/sbin/httpd -DF…"   2 seconds ago    Up 1 second               servidorFedApache
f768497f72b7   fedora                   "/bin/bash"              48 minutes ago   Up 20 minutes             meuFedoraApache
</span></code></pre></div></div>

<p>Também podemos ver o IP desse container e acessá-lo via navegador Web,
tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect servidorFedApache | <span class="nb">grep</span> <span class="nt">-i</span> <span class="se">\"</span>IPAddress
<span class="go">            "IPAddress": "172.17.0.3",
</span></code></pre></div></div>

<p>Depois seria só inserir o IP do container no navegador, tal como
<a href="http://172.17.0.3">http://172.17.0.3</a> e deve ser possível ver uma página Web, tal como
apresentado na Figura 7.</p>

<p><img src="imagens/navegador1.png" alt="Figura 7: Navegador acessando o Apache do
container" /></p>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    <p>É importante observar que durante o <code>commit</code> o container
que serve de base estava em execução.</p></div></div>

<h3 id="criando-imagens-com-o-build">Criando imagens com o <code class="language-plaintext highlighter-rouge">build</code></h3>

<p>Vimos anteriormente que o <code class="language-plaintext highlighter-rouge">commit</code> pode ser utilizado para criar uma
imagem, todavia atualmente recomenda-se utilizar o <code class="language-plaintext highlighter-rouge">build</code>, já que esse
é considerado uma prática melhor, pois permite analisar as diferenças
entre as imagens, já que mantém um arquivo com os passos executados para
alterar a imagem. Desta forma é importante entender como funciona o
<code class="language-plaintext highlighter-rouge">build</code> e o arquivo Dockerfile.</p>

<h4 id="dockerfile">Dockerfile</h4>

<p>Então a base para se criar uma imagem com o <code class="language-plaintext highlighter-rouge">build</code> é entender o
Dockerfile e sua estrutura. Desta forma para entender a estrutura básica
deste arquivo vamos replicar o que foi feito na imagem anterior (quando
foi utilizado o <code class="language-plaintext highlighter-rouge">commit</code>).</p>

<p>Para isso vamos criar um diretório, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">mkdir </span>buildApache
<span class="gp">$</span><span class="w"> </span><span class="nb">cd </span>buildApache/
<span class="gp">$</span><span class="w"> </span>vi Dockerfile
</code></pre></div></div>

<p>Então anteriormente (comandos), foi criado um diretório chamando
<code class="language-plaintext highlighter-rouge">buildApache</code>, entramos dentro deste diretório (<code class="language-plaintext highlighter-rouge">cd</code>) e por fim
executamos o editor de texto <code class="language-plaintext highlighter-rouge">vi</code> (fique a vontade para utilizar outro
editor de texto) para criar/editar o arquivo chamado <code class="language-plaintext highlighter-rouge">Dockerfile</code>. Para
este exemplo o conteúdo deste arquivo será:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">FROM fedora
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
RUN dnf install httpd net-tools -y
</span><span class="gp">RUN echo "Olá com &lt;b&gt;</span><span class="w"> </span>build<span class="s2">" &gt; /var/www/html/index.html''
</span></code></pre></div></div>

<p>As instruções contidas neste arquivo de exemplo foram:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FROM</code>: indica a imagem base, na qual essa nova imagem será gerada;</li>
  <li><code class="language-plaintext highlighter-rouge">MAINTAINER</code>: informa o autor da imagem e seu e-mail;</li>
  <li><code class="language-plaintext highlighter-rouge">RUN</code>: Executa comandos na imagem atual.</li>
</ul>

<p>Então o principal neste arquivo de exemplo, é que a imagem é baseada no
<code class="language-plaintext highlighter-rouge">fedora</code>, e são executados três comandos, sendo esses: atualiza o
<code class="language-plaintext highlighter-rouge">fedora</code>, instala do <code class="language-plaintext highlighter-rouge">httpd</code> e <code class="language-plaintext highlighter-rouge">net-tools</code> (o <code class="language-plaintext highlighter-rouge">-y</code> é para responder sim
a todas as perguntas do <code class="language-plaintext highlighter-rouge">dnf</code>, já que não há interação do usuário com
este tipo de procedimento) e por fim, neste exemplo, criamos um
<code class="language-plaintext highlighter-rouge">index.html</code> para diferenciar essa imagem da anterior (criada com o
<code class="language-plaintext highlighter-rouge">commit</code>).</p>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    <p>Lembrando que principalmente nesta imagem não precisaria instalar o
<code>net-tools</code>, isso foi feito aqui só para manter
compatibilidade entre os exemplos.</p></div></div>

<p>Feito o Dockerfile, agora é possível executar o <code class="language-plaintext highlighter-rouge">docker build</code> e criar
efetivamente a imagem, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">-t</span><span class="o">=</span><span class="s2">"servidor/build_fedora_apache"</span> <span class="nb">.</span>
<span class="go">DEPRECATED: The legacy builder is deprecated and will be removed in a future release.
            Install the buildx component to build images with BuildKit:
            https://docs.docker.com/go/buildx/

Sending build context to Docker daemon  2.048kB
Step 1/5 : FROM fedora
</span><span class="gp"> ---&gt;</span><span class="w"> </span>9146ee7fcff0
<span class="go">Step 2/5 : MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
</span><span class="gp"> ---&gt;</span><span class="w"> </span>Running <span class="k">in </span>8acec3282bb9
<span class="gp"> ---&gt;</span><span class="w"> </span>Removed intermediate container 8acec3282bb9
<span class="gp"> ---&gt;</span><span class="w"> </span>6e988b94e803
<span class="go">Step 3/5 : RUN dnf update -y
</span><span class="c">...
</span><span class="go">Complete!
</span><span class="gp"> ---&gt;</span><span class="w"> </span>Removed intermediate container 168523b0e76d
<span class="gp"> ---&gt;</span><span class="w"> </span>60e824a461ec
<span class="gp">Step 5/5 : RUN echo "Olá com &lt;b&gt;</span><span class="w"> </span>build<span class="s2">" &gt; /var/www/html/index.html''
</span><span class="gp"> ---&gt;</span><span class="w"> </span><span class="s2">Running in 23444ad42f62
</span><span class="gp"> ---&gt;</span><span class="w"> </span><span class="s2">Removed intermediate container 23444ad42f62
</span><span class="gp"> ---&gt;</span><span class="w"> </span><span class="s2">a399fcc1c787
</span><span class="go">Successfully built a399fcc1c787
Successfully tagged servidor/build_fedora_apache:latest
</span></code></pre></div></div>

<p>É importante acompanhar e verificar as saída do processo <code class="language-plaintext highlighter-rouge">build</code>, para
identificar possíveis erros, principalmente nos comandos executados pelo
<code class="language-plaintext highlighter-rouge">RUN</code>. Caso erros aconteçam serão retornados códigos diferentes de zero,
na saída.</p>

<p>::: tip
Se houverem erros, uma boa prática é executar o container com o <code class="language-plaintext highlighter-rouge">bash</code> e
ir digitando os comandos lá dentro e copiando e colando para o
Dockerfile.
:::</p>

<p>Na saída anterior, que não apresentou erros, veja que o comando
<code class="language-plaintext highlighter-rouge">docker build</code> é seguida de <code class="language-plaintext highlighter-rouge">-t</code>, que indica o rótulo que vai
identificar a nova imagem. Após isso é possível acompanhar a execução
das instruções do Dockerfile, ou seja, obtenção da imagem do <code class="language-plaintext highlighter-rouge">fedora</code>, e
execução dos comandos presentes no <code class="language-plaintext highlighter-rouge">RUN</code>.</p>

<p>É válido mencionar com ainda é possível criar rótulos para as imagens na
opção <code class="language-plaintext highlighter-rouge">-t</code>, tal como:
<code class="language-plaintext highlighter-rouge">docker build -t="servidor/build_fedora_apache:v1"</code>, isso ajuda a
organizar melhor as imagens, mas caso não se utilize esse rótulo o
Docker colocará por padrão o rótulo <code class="language-plaintext highlighter-rouge">latest</code>.</p>

<p>Também é possível executar o <code class="language-plaintext highlighter-rouge">docker build</code> em um diretório diferente da
onde está o Dockerfile, inclusive utilizando um arquivo que não se chama
Dockerfile (mas o conteúdo tem que ser no estilo Dockerfile), para isso
basta utilizar a opção <code class="language-plaintext highlighter-rouge">-f</code> e passar o caminho para o arquivo em
questão.</p>

<p>Após o <code class="language-plaintext highlighter-rouge">build</code> é possível ver a imagem na listagem de imagens Docker,
tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker images
<span class="go">REPOSITORY                     TAG           IMAGE ID       CREATED              SIZE
servidor/build_fedora_apache   latest        a399fcc1c787   About a minute ago   518MB
servidor/fedora_apache         latest        8bcfdd9d6660   About an hour ago    512MB
fedora                         latest        9146ee7fcff0   3 days ago           222MB
ubuntu                         latest        35a88802559d   2 months ago         78MB
luizarthur/cyberinfra          routerDeb11   28b009432f01   4 months ago         391MB
</span></code></pre></div></div>

<p>Então, com a imagem pronta, é possível executar um container utilizando
essa nova imagem:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> servidorFedApache2 <span class="nt">-d</span> servidor/build_fedora_apache /usr/sbin/httpd <span class="nt">-DFOREGROUND</span>
<span class="go">81b9354214ca0bae865211ba93b34817c7aef8cab3cc3510954a11da14a9db03
</span></code></pre></div></div>

<p>Se tudo correu bem, tal imagem estará em execução:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE                          COMMAND                  CREATED             STATUS             PORTS     NAMES
81b9354214ca   servidor/build_fedora_apache   "/usr/sbin/httpd -DF…"   6 seconds ago       Up 5 seconds                 servidorFedApache2
4d76b05803d3   servidor/fedora_apache         "/usr/sbin/httpd -DF…"   About an hour ago   Up About an hour             servidorFedApache
f768497f72b7   fedora                         "/bin/bash"              2 hours ago         Up 2 hours                   meuFedoraApache
</span></code></pre></div></div>

<p>E podemos fazer o teste, tal como feito no exemplo do <code class="language-plaintext highlighter-rouge">commit</code>, e
portanto podemos acessar o servidor HTTP em execução no container
criado. A saída a seguir mostra como obter o IP do container e a
Figura 8 mostra o acesso à esse container utilizando um navegador no
<em>host</em> hospedeiro.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect servidorFedApache2 | <span class="nb">grep</span> <span class="nt">-i</span> <span class="se">\"</span>IPAddress
<span class="go">            "IPAddress": "172.17.0.4",
                    "IPAddress": "172.17.0.4",
</span></code></pre></div></div>

<p><img src="imagens/navegador2.png" alt="Figura 8: Navegador acessando o Apache do container criado a partir de
um Dockerfile" /></p>

<h4 id="cache-do-build">Cache do <code class="language-plaintext highlighter-rouge">build</code></h4>

<p>Os passos executados durante a criação da imagem utilizando <code class="language-plaintext highlighter-rouge">build</code> e
Dockerfile ficam armazenados em cache, isso pode economizar tempo, pois
se um passo já foi feito e um novo passo foi adicionado, o Docker só vai
gastar tempo executando o novo passo.</p>

<p>O uso do cache na criação da imagem utilizando o <code class="language-plaintext highlighter-rouge">build</code> e o Dockerfile,
pode ser vista na saída a seguir, que executa a imagem, que já havia
sido criada na seção anterior - ou seja, é uma imagem que já teve todos
os seus passos criados:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">-t</span><span class="o">=</span><span class="s2">"servidor/build_fedora_apache"</span> <span class="nb">.</span>
<span class="c">...
</span><span class="go">Step 1/5 : FROM fedora
</span><span class="gp"> ---&gt;</span><span class="w"> </span>9146ee7fcff0
<span class="go">Step 2/5 : MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
</span><span class="gp"> ---&gt;</span><span class="w"> </span>Using cache
<span class="gp"> ---&gt;</span><span class="w"> </span>ef7690e14222
<span class="go">Step 3/5 : RUN dnf update -y
</span><span class="gp"> ---&gt;</span><span class="w"> </span>Using cache
<span class="gp"> ---&gt;</span><span class="w"> </span>2402ee15a5f0
<span class="go">Step 4/5 : RUN dnf install httpd net-tools -y
</span><span class="gp"> ---&gt;</span><span class="w"> </span>Using cache
<span class="gp"> ---&gt;</span><span class="w"> </span>6a8f5591a1c9
<span class="gp">Step 5/5 : RUN echo "Olá com &lt;b&gt;</span><span class="w"> </span>build<span class="s2">" &gt; /var/www/html/index.html''
</span><span class="gp"> ---&gt;</span><span class="w"> </span><span class="s2">Using cache
</span><span class="gp"> ---&gt;</span><span class="w"> </span><span class="s2">9c80a2830029
</span><span class="go">Successfully built 9c80a2830029
Successfully tagged servidor/build_fedora_apache:latest
</span></code></pre></div></div>

<p>Na saída anterior onde aparece <code class="language-plaintext highlighter-rouge">---&gt; Using cache</code>, significa que quando
foi executado o comando <code class="language-plaintext highlighter-rouge">docker build</code>, que aquele dado passo (<code class="language-plaintext highlighter-rouge">Step</code>),
não foi executado, mas sim foi utilizado o que estava no cache, ou seja,
foi utilizado o que já se tinha anteriormente.</p>

<p>A ideia do cache será útil na maioria dos casos, entretanto algumas
vezes o cache pode atrapalhar. Por exemplo, suponha que em uma primeira
vez pedimos para o sistema atualizar a base de pacotes (ex.
<code class="language-plaintext highlighter-rouge">apt update</code>), mas isso já faz um tempo e tal base está desatualizada, e
seria refazer isso para instalar um novo pacote. Se esse passo estiver
no Dockerfile, que já passou por um cache, tal atualização não será
realizada e portanto pode não ser possível instalar o pacote novo. Para
esses casos existe a opção <code class="language-plaintext highlighter-rouge">--no-cache</code>, que obriga o Docker a ignorar o
cache e refazer todos passos presentes no Dockerfile. Um exemplo do uso
desse comando seria:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">--no-cache</span> <span class="nt">-t</span><span class="o">=</span><span class="s2">"servidor/build_fedora_apache"</span> <span class="nb">.</span>
</code></pre></div></div>

<p>Então, a opção <code class="language-plaintext highlighter-rouge">--no-cache</code> do comando anterior, fará com que Docker
ignore qualquer cache existe (daquela imagem), obrigando o Docker a
recriar a imagem executando novamente todos os passos presentes no
Dockerfile.</p>

<p>Também é possível ter um comportamento semelhante ao <code class="language-plaintext highlighter-rouge">--no-cache</code>
utilizando-se a instrução <code class="language-plaintext highlighter-rouge">ENV</code> com a variável <code class="language-plaintext highlighter-rouge">REFRESHED_AT</code>, seguida
da uma data. Assim, caso a data presente neste variável mudar (tiver a
data do tempo atual), o Docker vai ignorar o cache e executar todos os
passos novamente.</p>

<p>A saída a seguir mostra como utilizar o <code class="language-plaintext highlighter-rouge">ENV REFRESHED_AT</code> no
Dockerfile:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">FROM fedora
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
ENV REFRESHED_AT 2024-08-30
RUN dnf update -y
RUN dnf install httpd net-tools -y
</span><span class="gp">RUN echo "Olá com &lt;b&gt;</span><span class="w"> </span>build<span class="s2">" &gt; /var/www/html/index.html''
</span></code></pre></div></div>

<p>::: tip
A princípio se alterar o valor que está na frente do <code class="language-plaintext highlighter-rouge">ENV REFRESHED_AT</code>,
o Docker já vai executar os passos novamente. Tal como:
<code class="language-plaintext highlighter-rouge">ENV REFRESHED_AT 2024-08-30 2</code>, fazendo menção a uma versão 2 para o
mesmo dia.
:::</p>

<h3 id="instruções-do-dockerfile">Instruções do Dockerfile</h3>

<p>Na seção anterior, foram apresentadas algumas instruções que podem ser
utilizadas no Dockerfile, mas a seguir são apresentadas essas e outras
instruções que normalmente são utilizadas para a criação de imagens:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">FROM</code></strong>: Especifica a imagem base da qual a imagem será
construída;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">LABEL</code></strong>: Permite adicionar rótulos à imagem;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">RUN</code></strong>: Executa comandos durante a construção da imagem;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">CMD</code></strong>: Específica o comando padrão que será executado quando o
container for executado. É similar ao <code class="language-plaintext highlighter-rouge">RUN</code>, mas o <code class="language-plaintext highlighter-rouge">RUN</code> executa um
comando durante a criação da imagem, já o <code class="language-plaintext highlighter-rouge">CMD</code> é para a execução do
container.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ENTRYPOINT</code></strong>: Define o comando que sempre será executado quando
o container é iniciado;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">COPY</code></strong>: Copia arquivos ou diretórios do <em>host</em> para a imagem;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ADD</code></strong>: Similar ao <code class="language-plaintext highlighter-rouge">COPY</code>, mas permite ainda extrair arquivos
compactados e a utilização de URLs. Sugere-se utilizar o <code class="language-plaintext highlighter-rouge">COPY</code>
quando a tarefa for apenas copiar arquivos do <em>host</em> para o
container, e o <code class="language-plaintext highlighter-rouge">ADD</code>, quando for necessário fazer copias de URL ou
de arquivos compactados.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">WORKDIR</code></strong>: Diretório de trabalho à ser utilizado nos pelas
instruções <code class="language-plaintext highlighter-rouge">RUN</code>, <code class="language-plaintext highlighter-rouge">CMD</code>, <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>, <code class="language-plaintext highlighter-rouge">COPY</code> e <code class="language-plaintext highlighter-rouge">ADD</code>;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ENV</code></strong>: Define variáveis de ambiente para o container;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">EXPOSE</code></strong>: Determina quais portas de rede serão expostas do
container para o <em>host</em>;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ARG</code></strong>: Define variáveis que podem ser passadas durante o
<code class="language-plaintext highlighter-rouge">build</code>. Note que o ARG cria variáveis de ambiente que estarão
disponíveis apenas durante a construção da imagem, já o <code class="language-plaintext highlighter-rouge">ENV</code> é para
variáveis de ambiente durante a execução do container;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">VOLUME</code></strong>: Cria um ponto de montagem, permitindo que dados sejam
persistidos ou compartilhados entre containers;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">USER</code></strong>: Define sob qual usuário o container será executado.
Assim, ela define um usuário existente no container para executar as
instruções Docker.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">HELTHCHECK</code></strong>: Instrui o Docker a verificar o container em
intervalos regulares. Tal instrução vai executar um comando ou
<em>script</em> determinado pelo administrador para verificar se tudo está
certo com o container criado, tal comando pode ser por exemplo, um
<code class="language-plaintext highlighter-rouge">ping</code> ou um acesso ao uma URL com o comando <code class="language-plaintext highlighter-rouge">wget</code> ou <code class="language-plaintext highlighter-rouge">curl</code>;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">STOPSIGNAL</code></strong>: Define o sinal que será enviado ao se parar o
container;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">SHELL</code></strong>: Determina qual <em>shell</em> deve ser utilizado para os
comandos <code class="language-plaintext highlighter-rouge">RUN</code>, <code class="language-plaintext highlighter-rouge">CMD</code>, <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>, etc.</li>
</ul>

<p>As instruções apresentadas anteriormente são as mais comuns, a seguir
são apresentados exemplos de uso dessas instruções para a criação de
imagens com o Dockerfile.</p>

<p>O texto a seguir mostra como realizar algumas tarefas utilizando Docker - <a href="docker-tarefas">Tarefas</a>.</p>

</article>
      </section>
    </div>
  </div>

   <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
        <b>Luiz Arthur Feitosa dos Santos</b>
    </span>
    
    <span>© 2024</span>
  </a>
</footer>


</body>

</html>
