<h1 id="introdução">Introdução</h1>

<h1 id="sec:containers">Containers</h1>

<h2 id="verificando-se-o-docker-está-instalado">Verificando se o Docker está instalado</h2>

<p>Para iniciar os trabalhos com o Docker, é bom primeiro verificar se o mesmo está devidamente instalado.</p>

<p>Isso pode ser feito de várias formas, mas vamos fazer verificando a versão do Docker instalado, com o seguinte comando:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nt">--version</span>
<span class="go">Docker version 27.0.3, build 7d4bcd863a
</span></code></pre></div></div>
<p>Caso o comando não exista, será necessário instalar o Docker em seu sistema. Nenhuma instalação será abordada aqui neste material, recomenda-se buscar informações a respeito de como proceder tal instalação no sítio oficial do <a href="https://docs.docker.com/engine/install/">Docker</a>, já que a instalação pode variar de sistema para sistema.</p>

<p>::: note
No caso do Linux veja como instalar em <a href="https://docs.docker.com/desktop/install/linux-install/">https://docs.docker.com/desktop/install/linux-install/</a>.
:::</p>

<p>Além do comando <code class="language-plaintext highlighter-rouge">docker --version</code>, é comum executar os comandos:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">docker version</code>, que apresenta mais informações do que o comando que foi digitado anteriormente;</li>
  <li><code class="language-plaintext highlighter-rouge">docker info</code>, que traz mais informações ainda, informações a respeito do cliente, servidor, etc.</li>
</ul>

<p>Para ver se o servidor está em execução em sistemas Linux, é possível utilizar o comando <code class="language-plaintext highlighter-rouge">ps</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>ps ax | <span class="nb">grep </span>dockerd
<span class="go">    791 ?        Ssl    0:00 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
   8748 pts/0    S+     0:00 grep dockerd
</span></code></pre></div></div>

<p>Neste exemplo são retornados dois processos com o termo <code class="language-plaintext highlighter-rouge">dockerd</code>, sendo esses:</p>

<ul>
  <li>8748, é do <code class="language-plaintext highlighter-rouge">grep</code>, utilizado para filtrar as saídas no comando <code class="language-plaintext highlighter-rouge">ps</code> (esse não interessa).</li>
  <li>791, é o processo em execução do Docker (<code class="language-plaintext highlighter-rouge">/usr/bin/dockerd</code>), ou seja, era o que estávamos procurando e se ele não estivesse ai, algo estaria errado com a execução do Docker neste sistema.</li>
</ul>

<p>::: note
Lembrando que os números dos processos provavelmente vão mudar em cada sistema, já que são aleatórios.
:::</p>

<p>Bem, mas só executamos esses comandos para ter certeza que o Docker está instalado - isso não é obrigatório. Agora vamos para o próximo passo, que é realmente utilizar o Docker para fazer alguma coisa.</p>

<h2 id="executando-containers-run">Executando containers (<code class="language-plaintext highlighter-rouge">run</code>)</h2>

<p>Vamos executar um container Docker simples para efetivamente verificar se tudo está funcionando no Docker.</p>

<p>Para isso, vamos utilizar o comando <code class="language-plaintext highlighter-rouge">docker run</code>. Nesta primeira execução será iniciada uma imagem do Ubuntu Linux, com interação de um <em>shell</em>, para este sistema. Para tanto vamos executar o seguinte comando:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">-i</span> <span class="nt">-t</span> ubuntu /bin/bash
<span class="go">Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu
9c704ecd0c69: Pull complete
Digest: sha256:2e863c44b718727c860746568e1d54afd13b2fa71b160f5cd9058fc436217b30
Status: Downloaded newer image for ubuntu:latest
</span><span class="gp">root@ebfc7d73bf3a:/#</span><span class="w">
</span></code></pre></div></div>

<p>::: important
Pode ser necessário utilizar o comando <code class="language-plaintext highlighter-rouge">sudo</code> para executar o <code class="language-plaintext highlighter-rouge">docker</code>. Como exemplo, o comando anterior ficaria <code class="language-plaintext highlighter-rouge">sudo docker run -i -t ubuntu /bin/bash</code>.
:::</p>

<p>O comando anterior, bem como sua saída, apresentam várias “coisas” interessantes do Docker. Assim, vamos dissecar primeiro o comando executado (docker run -i -t ubuntu /bin/bash), vendo as seguintes opções e parâmetros:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-i</code>, mantém a saída padrão (STDIN) do container no console do hospedeiro, ou seja, todas as saídas geradas pelo container serão apresentadas na tela na qual o comando foi digitado;</li>
  <li><code class="language-plaintext highlighter-rouge">-t</code>, informa para o Docker associar um console virtual (<em>pseudo-tty</em>) para o container criado. Isso vai permitir interagir como container, através da execução de comandos;</li>
  <li><code class="language-plaintext highlighter-rouge">ubuntu</code>, é o nome da imagem utilizada para criar o container. Outras imagens poderiam ser utilizadas, essas podem estar disponível localmente ou na Internet, por exemplo no <a href="https://hub.docker.com/">Docker Hub</a>. Depois, no [Capítulo @sec:imagens], vamos ver melhor como listar e utilizar essas imagens.</li>
  <li><code class="language-plaintext highlighter-rouge">/bin/bash</code>, esse é o comando a ser executado no container que está sendo criado. Mais especificamente, neste exemplo, estamos pedindo para o container executar o <code class="language-plaintext highlighter-rouge">bash</code>, que é normalmente o <em>shell</em> padrão de ambientes Linux. Neste caso, como esperamos interagir com o container, via comandos  (dadas as opções <code class="language-plaintext highlighter-rouge">-i</code> e <code class="language-plaintext highlighter-rouge">-t</code>), vamos fazer isso via console. Ou seja, isso vai permitir interagir com o container através de um console texto, no qual será possível digitar comandos no container.</li>
</ul>

<h3 id="interagindo-com-o-bash-do-container">Interagindo com o <code class="language-plaintext highlighter-rouge">bash</code> do container</h3>

<p>Bem, com o resultado do comando anterior, estamos dentro de um container, pronto para interagir com ele através do <em>prompt</em> de comando.</p>

<p>::: important
Os comandos apresentados a seguir podem variar de container para container dependendo da distribuição e da versão da mesma, bem como das configurações já realizadas em um container pré-configurado. Tais comandos são do Linux e não do Docker.
:::</p>

<p>Então vamos por exemplo executar alguns comandos Linux neste container.</p>

<h4 id="verificando-o-nome-do-container">Verificando o nome do container:</h4>

<p>Podemos utilizar o comando <code class="language-plaintext highlighter-rouge">hostname</code> do Linux, para ver o nome do <em>host</em>/container.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">root@ebfc7d73bf3a:/#</span><span class="w"> </span><span class="nb">hostname</span>
<span class="go">ebfc7d73bf3a
</span></code></pre></div></div>

<p>A saída anterior, mostra que o nome do <em>host</em> é ebfc7d73bf3a.</p>

<p>::: important
Neste exemplo o nome ebfc7d73bf3a é o ID do container, ou seja, é um valor que identifica o container de forma única dentro do Docker.
:::</p>

<h4 id="verificando-detalhes-de-redes-do-container">Verificando detalhes de redes do container:</h4>

<p>Atualmente, para verificar as configurações de rede do Linux é comum utilizar o comando <code class="language-plaintext highlighter-rouge">ip</code>. Todavia se tentarmos utilizar o comando <code class="language-plaintext highlighter-rouge">ip</code> neste container, o resultado será o seguinte:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">root@ebfc7d73bf3a:/#</span><span class="w"> </span>ip
<span class="go">bash: ip: command not found
</span></code></pre></div></div>
<p>Ou seja, o comando <code class="language-plaintext highlighter-rouge">ip</code> não está instalado por padrão neste container, mas é possível instalar pacotes neste container, conforme é abordado a seguir.</p>

<p>::: note
Neste caso, seria possível ver o IP do container sem instalar o comando <code class="language-plaintext highlighter-rouge">ip</code>, isso pode ser feito com o comando <code class="language-plaintext highlighter-rouge">hostname -I</code>.
:::</p>

<h4 id="atualizando-o-ubuntu-do-container">Atualizando o Ubuntu do container:</h4>

<p>Para atualizar o Ubuntu do container basta fazer um <code class="language-plaintext highlighter-rouge">atp update</code>, tal como seria em um computador normal (sem container):</p>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">root@ebfc7d73bf3a:/#</span><span class="w"> </span>apt update
<span class="go">Get:1 http://archive.ubuntu.com/ubuntu noble InRelease [256 kB]
</span><span class="c">...
</span><span class="go">Reading state information... Done
2 packages can be upgraded. Run 'apt list --upgradable' to see them.
</span></code></pre></div></div>

<h4 id="instalando-pacotes-do-ubuntu-do-container">Instalando pacotes do Ubuntu do container:</h4>

<p>Agora com o <code class="language-plaintext highlighter-rouge">apt</code> atualizado, é possível instalar o comando <code class="language-plaintext highlighter-rouge">ip</code>, no caso ele é disponibilizado através do pacotes <code class="language-plaintext highlighter-rouge">iproute2</code>, então vamos instalar esse:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">root@ebfc7d73bf3a:/#</span><span class="w"> </span>apt <span class="nb">install </span>iproute2
<span class="go">Reading package lists... Done
</span><span class="c">...
</span><span class="go">Do you want to continue? [Y/n]
Get:1 http://archive.ubuntu.com/ubuntu noble/main amd64 libelf1t64 amd64 0.190-1.1build4 [57.6 kB]
</span><span class="c">...
</span><span class="go">Processing triggers for libc-bin (2.39-0ubuntu8.2) ...
</span></code></pre></div></div>
<p>A saída anterior mostra que o <code class="language-plaintext highlighter-rouge">iproute2</code> foi instalado com sucesso.</p>

<p>::: note
Se o container não for derivado do Debian, como é o caso do Ubuntu, pode ser que o comando <code class="language-plaintext highlighter-rouge">apt</code> não exista, ai será necessário utilizar outras formas para instalar pacotes - isso pode variar de distribuição para distribuição.
:::</p>

<h4 id="verificando-as-configurações-de-rede-com-o-comando-ip">Verificando as configurações de rede com o comando <code class="language-plaintext highlighter-rouge">ip</code>:</h4>

<p>Com o pacote <code class="language-plaintext highlighter-rouge">iproute2</code> instalado, agora é possível utilizar o comando <code class="language-plaintext highlighter-rouge">ip</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">root@ebfc7d73bf3a:/#</span><span class="w"> </span>ip a
<span class="gp">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt;</span><span class="w"> </span>mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
<span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
</span><span class="gp">6: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span><span class="w"> </span>mtu 1500 qdisc noqueue state UP group default
<span class="go">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</span></code></pre></div></div>
<p>A saída anterior, mostra que no container existem as seguintes interfaces de rede:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">lo</code>, com o IP 127.0.0.1/8;</li>
  <li><code class="language-plaintext highlighter-rouge">eth0</code>, com o IP 172.17.0.2/16.</li>
</ul>

<p>Daria para explorar mais informações, tal como a rota padrão através do comando <code class="language-plaintext highlighter-rouge">ip route</code>.</p>

<h4 id="verificando-os-processos-em-execução-no-container">Verificando os processos em execução no container:</h4>

<p>Para verificar os processos em execução no container, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">ps</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">root@ebfc7d73bf3a:/#</span><span class="w"> </span>ps ax
<span class="go">    PID TTY      STAT   TIME COMMAND
      1 pts/0    Ss     0:00 /bin/bash
    339 pts/0    R+     0:00 ps ax
</span></code></pre></div></div>

<p>A saída do comando anterior mostra que há dois processos no container em questão. Sendo esses representados pelos seguintes PIDs:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1</code>, para o processo <code class="language-plaintext highlighter-rouge">bash</code>, que é o <em>shell</em> que pedimos para executar no comando que criou o container;</li>
  <li><code class="language-plaintext highlighter-rouge">339</code>, para o processo <code class="language-plaintext highlighter-rouge">ps</code>, que é o último comando que foi executado.</li>
</ul>

<p>Daria para ficar interagindo com o container, tal como em um sistema normal, mas vamos parar por aqui.</p>

<h3 id="saindo-do-console-do-container-exit">Saindo do console do container (<code class="language-plaintext highlighter-rouge">exit</code>)</h3>

<p>Para sair do console do container, basta digitar <code class="language-plaintext highlighter-rouge">exit</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">root@ebfc7d73bf3a:/#</span><span class="w"> </span><span class="nb">exit</span>
<span class="go">exit
</span><span class="gp">$</span><span class="w">
</span></code></pre></div></div>
<p>Conforme a saída do comando anterior, veja que saímos do container <code class="language-plaintext highlighter-rouge">ebfc7d73bf3a</code>, no qual estávamos com o usuário <code class="language-plaintext highlighter-rouge">root</code>, e no exemplo, voltamos para o <em>host</em> <code class="language-plaintext highlighter-rouge">fielDell</code>, com o usuário <code class="language-plaintext highlighter-rouge">luiz</code>.</p>

<p>Bem, mas o que aconteceu com o container que estava em execução?
A resposta é: ele parou de ser executado!
Isso acontece, pois o Docker iniciou o container para executar o comando <code class="language-plaintext highlighter-rouge">/bin/bash</code>, e quando digitamos <code class="language-plaintext highlighter-rouge">exit</code>, o comando <code class="language-plaintext highlighter-rouge">/bin/bash</code> para de ser executado e assim o container inteiro para.</p>

<h2 id="listando-containers">Listando containers</h2>

<p>Uma tarefa extremamente comum é listar os containers que estão em execução, bem como os que estão parados. Veja como fazer isso a seguir.</p>

<h3 id="listar-containers-parados-ps--a">Listar containers parados (<code class="language-plaintext highlighter-rouge">ps -a</code>)</h3>

<p>Para ver os containers parados, execute o comando <code class="language-plaintext highlighter-rouge">docker ps -a</code>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps <span class="nt">-a</span>
<span class="go">CONTAINER ID   IMAGE                               COMMAND                  CREATED             STATUS                        PORTS     NAMES
ebfc7d73bf3a   ubuntu                              "/bin/bash"              About an hour ago   Exited (0) 47 minutes ago               strange_jang
06d326091537   luizarthur/cyberinfra:hostDeb11     "/gns3/init.sh bash"     6 weeks ago         Exited (137) 6 weeks ago                admiring_burnell
</span></code></pre></div></div>
<p>::: note
A saída infelizmente pode extrapolar o tamanho da página, e por isso as colunas ficam em posições ruins de mostrar o resultado - isso também pode acontecer em um terminal de computador.
:::</p>

<p>No exemplo da saída anterior temos dois containers parados, sendo esses:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ebfc7d73bf3a</code>, que tem o nome <code class="language-plaintext highlighter-rouge">strange_jang</code>, derivado de uma imagem chamada <code class="language-plaintext highlighter-rouge">ubuntu</code>, sendo esse o container deste exemplo.</li>
  <li><code class="language-plaintext highlighter-rouge">06d326091537</code>, com o nome <code class="language-plaintext highlighter-rouge">admiring_burnell</code>, criado da imagem <code class="language-plaintext highlighter-rouge">luizarthur/cyberinfra:hostDeb11</code>.</li>
</ul>

<p>Note ainda na saída anterior, que dá para ver os comandos de iniciação desses containers (<code class="language-plaintext highlighter-rouge">COMMAND</code>), bem como algumas informações de tempo (<code class="language-plaintext highlighter-rouge">CREATED</code>), estado do container (<code class="language-plaintext highlighter-rouge">STATUS</code>), etc.</p>

<p>A princípio o nome do container é gerado automaticamente, mas é possível informar um nome para o container utilizando a opção <code class="language-plaintext highlighter-rouge">--name</code>. Os nomes devem ser únicos. Assim, na hora de criar o container, informe o nome deste container, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--name</span> meuContainer <span class="nt">-i</span> <span class="nt">-t</span> ubuntu /bin/bash
</code></pre></div></div>

<p>No exemplo anterior seria criado um container chamado <code class="language-plaintext highlighter-rouge">meuContainer</code>.</p>

<h3 id="listar-containers-em-execução-ps">Listar containers em execução (<code class="language-plaintext highlighter-rouge">ps</code>)</h3>

<p>Para listar containers em execução, basta executar o comando <code class="language-plaintext highlighter-rouge">docker ps</code>, ou seja, é apenas tirar o <code class="language-plaintext highlighter-rouge">-a</code> do comando anterior. Veja o exemplo:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</span></code></pre></div></div>

<p>No exemplo da saída anterior, não há nenhum container em execução.</p>

<p>::: important
Note que o comando <code class="language-plaintext highlighter-rouge">ps</code> dentro de sistemas Unix-Like, apresentam os processos em execução. Já o <code class="language-plaintext highlighter-rouge">ps</code> passado como parâmetro para o comando <code class="language-plaintext highlighter-rouge">docker</code>, apresenta containers em execução ou parados. Ou seja, eles não são equivalentes.
:::</p>

<p>Para listagens, há duas opções úteis:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-n</code> seguida de um número inteiro, mostrará os últimos <em>x</em> containers (não importa o estado do container - em execução ou parado), sendo que <em>x</em> é o número digitado na frente de <code class="language-plaintext highlighter-rouge">-n</code>;</li>
  <li><code class="language-plaintext highlighter-rouge">-l</code>, mostrará apenas o último container (não importa o estado).</li>
</ul>

<p>As opções <code class="language-plaintext highlighter-rouge">-n</code> e <code class="language-plaintext highlighter-rouge">-l</code> são importantes, pois podem haver vários containers na lista retornada pelo comando <code class="language-plaintext highlighter-rouge">ps</code>. Assim tais opções vão filtrar e mostrar os mais recentes, que normalmente são os que estamos trabalhando no momento.</p>

<h2 id="iniciando-containers-parados-start">Iniciando containers parados (<code class="language-plaintext highlighter-rouge">start</code>)</h2>

<p>É possível iniciar um container que está parado, isso é feito com o comando <code class="language-plaintext highlighter-rouge">docker start</code> seguido do ID do container ou nome.</p>

<p>Então vamos iniciar o container que criamos anteriormente, através de seu ID (visto na listagem dos containers parados):</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker start ebfc7d73bf3a
<span class="go">ebfc7d73bf3a
</span></code></pre></div></div>

<p>Feito isso, agora se listarmos os containers em execução, teremos o seguinte resultado:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE     COMMAND       CREATED       STATUS         PORTS     NAMES
ebfc7d73bf3a   ubuntu    "/bin/bash"   2 hours ago   Up 3 seconds             strange_jang
</span></code></pre></div></div>

<p>Ou seja, o container ebfc7d73bf3a, saiu de parado para em execução (<code class="language-plaintext highlighter-rouge">Up</code>).</p>

<h2 id="acessando-containers-em-execução-attach">Acessando containers em execução (<code class="language-plaintext highlighter-rouge">attach</code>)</h2>

<p>Bem, mas e agora? Como interagir com o console deste container que acabamos de ligar novamente, no exemplo anterior? Para isso é possível utilizar a opção <code class="language-plaintext highlighter-rouge">attach</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker attach ebfc7d73bf3a
<span class="gp">root@ebfc7d73bf3a:/#</span><span class="w">
</span></code></pre></div></div>

<p>Assim estamos novamente no console do container que voltou à execução pela opção <code class="language-plaintext highlighter-rouge">start</code>.</p>

<p>::: note
Atenção, para sair de um console de um container, sem parar o processo, é possível pressionando as teclas <code class="language-plaintext highlighter-rouge">Ctrl+p</code> seguido de <code class="language-plaintext highlighter-rouge">Ctrl+q</code>.
Então, pressione a tecla <code class="language-plaintext highlighter-rouge">ctrl</code> e a tecla <code class="language-plaintext highlighter-rouge">p</code>. Depois, sem soltar o <code class="language-plaintext highlighter-rouge">ctrl</code>, solte o <code class="language-plaintext highlighter-rouge">p</code> e pressione <code class="language-plaintext highlighter-rouge">q</code>.
:::</p>

<h2 id="parando-containers-em-execução-stop">Parando containers em execução (<code class="language-plaintext highlighter-rouge">stop</code>)</h2>

<p>Para parar um container que está em execução podemos utilizar a opção <code class="language-plaintext highlighter-rouge">stop</code>. Então, normalmente você vai listar os containers em execução com o comando <code class="language-plaintext highlighter-rouge">docker ps</code>, vai pegar o ID ou nome deste e executar o comando <code class="language-plaintext highlighter-rouge">docker</code>, com a opção <code class="language-plaintext highlighter-rouge">stop</code>, tal como:</p>

<ul>
  <li>Verificando os containers em execução:
    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE     COMMAND       CREATED       STATUS         PORTS     NAMES
ebfc7d73bf3a   ubuntu    "/bin/bash"   2 hours ago   Up 3 seconds             strange_jang
</span></code></pre></div>    </div>
  </li>
</ul>

<p>Neste caso vamos utilizar ID ebfc7d73bf3a.</p>

<ul>
  <li>Parando o container:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker stop ebfc7d73bf3a
<span class="go">ebfc7d73bf3a
</span></code></pre></div></div>

<ul>
  <li>Verificando se realmente o container parou:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</span></code></pre></div></div>

<p>Como observa-se na última saída, o container <code class="language-plaintext highlighter-rouge">ebfc7d73bf3a</code> não está mais em execução. É claro que os passos de verificação apresentados aqui, não são obrigatórios, mas é comum executá-los no dia a dia, para ter certeza do que estamos fazendo.</p>

<p>A opção <code class="language-plaintext highlighter-rouge">stop</code> do Docker, envia um sinal SIGTERM para o container. Todavia é possível enviar o sinal SIGKILL, com a opção <strong><code class="language-plaintext highlighter-rouge">kill</code></strong>.</p>

<p>Desta forma, com o <code class="language-plaintext highlighter-rouge">stop</code>, o container é fechado de forma elegante, encerrando o processo corretamente. Já com o <code class="language-plaintext highlighter-rouge">kill</code>, o processo do container é fechado abruptamente, por exemplo, sem salvar conteúdos em disco - se for o caso. Então, o <code class="language-plaintext highlighter-rouge">kill</code> só deve ser utilizado em casos extremos, nos quais o container pode comprometer a integridade do sistema como um todo, ou por estar travado (não responde de forma alguma).</p>

<p>::: note
As opções <code class="language-plaintext highlighter-rouge">stop</code> e <code class="language-plaintext highlighter-rouge">kill</code> do Docker fazem mais sentido para containers que rodam processos em plano de fundo, no estilo <em>daemon</em> (veremos esse a seguir). Se o container for executado de forma interativa, utilizando por exemplo o <code class="language-plaintext highlighter-rouge">/bin/bash</code>, é possível pará-lo com o <code class="language-plaintext highlighter-rouge">exit</code>, via console.
:::</p>

<h2 id="criando-containers-no-estilo-daemon--d">Criando containers no estilo <em>daemon</em> (<code class="language-plaintext highlighter-rouge">-d</code>)</h2>

<p>Da forma que utilizamos container até o momento, eles ficam bastante parecidos com VMs completas, utilizados no VirtualBox ou VMWare. Entretanto, na prática, não se espera que os containers funcionem assim, de forma interativa - mesmo que eles possam ser utilizados desta forma.</p>

<p>Atualmente, esperá-se que os containers executem pequenas partes de um serviço maior, no estilo microsserviço. Por exemplo, um container pode executar um servidor de banco de dados, outro executa um serviço Web, tal como JavaScript, outro PHP e assim por diante. Lembre-se que o Docker, ao contrário das VMs completas, compartilham recursos do computador hospedeiro, então os containers não consomem recursos em demasia se comparados às VMs completas e por isso, são uma boa opção para segmentar serviços, isolando ambientes diferentes e assim fornecendo mais segurança, escalabilidade, etc.</p>

<p>Dito isso, é comum executar containers sem interagir diretamente com eles. Desta forma, o administrador basicamente vai configurar qual serviço ou serviços o container deve executar quando for iniciado, e depois, só vai interagir com os serviços providos pelo container - não vai ficar interagindo com o container via <em>shell</em>.
Então, normalmente será necessário “daemonizar” os serviços que o container vai executar, ou seja, é necessário deixar os processos executados pelo container rodando em plano de fundo (<em>backgroud</em>), já que simplesmente não haverá uma tela por padrão esperando a interação do usuário. Em outras palavras, a ideia é colocar serviço/processo, bem como o container como <em>daemon</em>.</p>

<p>::: note
Normalmente serviços de rede são executados em servidores como <em>daemons</em>, tais como: HTTP, SSH, SMB, NFS, etc.
:::</p>

<p>Para iniciar processos em <em>backgroud</em> no Docker, utiliza-se a opção <strong><code class="language-plaintext highlighter-rouge">-d</code></strong>. Uma curiosidade é que o <code class="language-plaintext highlighter-rouge">-d</code> significa <em>detach</em> e não <em>daemon</em>, mas ela serve para deixar o processo como se fosse um <em>daemon</em>. Desta forma, com a opção <em>detach</em>, espera-se que não exista um console acoplado para interação, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--name</span> cont1 <span class="nt">-d</span> ubuntu /bin/sh <span class="nt">-c</span> <span class="s2">"while true; do echo Olá mundo; date; sleep 10; done"</span>
<span class="go">7b4b0a3be0b58fdfa7f8e0e4674bc38a400c564ec969a853ae6ee0add9796010
</span></code></pre></div></div>

<p>No comando anterior, estamos basicamente informando o seguinte para o Docker:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">run</code>: inicie o container;</li>
  <li><code class="language-plaintext highlighter-rouge">--name cont1</code>: atribuir o nome cont1 ao container;</li>
  <li><code class="language-plaintext highlighter-rouge">-d</code>: ele vai ser executado em plano de fundo (no estilo <em>daemon</em>);</li>
  <li><code class="language-plaintext highlighter-rouge">ubuntu</code>: utiliza a imagem do Ubuntu;</li>
  <li><code class="language-plaintext highlighter-rouge">/bin/sh</code>: vai executar um <em>script</em>.</li>
</ul>

<p>Em resumo, iniciamos um container para executar um <em>shell script</em> que fica apresentando na saída do container o seguinte: texto “Olá mundo”, seguido da data/hora do container, repedindo isso a cada 10 segundos. Tudo isso foi feito através dos comandos que estão na frente de <code class="language-plaintext highlighter-rouge">/bin/sh -c</code>.</p>

<p>::: note
Note que o comando passado para esse container é o <code class="language-plaintext highlighter-rouge">/bin/sh</code>, tudo que vêm após tal comando (<code class="language-plaintext highlighter-rouge">-c "while true; do echo Olá...</code>), são opções e parâmetros do <code class="language-plaintext highlighter-rouge">sh</code> e não do comando <code class="language-plaintext highlighter-rouge">docker</code>.
:::</p>

<p>Se tudo correr bem, após iniciar o container utilizando a opção <code class="language-plaintext highlighter-rouge">-d</code>, não haverá nenhuma saída do container na tela do computador hospedeiro. Desta forma, para ver o status do container é possível utilizar o <code class="language-plaintext highlighter-rouge">ps</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
7b4b0a3be0b5   ubuntu    "/bin/sh -c 'while t…"   9 seconds ago   Up 9 seconds             cont1
</span></code></pre></div></div>

<p>O comando anterior, mostra pelo status, que o container está em execução, à 9 segundos (<code class="language-plaintext highlighter-rouge">Up 9 seconds</code>). Todavia, o status não mostra o que está acontecendo dentro do container, para ter mais detalhes vamos ver o comando <code class="language-plaintext highlighter-rouge">logs</code> na seção a seguir.</p>

<h2 id="verificando-as-saídas-dos-containers-logs">Verificando as saídas dos containers (<code class="language-plaintext highlighter-rouge">logs</code>)</h2>

<p>Com o container sendo executado tal como um <em>daemon</em>, ou seja, em plano de fundo, o resultado da execução do container não aparecerá por padrão na tela do hospedeiro.</p>

<p>Todavia, é possível utilizar o comando <code class="language-plaintext highlighter-rouge">docker logs</code> para ver a saída de containers Docker que estão sendo executados como <em>daemons</em>.</p>

<p>::: important
O <code class="language-plaintext highlighter-rouge">docker logs</code> apenas apresenta a saída do container, ele não permite a interação com o mesmo (ex. digitar comandos no container).
:::</p>

<p>Desta forma, para ver o que está acontecendo no terminal do container do exemplo anterior, que está em <em>background</em>, podemos executar o seguinte comando:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker logs cont1
<span class="go">Olá mundo
Tue Jul 16 18:56:51 UTC 2024
Olá mundo
Tue Jul 16 18:57:01 UTC 2024
Olá mundo
Tue Jul 16 18:57:11 UTC 2024
Olá mundo
Tue Jul 16 18:57:21 UTC 2024
Olá mundo
Tue Jul 16 18:57:31 UTC 2024
Olá mundo
Tue Jul 16 18:57:41 UTC 2024
</span></code></pre></div></div>

<p>A saída anterior mostra que o <em>script</em> executado no container do exemplo anterior, está funcionando corretamente, pois está apresentando na tela o texto  “Olá mundo”, seguido da data/hora do container, a cada 10 segundos, tal como programado no <em>script</em>.</p>

<p>O comando <code class="language-plaintext highlighter-rouge">docker logs</code>, sem nenhuma opção, vai apresentar uma prévia da saída do container e parar. Caso seja necessário monitorar as saídas do container de forma continua, dá para utilizar a opção <strong><code class="language-plaintext highlighter-rouge">-f</code></strong>. Desta forma, as saídas do container ficam aparecendo na tela do hospedeiro, até o administrador pressionar <code class="language-plaintext highlighter-rouge">Ctrl+c</code>, para sair. Então para ter esse resultado o comando anterior ficaria da seguinte forma:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker logs <span class="nt">-f</span> cont1
<span class="go">Olá mundo
Tue Jul 16 18:56:51 UTC 2024
Olá mundo
Tue Jul 16 18:57:01 UTC 2024
Olá mundo
Tue Jul 16 18:57:11 UTC 2024
</span><span class="c">...
</span></code></pre></div></div>
<p>O comando <code class="language-plaintext highlighter-rouge">docker logs -f</code> é muito utilizado no dia a dia, pois permite o monitoramento continuo do container que está sendo executado no estilo <em>daemon</em>.</p>

<p>::: note
A opção <code class="language-plaintext highlighter-rouge">docker logs -f</code> é similar ao comando <code class="language-plaintext highlighter-rouge">tail -f</code>, utilizada para monitorar arquivos de <em>log</em> de sistemas Unix-Like. Lembre que é utilizado o <code class="language-plaintext highlighter-rouge">Ctrl+c</code> para sair desses comandos.
:::</p>

<h2 id="reiniciando-automaticamente-containers---restart">Reiniciando automaticamente containers (<code class="language-plaintext highlighter-rouge">--restart</code>)</h2>

<p>Os containers podem parar de funcionar por causa de algum erro inesperado e se ele tiver sendo executado em plano de fundo, você provavelmente não verá tal problema.</p>

<p>Então é possível iniciar o container informando, por exemplo, que se algo der errado, ele deve se auto reiniciar e isso é feito com a opção <strong><code class="language-plaintext highlighter-rouge">--restart</code></strong>. Desta forma, caso o programa executado pelo container termine normalmente ou termine devido à algum erro, o container vai reiniciar sozinho.</p>

<p>::: important
É importante perceber que o container sai do status de “em execução” para “parado”, devido à basicamente duas situações:</p>

<ul>
  <li>O programa que ele executa simplesmente terminou normalmente;</li>
  <li>Houve algum erro com o programa e por isso ele foi abortado.
:::</li>
</ul>

<p>Exitem algumas opções para o reinicio automático para containers Docker, sendo as mais comuns:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">always</code>: com esta opção, o container sempre será reinicializado, não importa o motivo (terminou normalmente ou por erro). Mesmo se o computador hospedeiro for reinicializado, o Docker vai iniciar novamente o container.</li>
  <li><code class="language-plaintext highlighter-rouge">unless-stopped</code>: similar ao <code class="language-plaintext highlighter-rouge">always</code>, mas neste caso o container não é reinicializado se estiver no estado de “parado” (ex. alguém parou o container com <code class="language-plaintext highlighter-rouge">docker stop</code>). Todavia, se o processo do Docker for reinicializado (ex. reinicializaram o computador hospedeiro), o container será religado.</li>
  <li><code class="language-plaintext highlighter-rouge">on-failure</code>: com esta opção, o container é reinicializado apenas se tiver um erro (<code class="language-plaintext highlighter-rouge">exit</code> diferente de zero). Nesta opção ainda dá para determinar o número de vezes que o container vai tentar religar, caso essa quantidade seja atingida ele desiste de religar.</li>
</ul>

<p>Para exemplificar o uso dessas funções do <code class="language-plaintext highlighter-rouge">restart</code>, vamos alterar um pouco o <em>script</em> utilizado no <code class="language-plaintext highlighter-rouge">cont1</code> (exemplo anterior). Vamos criar um novo container chamado <code class="language-plaintext highlighter-rouge">cont2</code>, que basicamente tem o mesmo <em>script</em> do <code class="language-plaintext highlighter-rouge">cont1</code>, só que adicionado um <code class="language-plaintext highlighter-rouge">exit 1</code>, após o “Olá mundo” e o resto continua como era antes. O objetivo aqui é simular um erro no <em>script</em>, já que quando o código chegar a linha do <code class="language-plaintext highlighter-rouge">exit 1</code>, ele determina que o <em>script</em> deve ser interrompido, e é retornado um 1 para o sistema (que representa um erro). Desta forma, o <em>script</em> nunca vai mostrar a data/hora, tal como fazia antes, já que o <code class="language-plaintext highlighter-rouge">exit</code> é executado antes.</p>

<p>A seguir são apresentados exemplos de opções para o uso do <code class="language-plaintext highlighter-rouge">restart</code> com esse novo <em>script</em> alterado:</p>

<h3 id="opção-always">Opção <code class="language-plaintext highlighter-rouge">always</code></h3>

<p>No exemplo a seguir é utilizada a opção <code class="language-plaintext highlighter-rouge">always</code> do <code class="language-plaintext highlighter-rouge">restart</code>, de forma que o container seja reinicializada toda vez que ele for encerrado (por erro ou porque o programa terminou normalmente):</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--restart</span><span class="o">=</span>always <span class="nt">--name</span> cont2 <span class="nt">-d</span> ubuntu /bin/sh <span class="nt">-c</span> <span class="s2">"while true; do echo Olá mundo; exit 1; date; sleep 10; done"</span>
<span class="go">6a17852229690344c0931d3fdcdd44775a17a79902d53bb70805b2ba43b7bd69
</span></code></pre></div></div>
<p>O comando anterior, mostra como utilizar a opção <code class="language-plaintext highlighter-rouge">--restart=always</code>. No comando também determinamos que o nome do container é <code class="language-plaintext highlighter-rouge">cont2</code>, que este deve ser executado em plano de fundo (<code class="language-plaintext highlighter-rouge">-d</code>), é criado a partir da imagem <code class="language-plaintext highlighter-rouge">ubuntu</code>, e principalmente está com o <em>script</em> alterado, que é abortado ao chegar no <code class="language-plaintext highlighter-rouge">exit</code>.</p>

<p>Assim, vamos utilizar a opção <code class="language-plaintext highlighter-rouge">log</code>, para ver a saída deste exemplo:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker logs <span class="nt">-f</span> cont2
<span class="go">Olá mundo
Olá mundo
Olá mundo
Olá mundo
Olá mundo
Olá mundo
Olá mundo
</span></code></pre></div></div>

<p>Dada a saída anterior, observa-se que o container <code class="language-plaintext highlighter-rouge">cont2</code> apresenta o texto “Olá mundo”, várias vezes, mas nunca a data/hora do sistema. Isso significa que o <em>script</em> é executado até o <code class="language-plaintext highlighter-rouge">echo Olá mundo</code> e é abortado. Desta forma, sem a opção <code class="language-plaintext highlighter-rouge">restart</code> o container seria encerrado, mas como estamos utilizando a opção <code class="language-plaintext highlighter-rouge">--restart=always</code>, o container é reiniciado toda vez que o <em>script</em> é finalizado pelo <code class="language-plaintext highlighter-rouge">exit</code>, esse comportamento vai se repetir indefinidamente.</p>

<h3 id="opção-on-failure">Opção <code class="language-plaintext highlighter-rouge">on-failure</code></h3>

<p>O exemplo a seguir mostra como é utilizada a opção <code class="language-plaintext highlighter-rouge">on-failure</code> do <code class="language-plaintext highlighter-rouge">restart</code>. Tal opção só reinicializa o container se o processo for finalizado com um <code class="language-plaintext highlighter-rouge">exit</code> maior que zero, ou seja, se o container for finalizado por causa de erros do programa sendo executado. Desta forma, se o programa terminar normalmente, o container não será reinicializado.</p>

<p>Para esse exemplo, foi criado um container chamado <code class="language-plaintext highlighter-rouge">cont3</code>, que fora o nome do container, a única diferença do exemplo anterior (<code class="language-plaintext highlighter-rouge">cont2</code>) é que foi utilizado a opção <code class="language-plaintext highlighter-rouge">--restart=on-failure:3</code>. Sendo que esse <code class="language-plaintext highlighter-rouge">:3</code>, na frente da opção, significa que ele só será reinicializado três vezes. Se for utilizado apenas o <code class="language-plaintext highlighter-rouge">--restart=on-failure</code>, sem nada na frente (ex. <code class="language-plaintext highlighter-rouge">:3</code>), ele será reinicializado de forma indefinida.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--restart</span><span class="o">=</span>on-failure:3 <span class="nt">--name</span> cont3 <span class="nt">-d</span> ubuntu /bin/sh <span class="nt">-c</span> <span class="s2">"while true; do echo Olá mundo; exit 1; date; sleep 10; done"</span>
<span class="go">857022977d13473202ce0ac1988a124ff76375dfc1326ff7c5eb4f50b24949c4
</span></code></pre></div></div>
<p>Depois de executar o comando para criar o container chamado <code class="language-plaintext highlighter-rouge">cont3</code>, vamos ver sua saída com o <code class="language-plaintext highlighter-rouge">logs</code>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker logs <span class="nt">-f</span> cont3
<span class="go">Olá mundo
Olá mundo
Olá mundo
Olá mundo
</span></code></pre></div></div>
<p>Dada a saída anterior, note que há quatro vezes o texto “Olá mundo”, então o container foi executado pela primeira vez, ai saiu com um <code class="language-plaintext highlighter-rouge">exit 1</code>, depois isso aconteceu mais três vezes e o container foi abortado (ficou no estado de parado).</p>

<p>Vamos executar os comandos para verificar o status dos containers criados até aqui, primeiro vamos ver os containers ativos:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS                          PORTS     NAMES
6a1785222969   ubuntu    "/bin/sh -c 'while t…"   About a minute ago   Restarting (1) 48 seconds ago             cont2
7b4b0a3be0b5   ubuntu    "/bin/sh -c 'while t…"   40 hours ago         Up 27 hours                               cont1
</span></code></pre></div></div>

<p>Note que estão ativos os containers <code class="language-plaintext highlighter-rouge">cont1</code> e <code class="language-plaintext highlighter-rouge">cont2</code>, ou seja, o <code class="language-plaintext highlighter-rouge">cont2</code> está em execução, mesmo que o seu processo esteja retornando erro em toda execução. Perceba que não há o container <code class="language-plaintext highlighter-rouge">cont3</code> na saída anterior, então  vamos ver se esse se encontra parado com o comando <code class="language-plaintext highlighter-rouge">docker ps -l</code>, já que este foi o último container que trabalhamos:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps <span class="nt">-l</span>
<span class="go">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS                      PORTS     NAMES
857022977d13   ubuntu    "/bin/sh -c 'while t…"   58 seconds ago   Exited (1) 56 seconds ago             cont3
</span></code></pre></div></div>

<p>A saída anterior, demonstra mais uma vez que a opção <code class="language-plaintext highlighter-rouge">--restart=on-failure:3</code> foi executada com sucesso, já que o <code class="language-plaintext highlighter-rouge">cont3</code> foi abortado/parado, depois de algumas execuções.</p>

<p>::: note
No comando anterior utilizamos <code class="language-plaintext highlighter-rouge">docker ps -l</code> para ver apenas o último container que foi abortado pelo Docker, pois como não há outros containers sabíamos que provavelmente o <code class="language-plaintext highlighter-rouge">cont3</code> era o último container que foi abortado.
:::</p>

<h2 id="deletando-containers-rm">Deletando containers (<code class="language-plaintext highlighter-rouge">rm</code>)</h2>

<p>Como descrito até aqui, uma vez que você execute um container, ele vai estar na lista de containers ativos ou parados, tal como pode ser visto a seguir, com os container que trabalhamos neste material:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps <span class="nt">-a</span>
<span class="go">CONTAINER ID   IMAGE                               COMMAND                  CREATED        STATUS                          PORTS     NAMES
857022977d13   ubuntu                              "/bin/sh -c 'while t…"   6 hours ago    Exited (1) 6 hours ago                    cont3
6a1785222969   ubuntu                              "/bin/sh -c 'while t…"   6 hours ago    Restarting (1) 55 seconds ago             cont2
7b4b0a3be0b5   ubuntu                              "/bin/sh -c 'while t…"   46 hours ago   Up 33 hours                               cont1
ebfc7d73bf3a   ubuntu                              "/bin/bash"              2 days ago     Exited (137) 47 hours ago                 strange_jang
06d326091537   luizarthur/cyberinfra:hostDeb11     "/gns3/init.sh bash"     7 weeks ago    Exited (137) 6 weeks ago                  admiring_burnell
</span></code></pre></div></div>

<p>Todavia, em alguns momentos vão haver containers que não vamos mais utilizar, como por exemplo containers de testes ou defasados. Assim, é possível remover esses containers utilizando o comando <code class="language-plaintext highlighter-rouge">rm</code> do Docker.</p>

<p>Por exemplo, vamos remover o container chamado <code class="language-plaintext highlighter-rouge">cont3</code>, para isso podemos utilizar o seguinte comando:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">rm </span>cont3
<span class="go">cont3
</span></code></pre></div></div>

<p>O resultado do comando será apenas uma saída com o nome do container, neste caso foi <code class="language-plaintext highlighter-rouge">cont3</code>. Neste exemplo anterior, utilizamos o nome do container para removê-lo, mas é possível utilizar o ID, vamos remover o primeiro container que criamos utilizando o ID dele, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">rm </span>ebfc7d73bf3a
<span class="go">ebfc7d73bf3a
</span></code></pre></div></div>

<p>Depois de remover o <code class="language-plaintext highlighter-rouge">cont3</code>, vamos tentar remover o <code class="language-plaintext highlighter-rouge">cont2</code>, entretanto o resultado para essa deleção será o seguinte:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">rm </span>cont2
<span class="go">Error response from daemon: cannot remove container "/cont2": container is restarting: stop the container before removing or force remove
</span></code></pre></div></div>

<p>A saída anterior informa que o <code class="language-plaintext highlighter-rouge">cont2</code> está configurado para reiniciar, assim é necessário primeiro pará-lo e depois removê-lo, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker stop cont2
<span class="go">cont2
</span><span class="gp">$</span><span class="w"> </span>docker <span class="nb">rm </span>cont2
<span class="go">cont2
</span></code></pre></div></div>

<p>Agora que os containers foram removidos, é possível constatar tal tarefa utilizando o comando <code class="language-plaintext highlighter-rouge">docker ps -a</code>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps <span class="nt">-a</span>
<span class="go">CONTAINER ID   IMAGE                               COMMAND                  CREATED        STATUS                     PORTS     NAMES
7b4b0a3be0b5   ubuntu                              "/bin/sh -c 'while t…"   47 hours ago   Up 33 hours                          cont1
06d326091537   luizarthur/cyberinfra:hostDeb11     "/gns3/init.sh bash"     7 weeks ago    Exited (137) 6 weeks ago             admiring_burnell
</span></code></pre></div></div>

<p>A saída anterior mostra que foram removidos: o primeiro container que criamos; <code class="language-plaintext highlighter-rouge">cont2</code> e <code class="language-plaintext highlighter-rouge">cont3</code>, ou seja, chegamos no resultado que queríamos para esses exemplos de remoção de containers.</p>

<p>Em alguns casos especiais é necessário <strong>remover todos os containers</strong>, mas não há um comando específico do Docker para tal tarefa. Assim, é possível combinar comandos, no estilo <em>shell script</em> para conseguir tal resultado, neste caso um possível comando no Linux seria:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">rm</span> <span class="nt">-f</span> <span class="si">$(</span>docker ps <span class="nt">-aq</span><span class="si">)</span>
</code></pre></div></div>

<p>No comando anterior, foram combinados os comandos <code class="language-plaintext highlighter-rouge">docker ps -aq</code>, que gera uma lista de ID (<code class="language-plaintext highlighter-rouge">-q</code>) de containers do Docker, depois cada item desta lista é executada pelo comando <code class="language-plaintext highlighter-rouge">docker rm</code>, é claro que esse comando deve ser utilizado com cautela, pois apaga todos os containers do sistema.</p>

<p>Também dá para iniciar um container com a opção <strong><code class="language-plaintext highlighter-rouge">--rm</code></strong>, desta forma o container é executado uma única vez, e quando o programa que ele está executando terminar, o container é imediatamente removido do sistema. Um exemplo de comando utilizando o <code class="language-plaintext highlighter-rouge">--rm</code> é:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> cont5 <span class="nt">-d</span> ubuntu /bin/sh <span class="nt">-c</span> <span class="s2">"echo Olá mundo"</span>
<span class="go">060e1626cd5e460ff6a9270da00ab350b9fbaea5d73841d5c50bfc6a5067fc09
</span></code></pre></div></div>

<p>Utilize o comando <code class="language-plaintext highlighter-rouge">docker ps -l</code> e você notará que o container <code class="language-plaintext highlighter-rouge">cont5</code>, criando anteriormente, não aparecerá na listagem de containers do sistema.</p>

<p>A opção <code class="language-plaintext highlighter-rouge">--rm</code> é muito útil durante a criação de containers de teste, pois assim que o container for encerrado o mesmo será removido e não vai ficar ocupando recursos dentro do sistema hospedeiro.</p>

<h2 id="rótulos-nos-containers--l">Rótulos nos containers (<code class="language-plaintext highlighter-rouge">-l</code>)</h2>

<p>Como uma das ideias principais de containers é utilizar vários desses, cada um provendo determinados serviços, é natural que exista algum tipo de recurso mínimo para ajudar à organizar os containers.</p>

<p>Bem, um desses recursos são os rótulos (<em>labels</em>), que servem como metadados que podem ajudar a identificar os containers, por exemplo, quais containers são de uma dada organização, ou quais containers estão relacionados a um dado serviço. Então para utilizar os <em>labels</em> no Docker basta utilizar a opção <strong><code class="language-plaintext highlighter-rouge">-l</code></strong>. Veja o exemplo a seguir:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">-l</span> teste <span class="nt">-d</span> ubuntu /bin/sh <span class="nt">-c</span> <span class="s2">"while true; do echo Olá mundo; date; sleep 10; done"</span>
<span class="go">937619dfdf891ef84a98ac94c3d60d1edae2cd0cc596ba8459b2afeaaa815d8b

</span><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">-l</span> teste <span class="nt">-d</span> ubuntu /bin/sh <span class="nt">-c</span> <span class="s2">"while true; do echo Olá mundo; date; sleep 10; done"</span>
</code></pre></div></div>
<p>Anteriormente são criados dois containers, esses basicamente executam o primeiro <em>script</em> que utilizamos de exemplo, não foram passados nomes para esses, utilizam a opção <code class="language-plaintext highlighter-rouge">--rm</code> para serem removidos quando forem desligados e principalmente para estes exemplo, utilizam uma <em>label</em> chamada “teste” (<code class="language-plaintext highlighter-rouge">-l teste</code>).</p>

<p>Desta forma, agora é possível utilizar tal <em>label</em> para localizar os containers, tal como:</p>

<pre><code class="language-container">$ docker ps -a -f label=teste
CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS     NAMES
496d3dc5d3dd   ubuntu    "/bin/sh -c 'while t…"   57 seconds ago       Up 56 seconds                 cranky_hodgkin
937619dfdf89   ubuntu    "/bin/sh -c 'while t…"   About a minute ago   Up About a minute             goofy_agnesi
</code></pre>

<p>Graças a esse rótulo, também é possível criar comandos mais complexos, tal como desligar todas os containers que tenham a <em>label</em> “teste”. O comando a seguir realiza essa tarefa:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker stop <span class="si">$(</span>docker ps <span class="nt">-q</span> <span class="nt">--filter</span> <span class="s2">"label=teste"</span><span class="si">)</span>
<span class="go">496d3dc5d3dd
937619dfdf89
</span></code></pre></div></div>

<p>Como foi utilizada a opção <code class="language-plaintext highlighter-rouge">--rm</code>, esses container também foram removidos da lista de containers do sistema.</p>

<p>::: note
É comum utilizar <em>labels</em> com mais de uma palavra separada por <code class="language-plaintext highlighter-rouge">=</code>, tal como <code class="language-plaintext highlighter-rouge">desenvolvimento=maria</code>.
:::</p>

<h2 id="criando-containers-create">Criando Containers (<code class="language-plaintext highlighter-rouge">create</code>)</h2>

<p>Para criar um container é possível utilizar o comando <code class="language-plaintext highlighter-rouge">run</code>, tal como já fizemos no início deste capítulo, ou utilizar o comando <code class="language-plaintext highlighter-rouge">create</code>.</p>

<p>A grande diferença é que o <code class="language-plaintext highlighter-rouge">create</code> só cria o container e não coloca ele em execução. Então, após criar tal container é bem provável que o administrador execute o comando <code class="language-plaintext highlighter-rouge">start</code>. Desta forma, ao executar o comando <code class="language-plaintext highlighter-rouge">run</code>, ele internamente está executando um <code class="language-plaintext highlighter-rouge">create</code> seguido do <code class="language-plaintext highlighter-rouge">start</code>.</p>

<p>O comando a seguir é um exemplo do uso do comando <code class="language-plaintext highlighter-rouge">create</code> para criar um container chamado <code class="language-plaintext highlighter-rouge">cont6</code>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker create <span class="nt">--name</span> cont6 ubuntu /bin/sh <span class="nt">-c</span> <span class="s2">"while true; do echo Olá mundo; date; sleep 10; done"</span>
</code></pre></div></div>

<p>Após executar o comando anterior, o status do container será de criado (<code class="language-plaintext highlighter-rouge">Created</code>), veja:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps <span class="nt">-l</span>
<span class="go">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS    PORTS     NAMES
931b22bca56f   ubuntu    "/bin/sh -c 'while t…"   10 seconds ago   Created             cont6
</span></code></pre></div></div>

<p>Todavia, o container do exemplo anterior, foi criado mas não está em execução, ou seja, está parado. Assim, para mudar o seu estado para em execução, é necessário executar um <code class="language-plaintext highlighter-rouge">start</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker start cont6
<span class="go">cont6
</span></code></pre></div></div>

<p>Desta forma o container irá para o estado de “executando” (<code class="language-plaintext highlighter-rouge">Up</code>), tal como apresentado na saída a seguir do comando <code class="language-plaintext highlighter-rouge">docker ps -l</code>, deste exemplo:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps <span class="nt">-l</span>
<span class="go">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
931b22bca56f   ubuntu    "/bin/sh -c 'while t…"   2 minutes ago   Up 5 seconds             cont6
</span></code></pre></div></div>

<p>É possível utilizar o <code class="language-plaintext highlighter-rouge">create</code> e <code class="language-plaintext highlighter-rouge">start</code> do Docker para criar containers, entretanto se for para criar o container e imediatamente colocá-lo em execução, é mais fácil/prático utilizar o comando <code class="language-plaintext highlighter-rouge">run</code>.</p>

<p>::: note
Após criar um container com o comando <code class="language-plaintext highlighter-rouge">create</code> do Docker, não é possível utilizar o comando <code class="language-plaintext highlighter-rouge">run</code>, para executar um container com o mesmo nome do container criado. Neste caso, será reportado um erro dizendo que o container já existe.
:::</p>

<h2 id="informações-dos-containers-inspect">Informações dos containers (<code class="language-plaintext highlighter-rouge">inspect</code>)</h2>

<p>Comando <code class="language-plaintext highlighter-rouge">inspect</code> do Docker, permite verificar a configuração completa do container. O <code class="language-plaintext highlighter-rouge">inspect</code>, mostrará as mais diversas informações do container, tal como: nome, configurações de rede, armazenamento, estado, imagem, comando, etc. Isso pode ser muito útil, por exemplo, para a depuração de erros, identificação ou criação de containers similares.</p>

<p>Para inspecionar um container utilizando o <code class="language-plaintext highlighter-rouge">inspect</code> é necessário apenas executar <code class="language-plaintext highlighter-rouge">docker inspect</code> seguido do nome ou ID do container, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect cont6
<span class="go">[
    {
        "Id": "931b22bca56f04add7b383e12a862cd3cd9ef1c582cb8136e5b5afb0a8f4b935",
        "Created": "2024-07-19T14:56:22.519662813Z",
        "Path": "/bin/sh",
        "Args": [
            "-c",
</span><span class="gp">            "while true;</span><span class="w"> </span><span class="k">do </span><span class="nb">echo </span>Olá mundo<span class="p">;</span> <span class="nb">date</span><span class="p">;</span> <span class="nb">sleep </span>10<span class="p">;</span> <span class="k">done</span><span class="s2">"
</span><span class="go">        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
</span><span class="c">            ...
</span><span class="go">        },
        "Image": "sha256:35a88802559dd2077e584394471ddaa1a2c5bfd16893b829ea57619301eb3908",
        "ResolvConfPath": "/var/lib/docker/containers/931b22bca56f04add7b383e12a862cd3cd9ef1c582cb8136e5b5afb0a8f4b935/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/931b22bca56f04add7b383e12a862cd3cd9ef1c582cb8136e5b5afb0a8f4b935/hostname",
</span><span class="c">        ...
</span><span class="go">        "Name": "/cont6",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
</span><span class="c">        ...
</span><span class="go">            "NetworkMode": "bridge",
            "PortBindings": {},
</span><span class="c">           ...
</span><span class="go">        "Config": {
            "Hostname": "931b22bca56f",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": true,
            "AttachStderr": true,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
</span><span class="gp">                "while true;</span><span class="w"> </span><span class="k">do </span><span class="nb">echo </span>Olá mundo<span class="p">;</span> <span class="nb">date</span><span class="p">;</span> <span class="nb">sleep </span>10<span class="p">;</span> <span class="k">done</span><span class="s2">"
</span><span class="go">            ],
            "Image": "ubuntu",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.opencontainers.image.ref.name": "ubuntu",
                "org.opencontainers.image.version": "24.04"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
</span><span class="c">            ...
</span><span class="go">            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.4",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:04",
</span><span class="c">            ...
</span><span class="go">            }
        }
    }
]
</span></code></pre></div></div>

<p>Como é possível ver na saída anterior, que inclusive teve partes omitidas, o <code class="language-plaintext highlighter-rouge">inspect</code> traz muitas informações a respeito do container. Neste exemplo, verificamos as informações do <code class="language-plaintext highlighter-rouge">cont6</code>, que foi criando na seção anterior. Por exemplo, no final da saída, é possível ver muitas configurações de rede do container, tais como: IP, <em>gateway</em> padrão, endereço MAC, etc.</p>

<p>Todas as informações do <code class="language-plaintext highlighter-rouge">inspect</code> são apresentadas no formato JSON, o que facilita a automação de extração dessas informações, inclusive utilizando-se <em>scripts</em>. Na verdade o próprio Docker fornece meios para filtrar as informações que podem ser obtidas do <code class="language-plaintext highlighter-rouge">inspect</code> (a quantidade de informações pode atrapalhar a visão e análise em determinadas tarefas). Por exemplo, para obter o endereço IP do container, é possível executar o seguinte comando:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect <span class="nt">--format</span> <span class="s1">''</span> cont6
<span class="go">172.17.0.4

</span></code></pre></div></div>

<p>Isso mostra que o <code class="language-plaintext highlighter-rouge">cont6</code> tem o IP 172.17.0.4. Com o comando anterior, note que foi utilizado <code class="language-plaintext highlighter-rouge">docker inspect</code>, com a opção <code class="language-plaintext highlighter-rouge">--format</code>, seguido da estrutura JSON que armazena a informação que estamos querendo, e no final o nome ou ID do container. Para encontrar essa estrutura você deve dar realizar o <code class="language-plaintext highlighter-rouge">inspect</code> e analisar a hierarquia do JSON, no exemplo anterior o <code class="language-plaintext highlighter-rouge">IPAddress</code> está sob <code class="language-plaintext highlighter-rouge">NetworkSettings</code>, assim ficou <code class="language-plaintext highlighter-rouge">.NetworkSettings.IPAddress</code>.</p>

<p>Vamos obter do container <code class="language-plaintext highlighter-rouge">cont6</code> qual é o comando que ele está executando, tal informação está em <code class="language-plaintext highlighter-rouge">Path</code> (ver primeira saída que geramos do <code class="language-plaintext highlighter-rouge">inspect</code>). Assim a busca por tal informação seria o seguinte comando:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect <span class="nt">--format</span> <span class="s1">''</span> cont6
<span class="go">/bin/sh
</span></code></pre></div></div>

<p>Repare na saída do <code class="language-plaintext highlighter-rouge">inspect</code> apresentada no início da seção, que basicamente a mesma informação a respeito do comando executado, também está em <code class="language-plaintext highlighter-rouge">Cmd</code>, que está dentro de <code class="language-plaintext highlighter-rouge">Config</code>, ai a busca seria com o seguinte comando:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect <span class="nt">--format</span> <span class="s1">''</span> cont6
<span class="gp">[/bin/sh -c while true;</span><span class="w"> </span><span class="k">do </span><span class="nb">echo </span>Olá mundo<span class="p">;</span> <span class="nb">date</span><span class="p">;</span> <span class="nb">sleep </span>10<span class="p">;</span> <span class="k">done</span><span class="o">]</span>
</code></pre></div></div>

<p>Também é possível pedir para o <code class="language-plaintext highlighter-rouge">inspect</code> retornar mais de uma informação na consulta, bem como fazer isso para mais de um container, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect <span class="nt">--format</span> <span class="s1">'  '</span> cont1 cont4
<span class="go">/cont1 exited ubuntu
/cont4 exited ubuntu
</span></code></pre></div></div>

<p>Na saída anterior, o <code class="language-plaintext highlighter-rouge">inspect</code> foi instruído para buscar nos containers <code class="language-plaintext highlighter-rouge">cont1</code> e <code class="language-plaintext highlighter-rouge">cont4</code>, as seguintes informações:</p>

<ul>
  <li>Nome do container (````);</li>
  <li>Estado (````);</li>
  <li>Imagem que está sendo utilizada (````).</li>
</ul>

<p>Novamente, este tipo de busca por informações específicas a respeito de containers, pode ser extremamente útil no dia a dia do administrador de sistemas, em processos como a criação de telas que mostram o status dos sistemas para identificação de falhas, etc. Então, entender o <code class="language-plaintext highlighter-rouge">inspect</code> e como utilizar seus filtros é muito importante, principalmente em ambientes com diversos containers.</p>

<h2 id="conclusão-do-capítulo">Conclusão do Capítulo</h2>

<p>Neste capítulo foram apresentados os comandos básicos para a criação e gerenciamento de containers Docker. Então, este capítulo abordou como realizar tarefas simples, como: criar containers, listar, parar/executar, remover, inspecionar, etc. Lembrando que apesar dessas tarefas serem rotineiras, conhecer bem como realizá-las é fundamental para o bom funcionamento do sistema.</p>

<p>Todavia ainda não aprendemos como trabalhar com as imagens Dockers, que são a base para a criação dos containers, isso será feito no [Capítulo @sec:imagens]. Depois disso o [Capítulo @sec:confAvancadas], abordará configurações e gerenciamento de containers para tarefas mais avançadas.</p>

<h1 id="sec:imagens">Imagens</h1>

<p>No capítulo anterior, foi apresentado o conceito de container, que é onde os aplicativos/serviços que estão sendo providos via Docker efetivamente são executados. Todavia, já no [Capítulo @sec:containers] foi citado que o container é criado utilizando-se imagens. Por exemplo, no comando: “<code class="language-plaintext highlighter-rouge">docker run -i -t ubuntu /bin/bash</code>”, o parâmetro “<code class="language-plaintext highlighter-rouge">ubuntu</code>” representa a imagem que serve de base para a criação do container Docker.
Assim, neste capítulo, vamos entender o que é uma imagem, como ela é utilizada pelo container, quais são as vantagens do uso das imagens Docker, bem como criar e gerenciar imagens Docker.</p>

<p>Em resumo, uma imagem Docker, nada mais é do que uma camada de sistema de arquivos, que pode ser empilhada uma sobre a outra.
Ou seja, inicialmente podemos pensar na imagem Docker, como sendo o sistema de arquivos que utilizaremos dentro do container Docker, tal como uma imagem ou HD virtual de VM completa (ex. VM do VirtualBox ou VMWare). Entretanto, é preciso ter em mente que há uma grande diferença entre uma imagem Docker e uma imagem de VM completa.</p>

<p>Por exemplo, imagine que criamos uma VM completa, utilizando VirtualBox, nesta VM instalamos o Arch Linux para ser o SO (Sistema Operacional), vamos chamar essa VM de VM0, e tal VM servirá de base para a criação de duas outras VMs. Desta forma, clonamos duas vezes a VM0 e criamos agora a VM1 e VM2 (ver [@fig:virtualBox]). Sendo que, na VM1 instalaremos o MariaDB para ser nosso banco de dados. Já na VM2, instalaremos o HTTP Apache.</p>

<p>Neste exemplo anterior, utilizando virtualização completa (<em>full virtualization</em>), perceba que agora temos três VMs e cada uma tem um HD virtual independente, no qual está instalado o sistema de arquivo, que é a base do Arch Linux. Tais HDs virtuais, na verdade, são arquivos do computador hospedeiro, esses arquivos normalmente têm alguns <em>gigabytes</em> de tamanho. Continuando o exemplo, vamos supor que o HD da VM0 tem 5GB, ai clonamos ele para criar a VM1 que por ser um clone da VM0 já tem 5GB, somado a mais 5GB do MariaDB, o que totaliza um uso de 10GB do HD virtual. Já para VM2, temos os 5GB iniciais do Arch (que já veio de “herança”) e vamos imaginar que foram instalados e armazenados mais uns 3GB de dados, então teremos o HD virtual da VM2 com 8GB. Assim sendo, neste exemplo temos três HDs virtuais com 5GB, 10GB e 8GB, o que totaliza 23GB que são consumidos por esses HDs virtuais do HD real da máquina hospedeira, tal como ilustrado na [@fig:virtualBox]. Concluindo esse exemplo, em um sistema de virtualização completa, cada VM tem um HD completo e isolado, não importa se isso veio de uma cópia/clone de outra VM, a nova VM será um sistema único ocupando os recursos do hospedeiro de forma completa e exclusiva.</p>

<p>::: note
Os espaços citados no exemplo para :Arch Linux, MariaDB e Apache HTTP, são meramente ilustrativos, ou seja, não correspondem ao mundo real.
:::</p>

<p><img src="imagens/virtualBox.png" alt="Virtualização completa com VirtualBox e HDs virtuais" />{#fig:virtualBox}</p>

<p>Todavia, o conceito de imagem utilizada no Docker é ligeiramente diferente do utilizado normalmente em sistemas de virtualização completa. Desta forma, podemos até pensar nas imagens Docker como se fossem HDs virtuais, mas é mais correto chamar de sistema de arquivos (vamos fazer isso a partir de agora). Assim, é possível criar um sistema de arquivos base e ir acoplando/sobrepondo outros sistemas de arquivos, sendo que neste contexto cada sistema de arquivos vai ser uma nova imagem e então teremos imagens sobrepostas.</p>

<p>Portanto, se pegarmos o mesmo exemplo anterior, só que utilizando imagens Docker, o cenários ficaria da seguinte forma: teríamos a imagem Arch Linux, que chamaremos de IMG0, com 5GB, que serviria de base para a criação da IMG1 e IMG2. Tais imagens são respectivamente equivalentes à VM0, VM1 e VM2. Então, pegamos de base a IMG0, instalamos o MariaDB e criamos a IMG1. Da mesma forma, pegamos a IMG0 de base, instalamos o Apache HTTP e criamos a VM2. Só que fazendo isso com imagens Docker, vai haver uma grande diferença quando comparado ao exemplo anterior com o VirtualBox, pois a IMG0 utiliza 5GB. Na IMG1, com a instalação do MariaDB e dados, tal imagem consumirá apenas 5GB no total e não 10GB (do exemplo com virtualização completa). Por fim, a IMG2 terá somente 3GB no total (e não 8GB), tal como ilustra a [@fig:docker1]. Ou seja, todas as imagens (IMG0, IMG1 e IMG2), consumirão da máquina hospedeira apenas 13GB de espaço em disco e não 23G, como foi feito utilizando o VirtualBox, sendo que isso é possível graças ao conceito de UFS (Union File System).</p>

<p><img src="imagens/docker1.png" alt="Docker e imagens" />{#fig:docker1}</p>

<h2 id="union-file-system---union-mount">Union File System - <em>union mount</em></h2>

<p>Para compreender como as imagens Docker funcionam é necessário entender o conceito de UFS (Union File System), comumente chamado de <em>union mount</em>.</p>

<p>Para falar de <em>union mount</em> é necessário primeiro lembrar que montar (<em>mount</em>) em ambientes Like-Unix, significa disponibilizar em um diretório do sistema, o conteúdo de partições de HDs, SSDs, <em>pendrives</em>, DVDs, etc.
Assim, quando se monta uma partição de um HD, por exemplo no diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, o conteúdo desta partição (arquivos e diretórios) aparecerão dentro do diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>. A [@fig:mount0]-a apresenta o diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, sem nenhum conteúdo (diretório vazio) antes da montagem. Já a [@fig:mount0]-b, mostra o diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code> após a montagem da partição de um HD, neste caso tal diretório apresenta conteúdo da partição do HD, que são os arquivos <code class="language-plaintext highlighter-rouge">Texto.txt</code> e <code class="language-plaintext highlighter-rouge">video.mp4</code>.</p>

<!--
![(a) Antes de montar partição do HD (b) Depois de montar partição do HD](imagens/mount1.png){#fig:mount1}
-->
<p>É muito importante saber, que se já houvesse algum conteúdo dentro de <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, antes da montagem, tal conteúdo ficaria oculto, indisponível e intocável durante todo o tempo que tal diretório permanecer montado.
Desta forma, se enquanto o conteúdo da partição do HD estiver montada em <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code> e posteriormente for montada o conteúdo de um <em>pendrive</em> no mesmo diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, tudo que for feito no diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code> afetará somente os arquivos do <em>pendrive</em>, pois o conteúdo da partição do HD estará oculta e protegida pelo processo de montagem.
A [@fig:mount0]-c mostra como ficará aos olhos do usuário o conteúdo do diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, quando montando o conteúdo de um <em>pendrive</em> no mesmo diretório onde já estava montada a partição do HD. Já a [@fig:mount0]-d, apresenta que na verdade o conteúdo do HD ainda está associado ao diretório, mas o mesmo não fica acessível enquanto o <em>pendrive</em> permanecer montado.
Todavia, quando o conteúdo da partição do HD volta a aparecer no diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, asim que o <em>pendrive</em> for desmontado, como se nada houvesse acontecido.</p>

<!--
![(a) Pendrive montado (b) Arquivos da partição do HD ficam indisponíveis](imagens/mount2.png){#fig:mount2}
-->

<p>A diferença do <em>union mount</em> para o <em>mount</em> tradicional, é que o <em>union mount</em> permite montar vários sistemas de arquivos em um ponto de montagem (diretório), deixando o conteúdo de todos esses sistemas de arquivos disponíveis simultaneamente. Ou seja, utilizando o <em>union mount</em> é possível montar, o conteúdo de uma partição de HD no diretório <code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>, mas agora se for montado o conteúdo de um <em>pendrive</em> no mesmo diretório (<code class="language-plaintext highlighter-rouge">/mnt/meuTeste</code>), ficará visível e acessível tanto o conteúdo da partição do HD, quanto o conteúdo do <em>pendrive</em>, desta forma o usuário deste sistema poderia trabalhar em ambos dispositivos de armazenamento (<em>pendrive</em> e partição do HD) simultaneamente no mesmo diretório (o que não era possível no <em>mount</em> tradicional). A [@fig:mount0]-e, apresenta esse comportamento do <em>union mount</em>. É importante entender aqui, que caso exista arquivos com o mesmo <em>path</em>, por exemplo <code class="language-plaintext highlighter-rouge">/texto.txt</code> na partição do HD e um arquivo <code class="language-plaintext highlighter-rouge">/texto.txt</code> no pendrive, ficará acessível apenas o arquivo do dispositivo que foi montado por último.
<!--
![Com *union mount* arquivos de HD e pendrive ficam disponíveis simultaneamente](imagens/mount3.png){#fig:mount3}
--></p>

<p><img src="imagens/mount0.svg" alt="(a) Antes de montar partição do HD (b) Depois de montar partição do HD (c) Pendrive montado (d) Arquivos do HD ficam indisponíveis no diretório (e) *union mount*" />{#fig:mount0}</p>

<p>::: note
Para realizar um <em>union mount</em> no Linux, é possível utilizar, por exemplo, o <code class="language-plaintext highlighter-rouge">unionfs</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span>unionfs <span class="nt">-o</span> cow teste1/<span class="o">=</span>RW:teste2/<span class="o">=</span>RO testeTodos/
</code></pre></div></div>

<p>Neste exemplo, o conteúdo dos diretórios <code class="language-plaintext highlighter-rouge">teste1/</code> e <code class="language-plaintext highlighter-rouge">teste2/</code> são montados dentro de <code class="language-plaintext highlighter-rouge">testeTodos/</code>, tudo que for alterado em <code class="language-plaintext highlighter-rouge">testeTodos/</code> será gravado em <code class="language-plaintext highlighter-rouge">teste1/</code>, que foi definido com permissão de leitura e gravação (<code class="language-plaintext highlighter-rouge">RW</code>).
:::</p>

<p>O Docker suporta várias implementações do <em>mount union</em>, tais como: AUFS, Overlay, devicemapper, BTRFS e ZFS. A implementação utilizada por cada Docker pode ser vista com o comando <code class="language-plaintext highlighter-rouge">docker info</code>, na saída procure por <code class="language-plaintext highlighter-rouge">Storage Driver</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker info | <span class="nb">grep</span> <span class="nt">-i</span> <span class="s2">"storage driver"</span>
<span class="go"> Storage Driver: overlay2
</span></code></pre></div></div>

<p>Na saída anterior, a máquina na qual o comando foi executado, está utilizando o Overlay para tecnologia UFS, ou seja, para realizar <em>union mount</em>.</p>

<p>Agora, sabendo como funciona o UFS ou <em>union mount</em>, podemos dizer que o Docker utiliza tal técnica para agregar imagens e assim economizar espaço em disco, bem como facilitar a distribuições e escalabilidade dessas imagens, o que torna o Docker muito eficiente em comparação com sistemas de virtualização completos (ex. VirtualBox, VMWare, etc).</p>

<p>Desta forma, utilizando UFS, os containers Docker normalmente têm várias camadas de imagens, visando compor o container final de forma mais prática e eficiente. Veja na [@fig:imagensCamadas] como poderia ser composta as camadas de imagens de um container, bem como a descrição dessas no texto a seguir:</p>

<ul>
  <li>A primeira camada, ou seja imagem, será o sistema de arquivos de <em>boot</em>, conhecido como <em>bootfs</em>. De forma simplista, vamos imaginar que nesta imagem está apenas o <em>kernel</em> Linux;</li>
  <li>A próxima camada será, por exemplo, a base de alguma distribuição Linux, tal como o Arch, Ubuntu, CentOS, etc;</li>
  <li>Na sequência poderia ter uma camada com as ferramentas/comandos que o administrador acha que deve ter em todos os container, tais como: <code class="language-plaintext highlighter-rouge">vim</code>, <code class="language-plaintext highlighter-rouge">iproute2</code>, <code class="language-plaintext highlighter-rouge">tcpdump</code>, <code class="language-plaintext highlighter-rouge">htop</code>, etc;</li>
  <li>Depois, pode vir o serviço que se espera daquela imagem, tal como o Apache HTTP;</li>
  <li>Por fim, viria a camada na qual o container pode gravar/alterar arquivos/diretórios.</li>
</ul>

<p><img src="imagens/imagensCamadas.svg" alt="Exemplo de camadas de imagens Docker em um container" />{#fig:imagensCamadas}</p>

<p>Levando em consideração o exemplo da [@fig:imagensCamadas], note que a primeira camada (Camada 1 da [@fig:imagensCamadas]) é o <em>kernel</em>, que na verdade é compartilhado com o sistema hospedeiro. Já a Camada 2. Desta forma, o <em>kernel</em> sempre será compartilhado do hospedeiro com todos os containers, já a distribuição Linux pode ser qualquer uma (a gosto do administrador).
Após o <em>kernel</em> e a base da distribuição, normalmente começam a surgir várias camadas, conforme a necessidade/estratégia do administrador do sistema, por exemplo, caso ele queira que determinadas ferramentas estejam em todos os containers derivados, ele pode instalar tais ferramentas neste momento, tal como foi feito na Camada 3. Ainda seguindo o exemplo, a próxima camada (Camada 4) contém a instalação do Apache HTTP, então essa imagem provavelmente é de um servidor HTTP, que poderia por exemplo, receber mais imagens, para formar servidores PHP, JSP, JavaScript, etc.
Da mesma forma, o administrador, poderia pegar a partir da Camada 3 e adicionar uma imagem para um servidor de banco de dados, etc.
Já no topo das imagens, quando o container for iniciado, vai ficar uma imagem com permissão de leitura e gravação, que será o espaço no qual os arquivos criados ou alterados pelo container serão armazenados, essa técnica chama-se CoW (<em>Copy-on-Write</em>), ver Camada 5 da [@fig:imagensCamadas]. Lembrando que aqui estamos apresentando só um exemplo de como poderiam ser organizadas as camadas, ou seja, cada imagem de container pode seguir uma ordem de sequência de imagem diferente.</p>

<h3 id="cow-copy-on-write">CoW (<em>Copy-on-Write</em>)</h3>

<p>No conceito de <strong><em>Copy-on-Write</em></strong>, todas as imagens abaixo da última, estarão com permissão de somente leitura (RO), isso vai proteger a imagem de alterações e garantir que a imagem é a mesma para todos que a utilizarem. Já a última camada, tem permissão de leitura e gravação (RW). Desta forma, arquivos novos são gravados nesta imagem, da mesma forma, se algum arquivo das imagens a baixo forem alterados, será criado uma cópia deste arquivo na imagem superior, que então ocultará o arquivo da imagem original e apresentará para o sistema/usuário apenas o arquivo alterado que agora está na imagem com permissão de leitura e gravação. O CoW trabalha em conjunto com a técnica de <em>union mount</em>, explicada anteriormente.</p>

<p>::: important
O <em>union mount</em> permite montar várias imagens de forma que todas fiquem acessíveis simultaneamente em um mesmo ponto de montagem (diretório), só que normalmente apenas a última imagem é que terá permissão de gravação e escrita, já as camadas abaixo dessa terão permissão apenas de leitura. Quando algum arquivo/diretório de uma camada abaixo precisar ser alterado/escrito, a técnica de CoW copiará tal arquivo alterado para a última imagem, que normalmente representa o container. Isso garante a integridade dos arquivo para containers que utilizam as mesmas imagens e da mesma forma permite que o container tenha a capacidade de alterar completamente e livremente a estrutura de arquivos e diretórios ele está trabalhando.
:::</p>

<p>Então containers mantém as alterações realizadas no sistema de arquivos deles, permitindo assim salvar por exemplo configurações referentes aquele container (ex. IP, rota padrão, usuários, etc), bem como alterações realizadas por aquele container em arquivos que inicialmente eram da imagem, mas que agora fazem parte daquele container. Já a imagem utilizada para criar o container fica intocada, pois uma imagem Docker é imutável.</p>

<p>Agora sabendo como funcionam as imagens Docker e quais são as técnicas empregadas nessas imagens, vamos abordar como utilizar e configurar tais imagens na prática.</p>

<h2 id="listando-imagens-images">Listando imagens (<code class="language-plaintext highlighter-rouge">images</code>)</h2>

<p>Para listar as imagens disponíveis no próprio <em>host</em> hospedeiro, é possível utilizar o comando <code class="language-plaintext highlighter-rouge">docker images</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker images
<span class="go">REPOSITORY              TAG           IMAGE ID       CREATED        SIZE
ubuntu                  latest        35a88802559d   2 months ago   78MB
luizarthur/cyberinfra   routerDeb11   28b009432f01   4 months ago   391MB
luizarthur/cyberinfra   hostDeb11     da504d85c4c9   4 months ago   278MB
debian                  11            57a92962dbeb   4 months ago   124MB
archlinux               latest        0cda8061254a   5 months ago   436MB
</span></code></pre></div></div>

<p>A saída da listagem de imagens apresentada no exemplo anterior, mostra as imagens por linhas, sendo que cada coluna apresenta as seguintes informações:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">REPOSITORY</code>: é o repositório de onde a imagem foi derivada;</li>
  <li><code class="language-plaintext highlighter-rouge">TAG</code>: é um nome para identificar/nomear o repositório, isso pode por exemplo ajudar a controlar versões;</li>
  <li><code class="language-plaintext highlighter-rouge">IMAGE ID</code>: identificador único da imagem, em nível global (é um <em>hash</em>);</li>
  <li><code class="language-plaintext highlighter-rouge">CREATED</code>: informa a data que a imagem foi criada;</li>
  <li><code class="language-plaintext highlighter-rouge">SIZE</code>: tamanho da imagem - quanto ela ocupa no disco.</li>
</ul>

<p>As imagens ficam armazenadas normalmente dentro do diretório <code class="language-plaintext highlighter-rouge">/usr/lib/docker</code>, sendo que dentro deste diretório as imagens devem estar dentro dos subdiretórios <code class="language-plaintext highlighter-rouge">overlay2</code>, <code class="language-plaintext highlighter-rouge">aufs</code>, <code class="language-plaintext highlighter-rouge">btrfs</code>, dentre outros, dependendo o tipo de armazenamento Docker utilizado.</p>

<p>Por exemplo, o conteúdo do diretório <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code>, do <em>host</em> a seguir é:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">ls</span> /var/lib/docker/
<span class="go">buildkit  containerd  containers  engine-id  image  network  overlay2  plugins	runtimes  swarm  tmp  trust  volumes
</span></code></pre></div></div>

<p>Dentro do subdiretório <code class="language-plaintext highlighter-rouge">/var/lib/docker/overlay2/</code> ficará as camadas das imagens utilizadas no Docker (neste caso o <em>host</em> utiliza o <code class="language-plaintext highlighter-rouge">overlay2</code>), então um exemplo de saída deste diretório seria:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">ls</span> /var/lib/docker/overlay2/
<span class="go">00b33f7e6620ec4c3b874db4dbdac73e4ac79b3ba28414376be5641182c1381e       9b41a116168f228375439a9a3cd637171657966d91a1322df6ec8ec41778663c
032c162f754771188907fdb019c3e48df5965e05dd05100b08f999b644e266fb       9b41a116168f228375439a9a3cd637171657966d91a1322df6ec8ec41778663c-init
046c72f791a385eff6aea070a3acd52a47b9b8b815a82ee71436e1278a6e3d5d       9f9d469612856b3ba95bd9257b971b8bb821457c862c50c4f11353f9e7510452
046c72f791a385eff6aea070a3acd52a47b9b8b815a82ee71436e1278a6e3d5d-init  a4da83df821bbaaa6f2833864b3cf765713a2919039547966283bb5e4e1f5541
</span><span class="c">...
</span></code></pre></div></div>

<p>Já o diretório <code class="language-plaintext highlighter-rouge">/var/lib/docker/image/</code> contém metadados a respeito das imagens. No exemplo a seguir é possível ver que o <em>host</em> têm como subdiretório de <code class="language-plaintext highlighter-rouge">image</code> um diretório chamado <code class="language-plaintext highlighter-rouge">overlay2</code>, que por sua vez tem diretórios e arquivos com os dados a respeito das imagens:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">ls</span> /var/lib/docker/image/
<span class="go">overlay2

</span><span class="gp">#</span><span class="w"> </span><span class="nb">ls</span> <span class="nt">-l</span> /var/lib/docker/image/overlay2/
<span class="go">total 16
drwx------ 4 root root 4096 Jun 21  2021 distribution
drwx------ 4 root root 4096 Jun 21  2021 imagedb
drwx------ 5 root root 4096 Jun 21  2021 layerdb
-rw------- 1 root root 2214 Aug 13 11:20 repositories.json
</span></code></pre></div></div>

<p>A princípio, tais arquivos não devem ser editados manualmente, pois são mantidos de forma automática pelo próprio Docker.</p>

<p>::: note
Os arquivos dos containers ficam normalmente no diretório <code class="language-plaintext highlighter-rouge">/var/lib/docker/containers/</code>.
:::</p>

<h2 id="de-onde-vêm-as-imagens-docker">De onde vêm as imagens Docker?</h2>

<p>Estamos falando das imagens Docker, mas como fazer ou obter uma imagem Docker?</p>

<p>A reposta é: “você pode fazer a sua própria imagem, ou baixá-las de algum repositório”.</p>

<p>Então há basicamente duas formas obter e utilizar imagens Docker, que são:</p>

<ul>
  <li>
    <p><strong>Obtendo imagens de repositórios</strong>, tais como o <a href="https://hub.docker.com/">Docker Hub</a>. Neste exemplo o Docker Hub, é um repositório para imagens Dockers, no qual é possível compartilhar, armazenar e distribuir imagens Dockers utilizando, repositórios públicos ou privados;</p>
  </li>
  <li>
    <p><strong>Criando sua própria imagem</strong>. Para criar-se uma imagem, normalmente é utilizada imagem pré-existente geralmente obtida de um repositório. É claro que é possível criar uma imagem Docker do zero, sem utilizar outra imagem pré-existente, todavia uma das grandes vantagens do Docker é justamente poder reutilizar imagens já criadas, o que torna tudo muito mais fácil.</p>
  </li>
</ul>

<p>É necessário observar que o conceito de repositórios de imagens Docker são um grande atrativo para o uso do Docker, pois torna-se muito fácil criar, gerenciar e distribuir imagens. Dada essa afirmação/constatação, não faz muito sentido não utilizar os repositórios. Assim, o texto a seguir mescla a criação de imagens manualmente com o uso de repositórios, já que isso é o mais natural dentro do mundo Docker.</p>

<h2 id="procurando-imagens-no-docker-hub-search">Procurando imagens no Docker Hub (<code class="language-plaintext highlighter-rouge">search</code>)</h2>

<p>O <a href="https://hub.docker.com/">Docker Hub</a> é similar ao <a href="https://github.com/">GitHub</a>, só que o GitHub é uma plataforma que mantém códigos-fonte, ou seja, repositórios de projetos de programação. Já o Docker Hub faz a mesma coisa, só que com imagens Dockers, que podem ser simplesmente a imagem de um Linux básico (que serve de base para outras imagens) ou de imagens mais complexas contento por exemplo um sistema completo de uma empresa.</p>

<p>Ainda comparando o GitHub com o Docker Hub, uma das grandes vantagens de se disponibilizar um projeto de software via Docker Hub e não GitHub, é que quem baixar a imagem já tem o ambiente completo e funcional para executar tal projeto. O que não acontece no GitHub, pois nesse é necessário geralmente, baixar o projeto, resolver as dependências (instalar softwares e bibliotecas necessários para o projeto) e só então tentar executá-lo. É claro que na prática, o objetivo do GitHub e do Docker Hub são diferentes (eles não competem entre-si), na verdade um complementa o outro.</p>

<p>::: note
Há outros repositórios similares ao Docker Hub, tais como: <a href="https://quay.io/">Quay</a>, <a href="https://cloud.google.com/artifact-registry?hl=pt-br">Google Container Registry - GCR</a>, <a href="https://aws.amazon.com/pt/ecr/">Amazon Elastic Container Registry - ECR</a>, <a href="https://azure.microsoft.com/en-us/products/container-registry/">Azure Container Registry - ACR</a>, <a href="https://docs.gitlab.com/ee/user/packages/container_registry/">GitLab Container Registry</a> e <a href="https://goharbor.io/">Harbor</a>. Todavia neste texto vamos nos concentrar no Docker Hub.
:::</p>

<p>Assim, para obter imagens do Docker Hub é possível pesquisar por essas no sítio Web do Docker Hub (<a href="https://hub.docker.com/search">https://hub.docker.com/search</a>). A [@fig:dockerHubBusca] ilustra a busca por imagens Dockers relacionadas com “Fedora” na tentativa de encontrar uma imagem do Fedora Linux.</p>

<p><img src="imagens/dockerHub1.png" alt="Busca por imagens no Docker Hub" />{#fig:dockerHubBusca}</p>

<p>Já a [@fig:dockerHubBusca] mostra as informações do repositório Docker escolhido após a busca anterior.</p>

<p><img src="imagens/dockerHub2.png" alt="Imagem do Fedora Linux no Docker Hub" />{#fig:dockerHubArch}</p>

<p>Além de realizar a busca direta no sítio Web, também é possível realizar tal busca utilizando o comando <code class="language-plaintext highlighter-rouge">docker search</code> seguido do termo de busca. No exemplo a seguir buscamos novamente por “fedora”, só que agora via console:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span>docker search fedora
<span class="go">NAME                         DESCRIPTION                                     STARS     OFFICIAL
fedora                       Official Docker builds of Fedora                1213      [OK]
ustclug/fedora               Official Fedora Image with USTC Mirror          0
srcml/fedora                 Build, package, and test srcml on Fedora        0
mdsplus/fedora                                                               0
kasmweb/fedora-39-desktop    Fedora 39 desktop for Kasm Workspaces           0
kasmweb/fedora-40-desktop    Fedora 40 desktop for Kasm Workspaces           1
</span></code></pre></div></div>

<h2 id="obtendo-imagens-do-docker-hub-pull">Obtendo imagens do Docker Hub (<code class="language-plaintext highlighter-rouge">pull</code>)</h2>

<p>Bem, depois de encontrar a imagem via sítio Web ou repositório, é possível obter essa imagem Docker realizando um <code class="language-plaintext highlighter-rouge">docker pull</code>. Note que na [@fig:dockerHubBusca], via sítio Web, que há uma opção para já copiar (<em>copy</em>) o comando necessário para baixar a imagem do <code class="language-plaintext highlighter-rouge">fedora</code> encontrada, então vamos executar tal comando:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker pull fedora
<span class="go">Using default tag: latest
latest: Pulling from library/fedora
f7bb57d05c2a: Pull complete
Digest: sha256:b7b4b222c2a433e831c006a49a397009640cc30e097824410a35b160be4a176b
Status: Downloaded newer image for fedora:latest
docker.io/library/fedora:latest
</span></code></pre></div></div>

<p>A saída do comando anterior mostra que a imagem Docker, foi do Docker Hub com sucesso. Para constatar isso podemos pedir para listar as imagens, e lá deve aparecer uma linha do repositório do <code class="language-plaintext highlighter-rouge">fedora</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker images
<span class="go">REPOSITORY              TAG           IMAGE ID       CREATED        SIZE
fedora                  latest        9146ee7fcff0   3 days ago     222MB
ubuntu                  latest        35a88802559d   2 months ago   78MB
luizarthur/cyberinfra   routerDeb11   28b009432f01   4 months ago   391MB
</span><span class="c">...
</span></code></pre></div></div>
<p>Depois de obter a imagem é possível utilizá-la, por exemplo iniciando um container, tal como já fizemos nos capítulos anteriores:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--name</span> meuFedora <span class="nt">-ti</span> fedora /bin/bash
<span class="gp">[root@19bad3150dfa /]#</span><span class="w"> </span>yum <span class="nt">--version</span>
<span class="go">4.19.0
  Installed: dnf-0:4.19.0-1.fc40.noarch at Sun Apr 14 22:54:24 2024
  Built    : Fedora Project at Thu Feb  8 16:33:42 2024

  Installed: rpm-0:4.19.1.1-1.fc40.x86_64 at Sun Apr 14 22:54:24 2024
  Built    : Fedora Project at Wed Feb  7 15:55:53 2024
</span><span class="gp">[root@19bad3150dfa /]#</span><span class="w"> </span><span class="nb">uname</span> <span class="nt">-a</span>
<span class="gp">Linux 19bad3150dfa 6.10.6-arch1-1 #</span>1 SMP PREEMPT_DYNAMIC Mon, 19 Aug 2024 17:02:39 +0000 x86_64 GNU/Linux
<span class="gp">[root@19bad3150dfa /]#</span><span class="w">
</span></code></pre></div></div>

<p>No comando anterior, ligamos um container chamado <code class="language-plaintext highlighter-rouge">meuFedora</code> com a imagem do Fedora Linux, que obtivemos anteriormente. Nesta foi executado o comando <code class="language-plaintext highlighter-rouge">yum</code> o que mostra que estamos em um ambiente que utiliza ferramentas de instalação do Fedora, mesmo estando em um <em>host</em> que é Arch Linux (ou seja, não tem <code class="language-plaintext highlighter-rouge">yum</code>).</p>

<h2 id="criando-imagens-commit-e-build">Criando imagens (<code class="language-plaintext highlighter-rouge">commit</code> e <code class="language-plaintext highlighter-rouge">build</code>)</h2>

<p>Como vimos anteriormente é possível obter uma imagem existente de um repositório, tal como o Docker Hub, todavia em algum momento será necessário modificar a imagem para que essa atenda necessidades específicas de empresas ou pessoas. Neste caso há duas formar de criar imagens:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">docker commit</code>, sendo que este método cria uma imagem a partir de um container existente. Tal método permite que se faça alterações manuais dentro do container (interagindo com o <code class="language-plaintext highlighter-rouge">bash</code>, por exemplo). Após todas as alterações necessárias, o administrador salvará o estado atual desse container, gerando uma nova imagem;</li>
  <li><code class="language-plaintext highlighter-rouge">docker build</code>, nesta forma a imagem será criada a partir das instruções contidas em um arquivo chamado Dockerfile, tal arquivo é basicamente um <em>script</em> que contém sequências de instruções para configurar a imagem Docker.</li>
</ul>

<p>Note que o <code class="language-plaintext highlighter-rouge">commit</code> a principio pode ser mais simples que o <code class="language-plaintext highlighter-rouge">build</code>, todavia ele não documenta as alterações feitas na imagem, isso compromete o registro das alterações da imagem e pode atrapalhar o gerenciamento da imagem.
Já o <code class="language-plaintext highlighter-rouge">build</code>, inicialmente é mais complexo, pois exige que o administrador do sistema compreenda os comandos do arquivo Dockerfile, mas a longo prazo o gerenciamento dessas imagens ficam mais simples. Desta forma, o método mais recomendado para criar imagem é o <code class="language-plaintext highlighter-rouge">build</code>.</p>

<h3 id="criando-imagens-com-o-commit">Criando imagens com o <code class="language-plaintext highlighter-rouge">commit</code></h3>

<p>Vamos iniciar criando imagens utilizando o <code class="language-plaintext highlighter-rouge">commit</code>, pois isso é mais intuitivo a principio. Desta forma, espera-se que tenhamos um container em execução e que vamos alterar coisas dentro desse container (na imagem dele) e depois vamos salvar essa imagem alterada.</p>

<p>Então como exemplo, vamos iniciar um container e depois vamos instalar alguns pacotes nele, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--name</span> meuFedoraApache <span class="nt">-ti</span> fedora /bin/bash
<span class="go">
</span><span class="gp">[root@f768497f72b7 /]#</span><span class="w"> </span>dnf update
<span class="c">...
</span><span class="gp">[root@f768497f72b7 /]#</span><span class="w"> </span>dnf <span class="nb">install </span>httpd
<span class="c">...
</span><span class="gp">[root@f768497f72b7 /]#</span><span class="w"> </span>dnf <span class="nb">install </span>net-tools
<span class="c">...
</span><span class="gp">[root@f768497f72b7 /]#</span><span class="w"> </span>/usr/sbin/httpd
</code></pre></div></div>

<p>No container anterior, utilizamos a imagem do <code class="language-plaintext highlighter-rouge">fedora</code> para iniciar um container chamado <code class="language-plaintext highlighter-rouge">meuFedoraApache</code>, depois utilizando o comando <code class="language-plaintext highlighter-rouge">dnf</code>, realizamos uma atualização do sistema e em seguida instalamos os pacotes <code class="language-plaintext highlighter-rouge">httpd</code> e <code class="language-plaintext highlighter-rouge">net-tools</code>, esses respectivamente são: o servidor Apache HTTP e alguns comandos de rede (<code class="language-plaintext highlighter-rouge">ifconfig</code>, <code class="language-plaintext highlighter-rouge">netstat</code>, etc). Por fim, iniciamos o <code class="language-plaintext highlighter-rouge">httpd</code> que acabamos de instalar.</p>

<p>::: note
Não precisaria instalar o <code class="language-plaintext highlighter-rouge">net-tools</code> para o Apache funcionar, isso só foi feito para poder ver o IP do container e se o Apache está em execução com o <code class="language-plaintext highlighter-rouge">netstat</code>.</p>

<p>Com esses passos podemos ver o servidor HTTP em execução no container em questão (veja o IP do container e digite esse em seu navegador Web).
:::</p>

<p>Agora, com o container já configurado da forma que esperávamos, vamos gerar uma imagem a partir desse container. Para isso precisamos abrir outro terminal (<strong>não no terminal do container</strong>) e executar:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker commit meuFedoraApache servidor/fedora_apache
<span class="go">sha256:8bcfdd9d6660954b2645e72185fb086071e1aeca519c93b3bd50aa6b0b363ff7
</span></code></pre></div></div>

<p>No exemplo que estamos seguindo, utilizamos o container <code class="language-plaintext highlighter-rouge">meuFedoraApache</code>, para criar uma imagem chamada <code class="language-plaintext highlighter-rouge">servidor/fedora_apache</code>. Tal imagem agora pode ser vista na lista de imagens que temos localmente, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker images
<span class="go">REPOSITORY               TAG           IMAGE ID       CREATED         SIZE
servidor/fedora_apache   latest        8bcfdd9d6660   5 minutes ago   512MB
fedora                   latest        9146ee7fcff0   3 days ago      222MB
ubuntu                   latest        35a88802559d   2 months ago    78MB
luizarthur/cyberinfra    routerDeb11   28b009432f01   4 months ago    391MB
</span><span class="c">...
</span></code></pre></div></div>

<p>Agora podemos utilizá-la para por exemplo iniciar um novo container com um servidor Apache em execução, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> servidorFedApache <span class="nt">-d</span> servidor/fedora_apache /usr/sbin/httpd <span class="nt">-DFOREGROUND</span>
<span class="go">4d76b05803d3757975f58199b97c023240763577884bec435d6fc1eec6bd6784
</span></code></pre></div></div>

<p>Então o comando anterior, executa um container chamado <code class="language-plaintext highlighter-rouge">servidorFedApache</code>, a partir da imagem <code class="language-plaintext highlighter-rouge">servidor/fedora_apache</code> (que criamos via <code class="language-plaintext highlighter-rouge">commit</code>) e executa o servidor HTTP (<code class="language-plaintext highlighter-rouge">/usr/sbin/httpd -DFOREGROUND</code>).</p>

<p>::: important
Note que foi necessário utilizar a opção <code class="language-plaintext highlighter-rouge">-DFOREGROUND</code>, para o container não terminar devido ao Apache executar em plano de fundo.
:::</p>

<p>Após isso podemos ver tal container em execução:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS     NAMES
4d76b05803d3   servidor/fedora_apache   "/usr/sbin/httpd -DF…"   2 seconds ago    Up 1 second               servidorFedApache
f768497f72b7   fedora                   "/bin/bash"              48 minutes ago   Up 20 minutes             meuFedoraApache
</span></code></pre></div></div>

<p>Também podemos ver o IP desse container e acessá-lo via navegador Web, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect servidorFedApache | <span class="nb">grep</span> <span class="nt">-i</span> <span class="se">\"</span>IPAddress
<span class="go">            "IPAddress": "172.17.0.3",
</span></code></pre></div></div>

<p>Depois seria só inserir o IP do container no navegador, tal como <a href="http://172.17.0.3">http://172.17.0.3</a> e deve ser possível ver uma página Web, tal como apresentado na [@fig:navegador1].</p>

<p><img src="imagens/navegador1.png" alt="Navegador acessando o Apache do container" />{#fig:navegador1}</p>

<p>::: note
É importante observar que durante o <code class="language-plaintext highlighter-rouge">commit</code> o container que serve de base estava em execução.
:::</p>

<h3 id="criando-imagens-com-o-build">Criando imagens com o <code class="language-plaintext highlighter-rouge">build</code></h3>

<p>Vimos anteriormente que o <code class="language-plaintext highlighter-rouge">commit</code> pode ser utilizado para criar uma imagem, todavia atualmente recomenda-se utilizar o <code class="language-plaintext highlighter-rouge">build</code>, já que esse é considerado uma prática melhor, pois permite analisar as diferenças entre as imagens, já que mantém um arquivo com os passos executados para alterar a imagem. Desta forma é importante entender como funciona o <code class="language-plaintext highlighter-rouge">build</code> e o arquivo Dockerfile.</p>

<h4 id="dockerfile">Dockerfile</h4>

<p>Então a base para se criar uma imagem com o <code class="language-plaintext highlighter-rouge">build</code> é entender o Dockerfile e sua estrutura. Desta forma para entender a estrutura básica deste arquivo vamos replicar o que foi feito na imagem anterior (quando foi utilizado o <code class="language-plaintext highlighter-rouge">commit</code>).</p>

<p>Para isso vamos criar um diretório, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">mkdir </span>buildApache
<span class="gp">$</span><span class="w"> </span><span class="nb">cd </span>buildApache/
<span class="gp">$</span><span class="w"> </span>vi Dockerfile
</code></pre></div></div>

<p>Então anteriormente (comandos), foi criado um diretório chamando <code class="language-plaintext highlighter-rouge">buildApache</code>, entramos dentro deste diretório (<code class="language-plaintext highlighter-rouge">cd</code>) e por fim executamos o editor de texto <code class="language-plaintext highlighter-rouge">vi</code> (fique a vontade para utilizar outro editor de texto) para criar/editar o arquivo chamado <code class="language-plaintext highlighter-rouge">Dockerfile</code>. Para este exemplo o conteúdo deste arquivo será:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">FROM fedora
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
RUN dnf install httpd net-tools -y
</span><span class="gp">RUN echo "Olá com &lt;b&gt;</span><span class="w"> </span>build<span class="s2">" &gt; /var/www/html/index.html''
</span></code></pre></div></div>

<p>As instruções contidas neste arquivo de exemplo foram:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FROM</code>: indica a imagem base, na qual essa nova imagem será gerada;</li>
  <li><code class="language-plaintext highlighter-rouge">MAINTAINER</code>: informa o autor da imagem e seu e-mail;</li>
  <li><code class="language-plaintext highlighter-rouge">RUN</code>: Executa comandos na imagem atual.</li>
</ul>

<p>Então o principal neste arquivo de exemplo, é que a imagem é baseada no <code class="language-plaintext highlighter-rouge">fedora</code>, e são executados três comandos, sendo esses: atualiza o <code class="language-plaintext highlighter-rouge">fedora</code>, instala do <code class="language-plaintext highlighter-rouge">httpd</code> e <code class="language-plaintext highlighter-rouge">net-tools</code> (o <code class="language-plaintext highlighter-rouge">-y</code> é para responder sim a todas as perguntas do <code class="language-plaintext highlighter-rouge">dnf</code>, já que não há interação do usuário com este tipo de procedimento) e por fim, neste exemplo, criamos um <code class="language-plaintext highlighter-rouge">index.html</code> para diferenciar essa imagem da anterior (criada com o <code class="language-plaintext highlighter-rouge">commit</code>).</p>

<p>::: note
Lembrando que principalmente nesta imagem não precisaria instalar o <code class="language-plaintext highlighter-rouge">net-tools</code>, isso foi feito aqui só para manter compatibilidade entre os exemplos.
:::</p>

<p>Feito o Dockerfile, agora é possível executar o <code class="language-plaintext highlighter-rouge">docker build</code> e criar efetivamente a imagem, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">-t</span><span class="o">=</span><span class="s2">"servidor/build_fedora_apache"</span> <span class="nb">.</span>
<span class="go">DEPRECATED: The legacy builder is deprecated and will be removed in a future release.
            Install the buildx component to build images with BuildKit:
            https://docs.docker.com/go/buildx/

Sending build context to Docker daemon  2.048kB
Step 1/5 : FROM fedora
</span><span class="gp"> ---&gt;</span><span class="w"> </span>9146ee7fcff0
<span class="go">Step 2/5 : MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
</span><span class="gp"> ---&gt;</span><span class="w"> </span>Running <span class="k">in </span>8acec3282bb9
<span class="gp"> ---&gt;</span><span class="w"> </span>Removed intermediate container 8acec3282bb9
<span class="gp"> ---&gt;</span><span class="w"> </span>6e988b94e803
<span class="go">Step 3/5 : RUN dnf update -y
</span><span class="c">...
</span><span class="go">Complete!
</span><span class="gp"> ---&gt;</span><span class="w"> </span>Removed intermediate container 168523b0e76d
<span class="gp"> ---&gt;</span><span class="w"> </span>60e824a461ec
<span class="gp">Step 5/5 : RUN echo "Olá com &lt;b&gt;</span><span class="w"> </span>build<span class="s2">" &gt; /var/www/html/index.html''
</span><span class="gp"> ---&gt;</span><span class="w"> </span><span class="s2">Running in 23444ad42f62
</span><span class="gp"> ---&gt;</span><span class="w"> </span><span class="s2">Removed intermediate container 23444ad42f62
</span><span class="gp"> ---&gt;</span><span class="w"> </span><span class="s2">a399fcc1c787
</span><span class="go">Successfully built a399fcc1c787
Successfully tagged servidor/build_fedora_apache:latest
</span></code></pre></div></div>
<p>É importante acompanhar e verificar as saída do processo <code class="language-plaintext highlighter-rouge">build</code>, para identificar possíveis erros, principalmente nos comandos executados pelo <code class="language-plaintext highlighter-rouge">RUN</code>. Caso erros aconteçam serão retornados códigos diferentes de zero, na saída.</p>

<p>::: tip
Se houverem erros, uma boa prática é executar o container com o <code class="language-plaintext highlighter-rouge">bash</code> e ir digitando os comandos lá dentro e copiando e colando para o Dockerfile.
:::</p>

<p>Na saída anterior, que não apresentou erros, veja que o comando <code class="language-plaintext highlighter-rouge">docker build</code> é seguida de <code class="language-plaintext highlighter-rouge">-t</code>, que indica o rótulo que vai identificar a nova imagem. Após isso é possível acompanhar a execução das instruções do Dockerfile, ou seja, obtenção da imagem do <code class="language-plaintext highlighter-rouge">fedora</code>, e execução dos comandos presentes no <code class="language-plaintext highlighter-rouge">RUN</code>.</p>

<p>É válido mencionar com ainda é possível criar rótulos para as imagens na opção <code class="language-plaintext highlighter-rouge">-t</code>, tal como: <code class="language-plaintext highlighter-rouge">docker build -t="servidor/build_fedora_apache:v1"</code>, isso ajuda a organizar melhor as imagens, mas caso não se utilize esse rótulo o Docker colocará por padrão o rótulo <code class="language-plaintext highlighter-rouge">latest</code>.</p>

<p>Também é possível executar o <code class="language-plaintext highlighter-rouge">docker build</code> em um diretório diferente da onde está o Dockerfile, inclusive utilizando um arquivo que não se chama Dockerfile (mas o conteúdo tem que ser no estilo Dockerfile), para isso basta utilizar a opção <code class="language-plaintext highlighter-rouge">-f</code> e passar o caminho para o arquivo em questão.</p>

<p>Após o <code class="language-plaintext highlighter-rouge">build</code> é possível ver a imagem na listagem de imagens Docker, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker images
<span class="go">REPOSITORY                     TAG           IMAGE ID       CREATED              SIZE
servidor/build_fedora_apache   latest        a399fcc1c787   About a minute ago   518MB
servidor/fedora_apache         latest        8bcfdd9d6660   About an hour ago    512MB
fedora                         latest        9146ee7fcff0   3 days ago           222MB
ubuntu                         latest        35a88802559d   2 months ago         78MB
luizarthur/cyberinfra          routerDeb11   28b009432f01   4 months ago         391MB
</span></code></pre></div></div>

<p>Então, com a imagem pronta, é possível executar um container utilizando essa nova imagem:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> servidorFedApache2 <span class="nt">-d</span> servidor/build_fedora_apache /usr/sbin/httpd <span class="nt">-DFOREGROUND</span>
<span class="go">81b9354214ca0bae865211ba93b34817c7aef8cab3cc3510954a11da14a9db03
</span></code></pre></div></div>

<p>Se tudo correu bem, tal imagem estará em execução:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE                          COMMAND                  CREATED             STATUS             PORTS     NAMES
81b9354214ca   servidor/build_fedora_apache   "/usr/sbin/httpd -DF…"   6 seconds ago       Up 5 seconds                 servidorFedApache2
4d76b05803d3   servidor/fedora_apache         "/usr/sbin/httpd -DF…"   About an hour ago   Up About an hour             servidorFedApache
f768497f72b7   fedora                         "/bin/bash"              2 hours ago         Up 2 hours                   meuFedoraApache
</span></code></pre></div></div>

<p>E podemos fazer o teste, tal como feito no exemplo do <code class="language-plaintext highlighter-rouge">commit</code>, e portanto podemos acessar o servidor HTTP em execução no container criado. A saída a seguir mostra como obter o IP do container e a [@fig:navegador2] mostra o acesso à esse container utilizando um navegador no <em>host</em> hospedeiro.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect servidorFedApache2 | <span class="nb">grep</span> <span class="nt">-i</span> <span class="se">\"</span>IPAddress
<span class="go">            "IPAddress": "172.17.0.4",
                    "IPAddress": "172.17.0.4",
</span></code></pre></div></div>

<p><img src="imagens/navegador2.png" alt="Navegador acessando o Apache do container criado a partir de um Dockerfile" />{#fig:navegador2}</p>

<h4 id="cache-do-build">Cache do <code class="language-plaintext highlighter-rouge">build</code></h4>

<p>Os passos executados durante a criação da imagem utilizando <code class="language-plaintext highlighter-rouge">build</code> e Dockerfile ficam armazenados em cache, isso pode economizar tempo, pois se um passo já foi feito e um novo passo foi adicionado, o Docker só vai gastar tempo executando o novo passo.</p>

<p>O uso do cache na criação da imagem utilizando o <code class="language-plaintext highlighter-rouge">build</code> e o Dockerfile, pode ser vista na saída a seguir, que executa a imagem, que já havia sido criada na seção anterior - ou seja, é uma imagem que já teve todos os seus passos criados:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">-t</span><span class="o">=</span><span class="s2">"servidor/build_fedora_apache"</span> <span class="nb">.</span>
<span class="c">...
</span><span class="go">Step 1/5 : FROM fedora
</span><span class="gp"> ---&gt;</span><span class="w"> </span>9146ee7fcff0
<span class="go">Step 2/5 : MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
</span><span class="gp"> ---&gt;</span><span class="w"> </span>Using cache
<span class="gp"> ---&gt;</span><span class="w"> </span>ef7690e14222
<span class="go">Step 3/5 : RUN dnf update -y
</span><span class="gp"> ---&gt;</span><span class="w"> </span>Using cache
<span class="gp"> ---&gt;</span><span class="w"> </span>2402ee15a5f0
<span class="go">Step 4/5 : RUN dnf install httpd net-tools -y
</span><span class="gp"> ---&gt;</span><span class="w"> </span>Using cache
<span class="gp"> ---&gt;</span><span class="w"> </span>6a8f5591a1c9
<span class="gp">Step 5/5 : RUN echo "Olá com &lt;b&gt;</span><span class="w"> </span>build<span class="s2">" &gt; /var/www/html/index.html''
</span><span class="gp"> ---&gt;</span><span class="w"> </span><span class="s2">Using cache
</span><span class="gp"> ---&gt;</span><span class="w"> </span><span class="s2">9c80a2830029
</span><span class="go">Successfully built 9c80a2830029
Successfully tagged servidor/build_fedora_apache:latest
</span></code></pre></div></div>
<p>Na saída anterior onde aparece <code class="language-plaintext highlighter-rouge">---&gt; Using cache</code>, significa que quando foi executado o comando <code class="language-plaintext highlighter-rouge">docker build</code>, que aquele dado passo (<code class="language-plaintext highlighter-rouge">Step</code>), não foi executado, mas sim foi utilizado o que estava no cache, ou seja, foi utilizado o que já se tinha anteriormente.</p>

<p>A ideia do cache será útil na maioria dos casos, entretanto algumas vezes o cache pode atrapalhar. Por exemplo, suponha que em uma primeira vez pedimos para o sistema atualizar a base de pacotes (ex. <code class="language-plaintext highlighter-rouge">apt update</code>), mas isso já faz um tempo e tal base está desatualizada, e seria refazer isso para instalar um novo pacote. Se esse passo estiver no Dockerfile, que já passou por um cache, tal atualização não será realizada e portanto pode não ser possível instalar o pacote novo. Para esses casos existe a opção <code class="language-plaintext highlighter-rouge">--no-cache</code>, que obriga o Docker a ignorar o cache e refazer todos passos presentes no Dockerfile. Um exemplo do uso desse comando seria:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">--no-cache</span> <span class="nt">-t</span><span class="o">=</span><span class="s2">"servidor/build_fedora_apache"</span> <span class="nb">.</span>
</code></pre></div></div>

<p>Então, a opção <code class="language-plaintext highlighter-rouge">--no-cache</code> do comando anterior, fará com que Docker ignore qualquer cache existe (daquela imagem), obrigando o Docker a recriar a imagem executando novamente todos os passos presentes no Dockerfile.</p>

<p>Também é possível ter um comportamento semelhante ao <code class="language-plaintext highlighter-rouge">--no-cache</code> utilizando-se a instrução <code class="language-plaintext highlighter-rouge">ENV</code> com a variável <code class="language-plaintext highlighter-rouge">REFRESHED_AT</code>, seguida da uma data. Assim, caso a data presente neste variável mudar (tiver a data do tempo atual), o Docker vai ignorar o cache e executar todos os passos novamente.</p>

<p>A saída a seguir mostra como utilizar o <code class="language-plaintext highlighter-rouge">ENV REFRESHED_AT</code> no Dockerfile:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">FROM fedora
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
ENV REFRESHED_AT 2024-08-30
RUN dnf update -y
RUN dnf install httpd net-tools -y
</span><span class="gp">RUN echo "Olá com &lt;b&gt;</span><span class="w"> </span>build<span class="s2">" &gt; /var/www/html/index.html''
</span></code></pre></div></div>

<p>::: tip
A princípio se alterar o valor que está na frente do <code class="language-plaintext highlighter-rouge">ENV REFRESHED_AT</code>, o Docker já vai executar os passos novamente. Tal como: <code class="language-plaintext highlighter-rouge">ENV REFRESHED_AT 2024-08-30 2</code>, fazendo menção a uma versão 2 para o mesmo dia.
:::</p>

<h3 id="instruções-do-dockerfile">Instruções do Dockerfile</h3>

<p>Na seção anterior, foram apresentadas algumas instruções que podem ser utilizadas no Dockerfile, mas a seguir são apresentadas essas e outras instruções que normalmente são utilizadas para a criação de imagens:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">FROM</code></strong>: Especifica a imagem base da qual a imagem será construída;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">LABEL</code></strong>: Permite adicionar rótulos à imagem;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">RUN</code></strong>: Executa comandos durante a construção da imagem;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">CMD</code></strong>: Específica o comando padrão que será executado quando o container for executado. É similar ao <code class="language-plaintext highlighter-rouge">RUN</code>, mas o <code class="language-plaintext highlighter-rouge">RUN</code> executa um comando durante a criação da imagem, já o <code class="language-plaintext highlighter-rouge">CMD</code> é para a execução do container.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ENTRYPOINT</code></strong>: Define o comando que sempre será executado quando o container é iniciado;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">COPY</code></strong>: Copia arquivos ou diretórios do <em>host</em> para a imagem;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ADD</code></strong>: Similar ao <code class="language-plaintext highlighter-rouge">COPY</code>, mas permite ainda extrair arquivos compactados e a utilização de URLs. Sugere-se utilizar o <code class="language-plaintext highlighter-rouge">COPY</code> quando a tarefa for apenas copiar arquivos do <em>host</em> para o container, e o <code class="language-plaintext highlighter-rouge">ADD</code>, quando for necessário fazer copias de URL ou de arquivos compactados.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">WORKDIR</code></strong>: Diretório de trabalho à ser utilizado nos pelas instruções <code class="language-plaintext highlighter-rouge">RUN</code>, <code class="language-plaintext highlighter-rouge">CMD</code>, <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>, <code class="language-plaintext highlighter-rouge">COPY</code> e <code class="language-plaintext highlighter-rouge">ADD</code>;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ENV</code></strong>: Define variáveis de ambiente para o container;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">EXPOSE</code></strong>: Determina quais portas de rede serão expostas do container para o <em>host</em>;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ARG</code></strong>: Define variáveis que podem ser passadas durante o <code class="language-plaintext highlighter-rouge">build</code>. Note que o ARG cria variáveis de ambiente que estarão disponíveis apenas durante a construção da imagem, já o <code class="language-plaintext highlighter-rouge">ENV</code> é para variáveis de ambiente durante a execução do container;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">VOLUME</code></strong>: Cria um ponto de montagem, permitindo que dados sejam persistidos ou compartilhados entre containers;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">USER</code></strong>: Define sob qual usuário o container será executado. Assim, ela define um usuário existente no container para executar as instruções Docker.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">HELTHCHECK</code></strong>: Instrui o Docker a verificar o container em intervalos regulares. Tal instrução vai executar um comando ou <em>script</em> determinado pelo administrador para verificar se tudo está certo com o container criado, tal comando pode ser por exemplo, um <code class="language-plaintext highlighter-rouge">ping</code> ou um acesso ao uma URL com o comando <code class="language-plaintext highlighter-rouge">wget</code> ou <code class="language-plaintext highlighter-rouge">curl</code>;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">STOPSIGNAL</code></strong>: Define o sinal que será enviado ao se parar o container;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">SHELL</code></strong>: Determina qual <em>shell</em> deve ser utilizado para os comandos <code class="language-plaintext highlighter-rouge">RUN</code>, <code class="language-plaintext highlighter-rouge">CMD</code>, <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>, etc.</li>
</ul>

<p>As instruções apresentadas anteriormente são as mais comuns, a seguir são apresentados exemplos de uso dessas instruções para a criação de imagens com o Dockerfile.</p>

<h1 id="tarefas-comuns-em-imagens-e-containers-dockers">Tarefas comuns em imagens e containers Dockers</h1>

<p>A seguir são apresentados alguns exemplos de imagens e criação de containers. A ideia é apresentar mais em detalhes algumas opções normalmente utilizadas do mundo Docker, bem como em que tipo de situações elas podem serem aplicadas.</p>

<h2 id="determinando-o-que-será-executado-por-padrão-na-imagemcontainer">Determinando o que será executado por padrão na imagem/container</h2>

<p>No Docker, existem duas maneiras de definir o comando principal que será executado na inicialização do container. Esse comando geralmente representa a função central do container, ou seja, o propósito para o qual ele foi criado. Caso esse comando seja interrompido, é provável que o container também seja finalizado, já que sua função principal não estará mais em execução.</p>

<p>Na criação de imagens Docker, há duas formas de se determinar qual e como o comando principal será executado, sendo essas identificadas pelas instruções: <code class="language-plaintext highlighter-rouge">CMD</code> e <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>. A seguir veremos a diferença entre essas instruções.</p>

<h3 id="cmd"><code class="language-plaintext highlighter-rouge">CMD</code></h3>

<p>Utilizando o <code class="language-plaintext highlighter-rouge">CMD</code> no Dockerfile, é possível determinar o comando que será executado quando o container for criando, com isso não é necessário indicar o comando que deve ser executado pelo container quando se executa o <code class="language-plaintext highlighter-rouge">docker run</code>. Tal prática facilita a vida de quem for executar o container, pois a pessoal não precisa digitar tal comando na frente do <code class="language-plaintext highlighter-rouge">docker run</code>, o que naturalmente também evita erros.</p>

<p>::: important
Se forem passadas mais de uma linha <code class="language-plaintext highlighter-rouge">CMD</code> no Dockerfile, será executada apenas a última linha.
:::</p>

<p>A seguir é apresentado um exemplo de um Dockerfile, que cria uma imagem baseada no Fedora Linux, para executar um servidor Apache HTTTP. Então a principal função desse container é executar o servidor HTTP, desta forma o comando <code class="language-plaintext highlighter-rouge">CMD</code>, do Dockerfile, é utilizado justamente para indicar que deve-se iniciar o processo <code class="language-plaintext highlighter-rouge">/usr/sbin/httpd</code>, que é responsável pelo servidor HTTP.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span>Version 0.1
<span class="go">FROM fedora
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
RUN dnf install httpd net-tools -y
</span><span class="gp">RUN echo "Olá com &lt;b&gt;</span><span class="w"> </span>build<span class="s2">" &gt; /var/www/html/index.html''
</span><span class="go">CMD ["/usr/sbin/httpd", "-DFOREGROUND"]
</span></code></pre></div></div>

<p>Após criar/editar o Dockerfile, é necessário gerar a imagem. Feito isso é possível criar containers a partir dessa imagem, tal como:</p>

<ol>
  <li>Gerar a imagem:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">-t</span><span class="o">=</span><span class="s2">"servidor/build_fedora_apache"</span> <span class="nb">.</span>
</code></pre></div></div>

<ol>
  <li>Criar container a partir da imagem gerada:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> servidorFedApache3 <span class="nt">-d</span> servidor/build_fedora_apache
</code></pre></div></div>

<ol>
  <li>Verificar se o container está em execução (opcional):
    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE                          COMMAND                  CREATED         STATUS         PORTS     NAMES
76b72b9eeb8f   servidor/build_fedora_apache   "/usr/sbin/httpd -DF…"   7 seconds ago   Up 7 seconds             servidorFedApache3
</span></code></pre></div>    </div>
  </li>
</ol>

<p>É importante saber que o comando a ser executado pela instrução <code class="language-plaintext highlighter-rouge">CMD</code> pode ser sobreposto no momento da criação do container, ou seja via linha de comando, por exemplo:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--name</span> servidorFedApache3 <span class="nt">-d</span> servidor/build_fedora_apache /bin/bash
</code></pre></div></div>

<p>No comando anterior, o container gerado pela a imagem criada anteriormente executa o comando inicial <code class="language-plaintext highlighter-rouge">/bin/bash</code> (note que também foi incluído o <code class="language-plaintext highlighter-rouge">-it</code>, para esse exemplo, só para poder acessar o terminal do container). Ou seja, neste caso não será executado o <code class="language-plaintext highlighter-rouge">/usr/sbin/httpd</code>, mas sim o <code class="language-plaintext highlighter-rouge">/bin/bash</code>, já que isso foi determinado via linha de comando.</p>

<p>::: note
Se você tentar acessar o servidor HTTP no container anterior, você verá que esse não está em execução, já que foi executado o <code class="language-plaintext highlighter-rouge">bash</code> ao invés do <code class="language-plaintext highlighter-rouge">httpd</code>.
:::</p>

<h3 id="entrypoint"><code class="language-plaintext highlighter-rouge">ENTRYPOINT</code></h3>

<p>O comportamento de mudar o comando principal na linha de execução do Docker, tal como faz o <code class="language-plaintext highlighter-rouge">CMD</code>, pode ser desejado em alguns casos. Todavia, quando isso não for desejável é possível utilizar o <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>. Ou seja, o <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> não permite que o comando principal seja alterado facilmente no <code class="language-plaintext highlighter-rouge">docker run</code>. Para isto basta trocar o <code class="language-plaintext highlighter-rouge">CMD</code> por <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span>Version 0.1
<span class="go">FROM fedora
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
RUN dnf install httpd net-tools -y
</span><span class="gp">RUN echo "Olá com &lt;b&gt;</span><span class="w"> </span>build<span class="s2">" &gt; /var/www/html/index.html''
</span><span class="go">ENTRYPOINT ["/usr/sbin/httpd", "-DFOREGROUND"]
</span></code></pre></div></div>
<p>Agora vamos gerar a imagem:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">-t</span><span class="o">=</span><span class="s2">"servidor/build_fedora_apache"</span> <span class="nb">.</span>
<span class="c">...
</span><span class="go">Step 6/6 : ENTRYPOINT ["/usr/sbin/httpd", "-DFOREGROUND"]
</span><span class="gp"> ---&gt;</span><span class="w"> </span>Using cache
<span class="gp"> ---&gt;</span><span class="w"> </span>06181e2db3ad
<span class="c">...
</span></code></pre></div></div>

<p>Com a imagem pronta vamos tentar executar o container passando um comando via <code class="language-plaintext highlighter-rouge">docker run</code>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--name</span> servidorFedApache3.1 <span class="nt">-d</span> servidor/httpd /bin/bash
<span class="go">7840c93ed7ec50a79764f7ecb0c8ccdf07cf638d340ac4ede1f8368b4382ffbc
</span></code></pre></div></div>

<p>Agora, com o <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>, ao tentar verificar os containers em execução, não será possível encontrar o container <code class="language-plaintext highlighter-rouge">servidorFedApache3.1</code>, pois a instrução <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>, não permitiu executá-lo com o <code class="language-plaintext highlighter-rouge">bash</code>. Todavia se não for passada nenhum comando no <code class="language-plaintext highlighter-rouge">docker run</code> ele será executado com o processo <code class="language-plaintext highlighter-rouge">httpd</code>.</p>

<h3 id="juntando-entrypoint-e-cmd">Juntando <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> e <code class="language-plaintext highlighter-rouge">CMD</code></h3>

<p>É possível utilizar em conjunto o <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> com o <code class="language-plaintext highlighter-rouge">CMD</code>, neste caso primeiro deve ser determinado via <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> o comando que obrigatoriamente deve ser utilizado ao se criar o container, e o que for passado via <code class="language-plaintext highlighter-rouge">CMD</code>, serão as opções do comando no <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>. Desta forma,
se não for passada nenhum comando/opção no <code class="language-plaintext highlighter-rouge">docker run</code> será executado o comando do <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> com as opções passadas do <code class="language-plaintext highlighter-rouge">CMD</code>. Caso for passado algum comando via <code class="language-plaintext highlighter-rouge">CMD</code>, esse ou esses, serão na verdade opções para o comando do ``ENTRYPOINT`. Ou seja, o comando não pode ser alterado, mas as opções/parâmetros sim. Vamos ver o exemplo a seguir:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span>Version 0.1
<span class="go">FROM fedora
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
RUN dnf install httpd net-tools -y
</span><span class="gp">RUN echo "Olá com &lt;b&gt;</span><span class="w"> </span>build<span class="s2">" &gt; /var/www/html/index.html''
</span><span class="go">ENTRYPOINT ["/usr/sbin/httpd"]
CMD ["-DFOREGROUND"]
</span></code></pre></div></div>

<p>Exemplos de criação de containers utilizando essa imagem:</p>

<ol>
  <li>Sem nenhum comando/parâmetros:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--name</span> servidorFedApache3.3 <span class="nt">-d</span> servidor/httpd
</code></pre></div></div>

<p>Vai executar <code class="language-plaintext highlighter-rouge">/usr/sbin/httpd -DFOREGROUND</code>.</p>

<ol>
  <li>Passando parâmetros:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--name</span> servidorFedApache3.3 <span class="nt">-d</span> servidor/httpd <span class="nt">-v</span>
</code></pre></div></div>

<p>Vai executar Vai executar <code class="language-plaintext highlighter-rouge">/usr/sbin/httpd -v</code>. Neste exemplo o servidor HTTP, vai mostrar a versão do servidor (não vai executar tal servidor), isso poderá ser visto com o ``log`, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker logs  servidorFedApache3.3
<span class="go">Server version: Apache/2.4.62 (Fedora Linux)
Server built:   Aug  1 2024 00:00:00
</span></code></pre></div></div>

<ol>
  <li>Tentando executar o comando <code class="language-plaintext highlighter-rouge">echo</code>:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--name</span> servidorFedApache3.3 <span class="nt">-d</span> servidor/httpd <span class="nb">echo</span> <span class="nt">-v</span>
</code></pre></div></div>

<p>Devido ao <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> não será executado o <code class="language-plaintext highlighter-rouge">echo</code>, mas sim o <code class="language-plaintext highlighter-rouge">echo</code> será passado como um parâmetro para o <code class="language-plaintext highlighter-rouge">httpd</code>, como tal parâmetro não existe no <code class="language-plaintext highlighter-rouge">httpd</code> será retornado um erro, que pode ser visto no <code class="language-plaintext highlighter-rouge">log</code>.</p>

<p>Por fim, é possível substituir o <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>, no <code class="language-plaintext highlighter-rouge">docker run</code>, mas para isso é necessário utilizar a opção <code class="language-plaintext highlighter-rouge">--entrypoint</code>, ou seja, é necessário explicitar a intenção de trocar o comando principal. Exemplo:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--name</span> servidorFedApache3.3 <span class="nt">--entrypoint</span> /bin/bash <span class="nt">-d</span> servidor/httpd
</code></pre></div></div>

<h2 id="sec:copy">Copiando arquivos do <em>host</em> para a a imagem</h2>

<p>Outra tarefa corriqueira no mundo dos containers é copiar arquivos para dentro da imagem, isso permite personalizar as imagens e pode facilitar a tarefa de configuração ou customização. No Docker há duas instruções que permitem copiar arquivos para a imagem, sendo essas: <code class="language-plaintext highlighter-rouge">COPY</code> e <code class="language-plaintext highlighter-rouge">ADD</code>.</p>

<p>Assim, para entender melhor como funciona esse processo de cópia para a imagem e o motivo de seu uso, vamos criar outro Dockerfile/imagem. Neste Dockerfile, utilizaremos:</p>

<ul>
  <li>A imagem <code class="language-plaintext highlighter-rouge">servidor/build_fedora_apache</code> feita no exemplo anterior;</li>
  <li>Em seguida será instalado os pacotes <code class="language-plaintext highlighter-rouge">php</code> e o <code class="language-plaintext highlighter-rouge">procps</code> (o <code class="language-plaintext highlighter-rouge">procps</code> não é necessário para o servidor, mas pode ser útil para testes, caso algo dê errado, pois esse fornece o comando <code class="language-plaintext highlighter-rouge">ps</code>);</li>
  <li>Depois de instalar o PHP, vamos criar um <em>script</em> para iniciar o PHP e o Apache;</li>
  <li>Por fim, vamos criar uma página PHP para testar o servidor.</li>
</ul>

<p>Para efetivar na prática os passos citados anteriormente, da seguinte forma:</p>

<ol>
  <li>Iniciamos criando o arquivo Dockerfile e para esse exemplo <strong>não vamos utilizar o nome padrão</strong> (<code class="language-plaintext highlighter-rouge">Dockerfile</code>):</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">vi Dockerfile-php
</span></code></pre></div></div>

<ol>
  <li>Editamos o conteúdo para atender o que foi determinado anteriormente:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">FROM servidor/build_fedora_apache
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
RUN dnf install -y php procps
RUN mkdir /run/php-fpm/
RUN mkdir -p /var/www/html/php
</span><span class="gp">RUN echo -e "#</span><span class="o">!</span>/bin/bash <span class="se">\n</span>/sbin/php-fpm &amp;<span class="se">\n</span>/sbin/httpd <span class="nt">-DFOREGROUND</span> <span class="se">\n</span>/bin/read<span class="s2">"  &gt; /sbin/startServer.sh
</span><span class="go">RUN chmod a+x /sbin/startServer.sh
</span><span class="gp">RUN echo "&lt;?php phpinfo();</span><span class="w"> </span>?&gt;<span class="s2">" &gt; /var/www/html/php/teste.php
</span><span class="go">CMD ["/sbin/startServer.sh"]
</span></code></pre></div></div>
<p>Neste caso, tal arquivo tem basicamente seguintes instruções (resumidas):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FROM ...</code>: para indicar que vamos utilizar a imagem com o servidor HTTP criando anteriormente;</li>
  <li><code class="language-plaintext highlighter-rouge">RUN dnf ...</code>: para realizar uma atualização do sistema e então atualizar e instalar os pacotes necessários (PHP e procps);</li>
  <li><code class="language-plaintext highlighter-rouge">RUN mkdir ...</code>: cria diretórios necessários para o PHP;</li>
  <li><code class="language-plaintext highlighter-rouge">RUN echo ... startServer.sh</code>: que está criando um <em>script</em> para iniciar o PHP e depois o Apache;</li>
  <li><code class="language-plaintext highlighter-rouge">RUN chmod ...</code>: dá permissão de execução ao <em>script</em>;</li>
  <li><code class="language-plaintext highlighter-rouge">RUN echo ... teste.php</code>: cria um arquivo com uma página PHP básica, só para testar se o PHP está funcionando;</li>
  <li><code class="language-plaintext highlighter-rouge">CMD ...</code>: comando que vai ser executado quando o container for criado.</li>
</ul>

<ol>
  <li>Criamos a imagem, apontando para o arquivo Dockerfile:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">-f</span> Dockerfile-php <span class="nt">-t</span><span class="o">=</span><span class="s2">"servidor/build_fedora_apache_php"</span> <span class="nb">.</span>
</code></pre></div></div>

<p>::: important
Tem que utilizar o <code class="language-plaintext highlighter-rouge">-f</code>, já que não foi utilizado o nome padrão de arquivo Dockerfile.
:::</p>

<ol>
  <li>Agora é possível criar um container utilizando a imagem nova:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> servidorFedApache_PHP <span class="nt">-d</span> servidor/build_fedora_apache_php
</code></pre></div></div>

<ol>
  <li>Depois desses passos, o container criado deve aparecer na listagem do comando <code class="language-plaintext highlighter-rouge">docker ps</code>. Bem como, será possível acessar a página PHP no servidor sendo executado no container, tal como mostra a [@fig:navegador3].</li>
</ol>

<p><img src="imagens/navegador3.png" alt="Navegador acessando PHP do container criado a partir do Dockerfile-php" />{#fig:navegador3}</p>

<p>::: note
Para acessar a página PHP, você deve descobrir o IP do container (tal como fizemos anteriormente) e acessar o <code class="language-plaintext highlighter-rouge">http://ip_container/php/teste.php</code> - que é o caminho que configuramos, onde está a página PHP.
:::</p>

<p>Uma <strong>importante observação</strong> deve ser feitas aqui: Para a criação desta imagem, <strong>utilizamos o <code class="language-plaintext highlighter-rouge">RUN</code> para criar o <em>script</em></strong>, isso foi feito com a seguinte instrução:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">RUN echo -e "#</span><span class="o">!</span>/bin/bash <span class="se">\n</span>/sbin/php-fpm &amp;<span class="se">\n</span>/sbin/httpd <span class="nt">-DFOREGROUND</span> <span class="se">\n</span>/bin/read<span class="s2">"  &gt; /sbin/startServer.sh
</span></code></pre></div></div>

<p>Então é possível utilizar o <code class="language-plaintext highlighter-rouge">RUN</code> para criar o <em>script</em>, mas <strong>isso pode deixar o entendimento confuso</strong> (muito coisa em uma linha só), então há grandes chances de erro. Outra questão ainda relacionada à isso é: “e se o administrador precisar criar um <em>script</em> ainda maior e mais complexo?”. Bem uma possível solução é apresentada a seguir com o <code class="language-plaintext highlighter-rouge">COPY</code> e o <code class="language-plaintext highlighter-rouge">ADD</code>.</p>

<h3 id="copiando-arquivos-para-imagem-com-o-copy">Copiando arquivos para imagem com o <code class="language-plaintext highlighter-rouge">COPY</code></h3>

<p>Desta forma, para melhorar o Dockerfile anterior, é possível utilizar a instrução <code class="language-plaintext highlighter-rouge">COPY</code>, para copiar um <em>script</em> do <em>host</em> para a imagem que está sendo criada. Assim, é possível utilizar um editor de textos para criar mais facilmente o <em>script</em> e depois o <code class="language-plaintext highlighter-rouge">COPY</code> vai copia-lo para a imagem.</p>

<p>Então vamos alterar o Dockerfile anterior, para que este utilize o <code class="language-plaintext highlighter-rouge">COPY</code>, tal como:</p>

<ol>
  <li>Editamos o arquivo Dockerfile e adicionamos a instrução <code class="language-plaintext highlighter-rouge">COPY</code>, tal como a seguir:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>vi Dockerfile-php
<span class="go">
FROM servidor/build_fedora_apache
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
RUN dnf install -y php procps
RUN mkdir /run/php-fpm/
RUN mkdir -p /var/www/html/php
COPY startServer.sh /sbin/startServer.sh
RUN chmod a+x /sbin/startServer.sh
</span><span class="gp">RUN echo "&lt;?php phpinfo();</span><span class="w"> </span>?&gt;<span class="s2">" &gt; /var/www/html/php/teste.php
</span><span class="go">CMD ["/sbin/startServer.sh"]
</span></code></pre></div></div>

<ol>
  <li>Após isso, criamos o arquivo <code class="language-plaintext highlighter-rouge">startServer.sh</code> no <em>host</em> hospedeiro, tal arquivo será copiado para a imagem:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>vi startServer.sh
<span class="go">
</span><span class="gp">#</span><span class="o">!</span>/bin/bash
<span class="go">/sbin/php-fpm &amp;
/sbin/httpd -DFOREGROUND
/bin/read
sleep infinity
</span></code></pre></div></div>

<p>Alguns pontos importantes devem ser destacados aqui:</p>

<ul>
  <li>
    <p>No arquivo Dockerfile foi utilizado o <strong>caminho relativo</strong> do arquivo <code class="language-plaintext highlighter-rouge">startServer.sh</code>. Desta forma, esperá-se que tal arquivo esteja no mesmo diretório do arquivo Dockerfile. Todavia, pode ser recomendável utilizar o caminho absoluto, principalmente se o arquivo não estiver no mesmo local que o Dockerfile.</p>
  </li>
  <li>
    <p>É muito importante que no inicio do Bash <em>script</em> tenha o <strong><em>shebang</em></strong> (<code class="language-plaintext highlighter-rouge">#!/bin/bash</code>),  para informar quem vai executar os comandos, caso contrário o <em>script</em> não será executado no inicio do container e tudo vai falhar;</p>
  </li>
  <li>
    <p>No final do <em>script</em> criando aqui, foram inseridas duas formas de <strong>impedir que o <em>script</em> execute e depois termine</strong>, sendo essas formas: <code class="language-plaintext highlighter-rouge">/bin/read</code> e o <code class="language-plaintext highlighter-rouge">sleep infinity</code>. Contudo isso seria desnecessário, já que teoricamente o comando <code class="language-plaintext highlighter-rouge">/sbin/httpd -DFOREGROUND</code>, fica executando indefinidamente. Entretanto é preciso ter em mente que é necessário que o <em>script</em> deve ficar em execução, pois caso contrário o container vai parar - dependendo o caso dá a impressão que ele nem foi executado.</p>
  </li>
  <li>
    <p>Em caso de problemas na hora de executar o container lembre-se de utilizar o <strong><code class="language-plaintext highlighter-rouge">log</code></strong> ou entrar no container utilizando o <code class="language-plaintext highlighter-rouge">bash</code>, para verificar o que está causando o problema (qual o motivo do container não ficar em execução?);</p>
  </li>
</ul>

<ol>
  <li>Geramos a imagem:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">-f</span> Dockerfile-php <span class="nt">-t</span><span class="o">=</span><span class="s2">"servidor/build_fedora_apache_php"</span> <span class="nb">.</span>
</code></pre></div></div>

<ol>
  <li>Criamos um container baseada nessa imagem:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> servidorFedApache_PHP2 <span class="nt">-d</span> servidor/build_fedora_apache_php
</code></pre></div></div>

<ol>
  <li>Agora é só verificar se está tudo correto, tal como:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE                              COMMAND                  CREATED          STATUS          PORTS     NAMES
9fde9bf8d3dd   servidor/build_fedora_apache_php   "/sbin/startServer.sh"   10 minutes ago   Up 10 minutes             servidorFedApache_PHP2
aff8a1b1d139   05fe3484d188                       "/sbin/startServer.sh"   44 minutes ago   Up 44 minutes             servidorFedApache_PHP
</span></code></pre></div></div>

<p>Assim, utilizamos o <code class="language-plaintext highlighter-rouge">COPY</code> para facilitar o processo de criação de arquivos dentro da imagem Docker. A seguir é apresentado como fazer o mesmo, mas utilizando o <code class="language-plaintext highlighter-rouge">ADD</code> em contextos um pouco diferentes.</p>

<h3 id="utilizando-o-add">Utilizando o ADD</h3>

<p>O ADD é similar ao <code class="language-plaintext highlighter-rouge">COPY</code>, todavia ele permite copiar arquivos de URL (ex. Internet) e descompactar arquivos que estão no <em>host</em> hospedeiro para a imagem.</p>

<p>Para ver a diferença, vamos pegar o exemplo anterior e substituir o <code class="language-plaintext highlighter-rouge">COPY</code> por <code class="language-plaintext highlighter-rouge">ADD</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>vi Dockerfile-php
<span class="go">
FROM servidor/build_fedora_apache
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
RUN dnf install -y php procps
RUN mkdir /run/php-fpm/
RUN mkdir -p /var/www/html/php
ADD https://raw.githubusercontent.com/luizsantos/aulasDocker/main/startServer.sh /sbin/startServer.sh
RUN chmod a+x /sbin/startServer.sh
ADD php.tar.gz /var/www/html/php/
CMD ["/sbin/startServer.sh"]
</span></code></pre></div></div>

<p>Neste novo Dockerfile, note que agora temos duas instruções <code class="language-plaintext highlighter-rouge">ADD</code>, sendo a função dessas em ordem:</p>

<ul>
  <li>Copiar o <em>script</em> <code class="language-plaintext highlighter-rouge">startServer.sh</code> do GitHub, pela URL: <a href="https://raw.githubusercontent.com/luizsantos/aulasDocker/main/startServer.sh">https://raw.githubusercontent.com/luizsantos/aulasDocker/main/startServer.sh</a> para o <code class="language-plaintext highlighter-rouge">/sbin/startServer.sh</code> da imagem;</li>
  <li>Extrair o <a href="https://github.com/luizsantos/aulasDocker/raw/main/testePHP.tar.gz">arquivo <code class="language-plaintext highlighter-rouge">php.tar.gz</code></a> do <em>host</em> hospedeiro para o diretório <code class="language-plaintext highlighter-rouge">/var/www/html/php/</code> do container.</li>
</ul>

<p>::: important
Não serão apresentados os procedimentos para gerar a imagem e container utilizando o <code class="language-plaintext highlighter-rouge">ADD</code>, mas basicamente é só repetir o que foi feito anteriormente.
:::</p>

<p>Bem, o funcionamento é similar ao <code class="language-plaintext highlighter-rouge">COPY</code>, mas o <code class="language-plaintext highlighter-rouge">ADD</code> dá mais possibilidades, já que permite copiar de <em>links</em> e extrair arquivos. Todavia, a literatura em geral, não recomenda utilizar o <code class="language-plaintext highlighter-rouge">ADD</code> como se fosse o <code class="language-plaintext highlighter-rouge">COPY</code>, ou seja, <strong>só utilize o <code class="language-plaintext highlighter-rouge">ADD</code> se você estiver copiando de URL ou extraindo arquivos, caso contrário recomenda-se utilizar o <code class="language-plaintext highlighter-rouge">COPY</code></strong>.</p>

<p>::: note
Durante os testes para a confecção deste material, observou-se que o <code class="language-plaintext highlighter-rouge">ADD</code> não descompacta arquivos provindos de URLs, ou seja, para utilizar sua função de descompactar arquivos, tal arquivo deve estar localmente no <em>host</em> hospedeiro. Também, alguns sítios Web e Fóruns relatam problemas em descompactar arquivos <code class="language-plaintext highlighter-rouge">.zip</code>, neste caso sugere-se baixar o arquivo na imagem e depois descompactar utilizando algum programa a ser executado com o <code class="language-plaintext highlighter-rouge">RUN</code>.
:::</p>

<h2 id="compartilhando-dados-entre-hostcontainers">Compartilhando dados entre <em>host</em>/containers</h2>

<p>O compartilhamento de arquivos é uma tarefa geralmente necessária entre computadores e o mesmo ocorre com os containers. Assim, o Docker fornece formas de se compartilhar dados entre:</p>

<ul>
  <li><em>Host</em> hospedeiro e containers;</li>
  <li>Entre os containers.</li>
</ul>

<p>Veremos tais técnicas a seguir.</p>

<h3 id="opção-volume-do-dockerfile">Opção VOLUME do Dockerfile</h3>

<p>A opção <code class="language-plaintext highlighter-rouge">VOLUME</code> permite criar um ponto de montagem compartilhado entre o container e o <code class="language-plaintext highlighter-rouge">host</code>. Isso facilita o compartilhamento de informações entre ambos, bem como permite que os dados do container seja <strong>persistidos</strong> (ou seja, não se apaguem quando o container for removido).</p>

<p>Então, continuando o exemplo do servidor PHP anterior, vamos deixar o conteúdo PHP compartilhado entre container e <em>host</em>. Assim por exemplo, seria mais fácil criar/alterar o conteúdo dos sítios PHP mantidos nos containers. Então vamos alterar o arquivo Dockerbuild em questão, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span>Version 0.1
<span class="go">FROM servidor/build_fedora_apache
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
RUN dnf install -y php procps
RUN mkdir /run/php-fpm/
RUN mkdir -p /var/www/html/php
COPY startServer.sh /sbin/startServer.sh
RUN chmod a+x /sbin/startServer.sh
VOLUME /var/www/html/php/
CMD ["/sbin/startServer.sh"]
</span></code></pre></div></div>

<p>No exemplo anterior, estamos informando através da instrução <code class="language-plaintext highlighter-rouge">VOLUME</code>, que iremos criar dentro do container um ponto de montagem no diretório <code class="language-plaintext highlighter-rouge">/var/www/html/php/</code>, que poderá ser acessado a partir do <code class="language-plaintext highlighter-rouge">host</code> hospedeiro do container.</p>

<p>Feito isso vamos criar um container a partir dessa imagem:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> servidorFedApache_PHP2 <span class="nt">-d</span> servidor/build_fedora_apache_php
<span class="go">24961fed96566b522ae6a3a9f91c5a4b99768b7eea7d246365dbafbf33b4003a
</span></code></pre></div></div>

<p>Agora, para acessar o compartilhamento no container Docker, basta acessar o diretório <code class="language-plaintext highlighter-rouge">/var/www/html/php/</code>. Já para acessar tal compartilhamento no <code class="language-plaintext highlighter-rouge">host</code>, é necessário descobrir em qual diretório o Docker relacionou esse compartilhamento no <code class="language-plaintext highlighter-rouge">host</code>, para isso podemos, por exemplo, utilizar a opção <code class="language-plaintext highlighter-rouge">inspect</code> e procurar por <code class="language-plaintext highlighter-rouge">Mounts</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect servidorFedApache_PHP2
<span class="c">...
</span><span class="go">        "Mounts": [
            {
                "Type": "volume",
                "Name": "51f493146da5b7db6d6f766e476bc1ecd2e6912e29 f51fd3c3534f433318aaf2",
                "Source": "/var/lib/docker/volumes/51f493146da5b7db 6d6f766e476bc1ecd2e6912e29f51fd3c3534f433318aaf2/_data",
                "Destination": "/var/www/html/php",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
</span><span class="c">...
</span></code></pre></div></div>

<p>Dada a saída anterior, é possível verificar que o compartilhamento do <code class="language-plaintext highlighter-rouge">servidorFedApache_PHP2</code> pode ser acessado no <em>host</em> hospedeiro no diretório <code class="language-plaintext highlighter-rouge">/var/lib/docker/volumes/51f493146da5b7db6d6f766e476bc1ecd2e6912e29f51fd3c3534f433318aaf2/_data</code>. Ou seja, é o <code class="language-plaintext highlighter-rouge">Source</code> que determina o ponto de montagem/compartilhamento no <em>host</em>.</p>

<p>Sabendo o diretório compartilhando entre container e <em>host</em>, podemos criar/alterar o seu conteúdo e isso será refletido imediatamente no container e vice-versa. Por exemplo vamos criar uma página PHP no diretório <code class="language-plaintext highlighter-rouge">/var/lib/docker/volumes/51f493146da5b7db6d6f766e476bc1ec d2e6912e29f51fd3c3534f433318aaf2/_data</code> do <em>host</em> e ver o resultado desta no container <code class="language-plaintext highlighter-rouge">servidorFedApache_PHP2</code>. Tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">sudo</span> <span class="nt">-i</span>
<span class="gp">#</span><span class="w"> </span>vi /var/lib/docker/volumes/51f493146da5b7db6d6f766e476bc1ecd2e6912e29f51fd3c3534f433318aaf2/_data/index.php
<span class="go">
</span><span class="gp">&lt;!DOCTYPE html&gt;</span><span class="w">
</span><span class="gp">&lt;html&gt;</span><span class="w">
</span><span class="gp">    &lt;head&gt;</span><span class="w">
</span><span class="gp">        &lt;title&gt;</span>Teste PHP&lt;/title&gt;
<span class="gp">    &lt;/head&gt;</span><span class="w">
</span><span class="gp">    &lt;body&gt;</span><span class="w">
</span><span class="gp">        &lt;?php echo '&lt;p&gt;</span>Olá PHP no container!&lt;/p&gt;<span class="s1">'; ?&gt;
</span><span class="gp">    &lt;/body&gt;</span><span class="w">
</span><span class="gp">&lt;/html&gt;</span><span class="w">
</span></code></pre></div></div>
<p>::: note
Observe que utilizamos o <code class="language-plaintext highlighter-rouge">sudo</code>, pois os usuários comuns não têm acesso aos compartilhamentos no <code class="language-plaintext highlighter-rouge">host</code>. Então criando compartilhamentos/volumes desta forma, pode ser necessário configurar permissões no <em>host</em> ou no container para que determinados usuários consigam manipular e criar arquivos e diretórios desses compartilhamentos.
:::</p>

<p>Agora podemos acessar a nova página PHP no container, tal como apresenta a [@fig:navegador4].</p>

<p><img src="imagens/navegador4.png" alt="Navegador acessando PHP utilizando VOLUME" />{#fig:navegador4}</p>

<h3 id="opção--v-do-run">Opção <code class="language-plaintext highlighter-rouge">-v</code> do <code class="language-plaintext highlighter-rouge">run</code>.</h3>

<p>Desta forma, tudo que for feito no diretório do <em>host</em> aparecerá no diretório do container, o que pode facilitar muito a vida do administrador. Entretanto há outra maneira de trabalhar com volumes, que não utilizando o Dockerfile. É possível compartilhar volumes via linha de comando, na hora de criar o container, e na verdade faz mais sentido criar os volumes desta forma, já que assim é possível informar qual é o diretório específico que vai aparecer o conteúdo do container dentro do <em>host</em>, com isso, por exemplo podemos utilizar um diretório no <em>host</em> que permita a gravação de um dado usuário e evitamos utilizar, por exemplo o comando <code class="language-plaintext highlighter-rouge">sudo</code>, tal como foi feito anteriormente.</p>

<p>Dito isso vamos ver um exemplo de como criar volumes via linha de comando, para isso vamos:</p>

<ol>
  <li>Criar o diretório que será compartilhado do <em>host</em> hospedeiro com o container:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">mkdir</span> /tmp/site
<span class="gp">echo "&lt;?php phpinfo();</span><span class="w"> </span>?&gt;<span class="s2">" &gt; /tmp/site/teste.php
</span></code></pre></div></div>

<p>Junto com a criação do diretório também foi criando um conteúdo PHP, no caso o arquivo <code class="language-plaintext highlighter-rouge">/tmp/site/teste.php</code>.</p>

<ol>
  <li>Agora vamos criar o container, com a opção <code class="language-plaintext highlighter-rouge">-v</code>:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> servidorFedApache_PHP3 <span class="nt">-v</span> /tmp/site:/var/www/html/php <span class="nt">-d</span> servidor/build_fedora_apache_php
<span class="go">7a7578cda0fb18d2d4addd30362296fea04898689dbebb954e063cf125f729c1
</span></code></pre></div></div>

<p>No exemplo anterior, estamos criando o container <code class="language-plaintext highlighter-rouge">servidorFedApache_PHP3</code>, que compartilha o diretório <code class="language-plaintext highlighter-rouge">/tmp/site</code> no <em>host</em>, com o diretório <code class="language-plaintext highlighter-rouge">/var/www/html/php</code> do container. Assim, fica bem claro quais são os diretórios compartilhados entre ambas máquinas, o que não acontecia utilizando-se apenas a opção <code class="language-plaintext highlighter-rouge">VOLUME</code> do Dockerfile.</p>

<p>Outra forma de ver tal compartilhamento seria:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect <span class="nt">-f</span>  servidorFedApache_PHP3
<span class="go">[{bind  /tmp/site /var/www/html/php   true rprivate}]
</span></code></pre></div></div>

<p>O comando anterior mostra primeiro o compartilhamento no <em>host</em> (<code class="language-plaintext highlighter-rouge">/tmp/site</code>) e do container (<code class="language-plaintext highlighter-rouge">/var/www/html/php</code>).</p>

<p>::: note
Na verdade faz mais sentido criar o volume compartilhado via linha de comando e não via Dockerfile.
:::</p>

<h3 id="compartilhando-dados-entre-containers">Compartilhando dados entre containers</h3>

<p>Também é possível utilizar os volumes para compartilhar dados entre os container, bem como o <em>host</em>. O compartilhamento de volume entre os containers é feita através da opção <code class="language-plaintext highlighter-rouge">--volumes-from</code>.</p>

<p>Para uma melhor explicação vamos criar um compartilhamento entre o <em>host</em> hospedeiro e um container, depois vamos compartilhar esse mesmo volume do container com outro container, tal como:</p>

<ol>
  <li>No <em>host</em>, primeiro criamos um diretório, que será compartilhado com um container:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">mkdir</span> /tmp/share
</code></pre></div></div>

<ol>
  <li>Ainda no <em>host</em> criamos um Dockerfile (vamos usar uma mais simples):</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>vi Dockerfile
<span class="go">
</span><span class="gp">#</span><span class="w"> </span>Version 0.1
<span class="go">FROM fedora
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
CMD /bin/bash
</span></code></pre></div></div>

<ol>
  <li>Geramos a imagem nova:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">-t</span><span class="o">=</span><span class="s2">"fedora/data"</span>
</code></pre></div></div>

<ol>
  <li>Agora vamos criar um container e relacioná-lo com o diretório <code class="language-plaintext highlighter-rouge">/tmp/share</code> do *host:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">-ti</span> <span class="nt">--name</span> container1 <span class="nt">-v</span> /tmp/share:/comp <span class="nt">-d</span> fedora/data
</code></pre></div></div>

<ol>
  <li>Com o primeiro container criado, vamos criar outro container, que será relacionado com o compartilhamento do primeiro container, tal como:</li>
</ol>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">-ti</span> <span class="nt">--name</span> container2 <span class="nt">--volumes-from</span> container1 <span class="nt">-d</span> fedora/data
</code></pre></div></div>

<p>Feito isso temos um diretório compartilhado entre o <em>host</em>, <code class="language-plaintext highlighter-rouge">container1</code> e <code class="language-plaintext highlighter-rouge">container2</code>, desta forma tudo que for feito no diretório <code class="language-plaintext highlighter-rouge">/comp</code> dos containers será refletido para os outros containers e para o diretório <code class="language-plaintext highlighter-rouge">/tmp/share</code> do <em>host</em>, veja só:</p>

<ul>
  <li>Agora podemos conectar ao <code class="language-plaintext highlighter-rouge">container2</code>, criar um arquivo, tal como <code class="language-plaintext highlighter-rouge">echo "ola do container2" &gt; /comp/container2.txt</code>, tal como:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker attach container2
<span class="gp">[root@648f9a9d64e0 /]#</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">"ola do container2"</span> <span class="o">&gt;</span> /comp/container2.txt
</code></pre></div></div>

<ul>
  <li>Vamos agora verificar se tal arquivo está no <code class="language-plaintext highlighter-rouge">container1</code> e também vamos criar um arquivo lá:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker attach container1
<span class="gp">[root@22d1729f5c88 /]#</span><span class="w"> </span><span class="nb">cat</span> /comp/container2.txt
<span class="go">ola do container2
</span><span class="gp">[root@22d1729f5c88 /]#</span><span class="w"> </span>vi /comp/teste.txt
<span class="gp">[root@22d1729f5c88 /]#</span><span class="w"> </span><span class="nb">cat</span> /etc/hostname <span class="o">&gt;</span> /comp/container1.txt
</code></pre></div></div>

<ul>
  <li>Por fim, vamos acessar tais arquivos a partir do <em>host</em> hospedeiro:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> /tmp/share/container1.txt
<span class="go">22d1729f5c88
</span><span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> /tmp/share/container2.txt
<span class="go">ola do container2
</span></code></pre></div></div>

<p>É possível verificar os volumes sendo compartilhados com o comando <code class="language-plaintext highlighter-rouge">docker volume ls</code>, bem como verificar os detalhes de um volume com o comando <code class="language-plaintext highlighter-rouge">docker volume inspect</code> seguido da identificação do volumes (descoberta com o comando anterior). Há outras opções, que podem ser vistas na documentação do Docker.</p>

<p>Então, o Docker através do <code class="language-plaintext highlighter-rouge">VOLUME</code>, <code class="language-plaintext highlighter-rouge">-v</code> e <code class="language-plaintext highlighter-rouge">--volumes-from</code>, cria uma forma bem fácil de compartilhar diretórios entre containers e <em>host</em>.</p>

<p>::: note
Outra forma de compartilhar dados entre containers e <em>host</em> seria via rede, mas isso normalmente é bem mais trabalhoso do que utilizar essa técnica de VOLUME utilizada pelo Docker.
:::</p>

<h2 id="sec:portas">Relacionando portas de container com o <em>host</em> hospedeiro</h2>

<p>Normalmente ao criar-se um container, esse é ligado à uma rede privada relacionada ao Docker. Tal rede normalmente fica trás de um NAT (Network Address Translation), significando que os serviços de rede executados pelo container não podem ser acessados por outros computadores externos à rede Docker.</p>

<p>Por exemplo, na [@fig:redeDocker1], a rede 172.17.0.0/24 é uma rede privada que somente o <em>host</em> hospedeiro e os containers deste <em>host</em> podem acessar. Assim, outros <em>hosts</em> tal como o Host A, não conseguem acessar por padrão tal rede dos containers.</p>

<p><img src="imagens/redeDocker1.svg" alt="Rede Docker - 172.17.0.0/24" />{#fig:redeDocker1}</p>

<p>Todavia, existem casos em que é necessário expor para fora da rede Docker, os serviços de rede de alguns containers Docker. Sendo assim, há algumas formas de fazer isso, mas talvez a forma mais prática e fácil, é a fornecida pelo próprio Docker, que permite relacionar a porta do container com alguma porta do <em>host</em> hospedeiro. Desta forma, ao se tentar acessar tal porta relacionada do hospedeiro, será na verdade acessado o container.</p>

<p>No Docker, essa tarefa de acessar o container através do IP do <em>host</em> hospedeiro é chamada de “expor” (<strong><em>expose</em></strong>) ou publicar (<strong>publish</strong>) a porta do container. Assim, para expor/publicar a porta de um container, ou melhor para relacionar a porta do container com alguma porta do <em>host</em> hospedeiro, é possível utilizar no <code class="language-plaintext highlighter-rouge">docker run</code>, uma das seguintes opções:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">-P</code></strong> ou <strong><code class="language-plaintext highlighter-rouge">--publish-all</code></strong>: expõem todas as portas declaradas no Dockerfile pela instrução <strong><code class="language-plaintext highlighter-rouge">EXPOSE</code></strong>;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">-p</code></strong> ou <strong><code class="language-plaintext highlighter-rouge">--publish</code></strong>: expõem apenas uma porta de um dado protocolo do container.</li>
</ul>

<p>Então, ao se utilizar o <code class="language-plaintext highlighter-rouge">-P</code> (menos “P” maiúsculo), é necessário dizer de forma explicita via Dockerfile, quais serviços de rede estão disponíveis do container e a relação porta do hospedeiro, com a porta do container, será feita de forma automática.
Já com a opção <code class="language-plaintext highlighter-rouge">-p</code> (menos “p” minúsculo), é necessário indicar qual porta do container será exposta, todavia neste caso, não é necessário que esta esteja declarada no Dockerfile via <code class="language-plaintext highlighter-rouge">EXPOSE</code>.</p>

<p>A seguir são apresentadas alguns exemplos de uso dessas opções, bem como do uso prático da técnica de <em>expose</em>/<em>publish</em> do Docker.</p>

<h3 id="expondo-as-portas-do-container-via--p-e-expose">Expondo as portas do container via <code class="language-plaintext highlighter-rouge">-P</code> e <code class="language-plaintext highlighter-rouge">EXPOSE</code></h3>

<p>Para entender como funciona o <code class="language-plaintext highlighter-rouge">-P</code>, vamos criar uma imagem via Dockerfile, sendo que essa imagem terá os servidores HTTP e SSH. Assim, será possível acessar tal container via HTTP e gerenciá-lo via SSH. Tal arquivo Dockerfile fica da seguintes forma:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>vi Dockerfile
<span class="go">
FROM servidor/build_fedora_apache
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
RUN dnf install -y openssh-server
RUN mkdir /run/php-fpm/
RUN mkdir -p /var/www/html/php
</span><span class="gp">RUN echo -e "#</span><span class="o">!</span>/bin/bash <span class="se">\n</span>/sbin/sshd &amp; <span class="se">\n</span>/sbin/httpd <span class="nt">-DFOREGROUND</span> <span class="se">\n</span>/bin/read<span class="s2">"  &gt; /sbin/startServer.sh
</span><span class="go">RUN chmod a+x /sbin/startServer.sh
RUN ssh-keygen -A
RUN adduser -ms /bin/bash admin
RUN echo "admin:123mudar" | chpasswd
EXPOSE 22 80
CMD ["/sbin/startServer.sh"]
</span></code></pre></div></div>

<p>O arquivo Dockerfile anterior, é bem similar ao servidor HTTP que já havíamos criado anteriormente (utiliza a imagem base <code class="language-plaintext highlighter-rouge">servidor/build_fedora_apache</code>), mas neste agora foi:</p>

<ul>
  <li>Instalado o SSH (<code class="language-plaintext highlighter-rouge">RUN dnf install -y openssh-server</code>);</li>
  <li>O <em>script</em> foi alterado para iniciar o servidor SSH (<code class="language-plaintext highlighter-rouge">.../sbin/sshd...</code>);</li>
  <li>Gerada a chave criptográfica utilizada pelo SSH (<code class="language-plaintext highlighter-rouge">RUN ssh-keygen -A</code>);</li>
  <li>Criado um usuário chamado <code class="language-plaintext highlighter-rouge">admin</code> (<code class="language-plaintext highlighter-rouge">adduser -ms /bin/bash admin</code>);</li>
  <li>Foi definida a senha do <code class="language-plaintext highlighter-rouge">admin</code>, como sendo <code class="language-plaintext highlighter-rouge">123mudar</code> (<code class="language-plaintext highlighter-rouge">echo "admin:123mudar" | chpasswd</code>);</li>
  <li>Por fim, foi informado ao Docker para expor as portas do SSH (TCP/22) e HTTP (TCP/80).</li>
</ul>

<p>Com o Dockerfile anterior, geramos a imagem do servidor em questão:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker build <span class="nt">-t</span><span class="o">=</span><span class="s2">"servidor/http"</span> <span class="nb">.</span>
</code></pre></div></div>

<p>Criamos um container a partir da imagem gerada:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> container1 <span class="nt">-P</span> <span class="nt">-d</span> servidor/http
</code></pre></div></div>

<p>Note que no comando anterior, foi utilizada a opção <code class="language-plaintext highlighter-rouge">-P</code>, que cria uma relação com as portas do <code class="language-plaintext highlighter-rouge">EXPOSE</code> do container, com portas do <em>host</em> hospedeiro. Tal relação pode ser vista com o comando <code class="language-plaintext highlighter-rouge">docker ps</code> (ver a seguir) ou via comando <code class="language-plaintext highlighter-rouge">iptables</code>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE           COMMAND                  CREATED         STATUS         PORTS                                                                              NAMES
</span><span class="gp">fb0673258719   servidor/http   "/sbin/startServer.sh"   7 seconds ago   Up 6 seconds   0.0.0.0:32770-&gt;</span>22/tcp, :::32770-&gt;22/tcp, 0.0.0.0:32771-&gt;80/tcp, :::32771-&gt;80/tcp   container1
</code></pre></div></div>

<p>::: important
As portas relacionadas com o <code class="language-plaintext highlighter-rouge">-P</code> no <em>host</em> hospedeiros são normalmente altas e aleatórias, tal como a 32770 do exemplo anterior. Também aparecem na listagem IPv4 e IPv6.
:::</p>

<p>Assim, feita a relação entre portas do container chamado <code class="language-plaintext highlighter-rouge">container1</code> e o <em>host</em>, podemos agora acessar, por exemplo o servidor SSH do container, através do IP de <em>localhost</em> do próprio <em>host</em> hospedeiro, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[luiz@fielDell expose]$</span><span class="w"> </span>ssh admin@127.0.0.1 <span class="nt">-p</span> 32770
<span class="c">...
</span><span class="go">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[127.0.0.1]:32770' (ED25519) to the list of known hosts.
admin@127.0.0.1's password:
</span><span class="gp">[admin@fb0673258719 ~]$</span><span class="w"> </span><span class="nb">cat</span> /etc/hosts
<span class="go">127.0.0.1	localhost
</span><span class="c">...
</span><span class="go">172.17.0.2	fb0673258719
</span></code></pre></div></div>

<p>O teste anterior foi feito a partir do próprio <em>host</em> hospedeiro, mas já seria possível acessar o container a partir do <em>host</em> hospedeiro utilizando o IP da rede Docker (sem usar a técnica de expor portas, ou seja acessando por exemplo o IP 172.17.0.2 do container). Todavia o leitor tem que ter em mente que isso não seria possível de <em>hosts</em> externos, mas agora utilizando a prática de expor portas do Docker, é possível acessar o container através do IP do <em>host</em> hospedeiro.</p>

<p>Por exemplo, imagine que o <em>host</em> hospedeiro tem o IP 200.0.0.1 (disponível na Internet). Qualquer <em>host</em> da Internet que executar o comando <code class="language-plaintext highlighter-rouge">ssh admin@200.0.0.1 -p 32770</code>, estará na verdade acessando o container <code class="language-plaintext highlighter-rouge">container1</code> e não o <em>host</em> hospedeiro, tal como é ilustrado na [@fig:redeDocker1].</p>

<h3 id="expondo-as-portas-do-container-via--p">Expondo as portas do container via <code class="language-plaintext highlighter-rouge">-p</code></h3>

<p>Como visto anteriormente, a opção <code class="language-plaintext highlighter-rouge">-P</code> precisa da instrução <code class="language-plaintext highlighter-rouge">EXPOSE</code> da imagem Docker, mas é possível expor uma porta do container, sem utilizar o <code class="language-plaintext highlighter-rouge">EXPOSE</code> da imagem. Isso é feito com a opção <code class="language-plaintext highlighter-rouge">-p</code>, assim basta criar um container com <code class="language-plaintext highlighter-rouge">docker run</code> passando como parâmetro o <code class="language-plaintext highlighter-rouge">-p</code>, seguido da porta que será exposta (é claro que o container tem que fornecer algum serviço de rede na porta em questão). Tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[luiz@fielDell expose]$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> container2 <span class="nt">-p</span> 80 <span class="nt">-d</span> servidor/http
<span class="go">d37c43975129a683e32430910140bf8e07b3f30b8864d9988246c2b05d10ca29
</span></code></pre></div></div>

<p>O comando anterior cria um container chamado <code class="language-plaintext highlighter-rouge">container2</code>, e expõem a porta 80/TCP, tal como pode ser visto da saída a seguir:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[luiz@fielDell expose]$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS                                                                              NAMES
</span><span class="gp">d37c43975129   servidor/http   "/sbin/startServer.sh"   41 seconds ago   Up 40 seconds   22/tcp, 0.0.0.0:32775-&gt;</span>80/tcp, :::32775-&gt;80/tcp                                    container2
<span class="gp">013b8cb020ca   servidor/http   "/sbin/startServer.sh"   46 seconds ago   Up 45 seconds   0.0.0.0:32773-&gt;</span>22/tcp, :::32773-&gt;22/tcp, 0.0.0.0:32774-&gt;80/tcp, :::32774-&gt;80/tcp   container1
</code></pre></div></div>

<p>Conforme a saída anterior, a porta 80/TCP do <code class="language-plaintext highlighter-rouge">container2</code>, ficou disponível na porta 32775 do <em>host</em> hospedeiro. É importante notar que devido ao <code class="language-plaintext highlighter-rouge">EXPOSE</code> do Dockerfile dessa imagem, a porta 22/TCP também aparece na listagem, mas ela não está acessível via <em>host</em> hospedeiro.</p>

<p>Como visto no exemplo anterior com o <code class="language-plaintext highlighter-rouge">-P</code> e aqui com o <code class="language-plaintext highlighter-rouge">-p</code>, a porta relacionada com o <em>host</em> hospedeiro é alta e aleatória, todavia com o <code class="language-plaintext highlighter-rouge">-p</code> é possível determinar qual é a porta que será utilizada no <em>host</em> hospedeiro, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[luiz@fielDell expose]$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> container3 <span class="nt">-p</span> 80:80 <span class="nt">-d</span> servidor/http
<span class="go">487bafe91e7567e91c79bf6c69039d468486ed0695e6c3169f559fac85d291ef
</span></code></pre></div></div>

<p>O comando anterior informa na opção <code class="language-plaintext highlighter-rouge">-p</code> a <code class="language-plaintext highlighter-rouge">&lt;porta do host&gt;:&lt;porta do container&gt;</code>, isso pode ser visto com o <code class="language-plaintext highlighter-rouge">docker ps</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[luiz@fielDell expose]$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE           COMMAND                  CREATED         STATUS         PORTS                                                                              NAMES
</span><span class="gp">487bafe91e75   servidor/http   "/sbin/startServer.sh"   5 seconds ago   Up 5 seconds   22/tcp, 0.0.0.0:80-&gt;</span>80/tcp, :::80-&gt;80/tcp                                          container3
<span class="gp">d37c43975129   servidor/http   "/sbin/startServer.sh"   7 minutes ago   Up 7 minutes   22/tcp, 0.0.0.0:32775-&gt;</span>80/tcp, :::32775-&gt;80/tcp                                    container2
</code></pre></div></div>

<p>Desta forma, agora quem tentar acessar a porta 80/TCP do <em>host</em> hospedeiro, na verdade vai acessar o HTTP do <code class="language-plaintext highlighter-rouge">container3</code>.</p>

<p>::: important
Poder relacionar a porta do container com uma porta específica do <em>host</em> hospedeiro é muito importante na prática, pois é possível deixar um serviço em execução em um Docker responder como se fosse o <em>host</em> hospedeiro, sem muitas complicações.
:::</p>

<p>Ainda é possível fazer outras combinações de parâmetros para expor portas no Docker, tais como:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">docker run -p 53/udp &lt;imagem&gt;</code>: expõem a porta 53/UDP -  ou seja, é possível expor portas TCP (que são o padrão caso não se especifique o protocolo e UDP, sendo que essas devem ser declaradas explicitamente com o <code class="language-plaintext highlighter-rouge">&lt;porta&gt;/udp</code>;</li>
  <li><code class="language-plaintext highlighter-rouge">docker run -p 22/tcp -p 53/udp &lt;imagem&gt;</code>: É possível passar mais de uma porta para ser exposta via <code class="language-plaintext highlighter-rouge">-p</code>;</li>
  <li><code class="language-plaintext highlighter-rouge">docker run -p 192.168.0.1:722:22/tcp &lt;imagem&gt;</code>: Caso o <em>host</em> tenha vários IPs, é possível informar qual desses IPs vai servir a porta exposta do container. Note que caso não seja passado o IP, o Docker vai assumir que o serviço responde por qualquer IP do <em>host</em> hospedeiro (0.0.0.0 - IP <em>this host</em>). Determinar o IP pode ser útil para garantir a segurança de alguns serviços, por exemplo, o SSH pode ser acessível por um IP local, mas não para IPs da Internet;</li>
  <li><code class="language-plaintext highlighter-rouge">EXPOSE 53/UDP</code>: Também é possível expor uma porta UDP via Dockerfile, e depois publicá-la via <code class="language-plaintext highlighter-rouge">-P</code>.</li>
</ul>

<h2 id="utilizando-variáveis-para-fazer-configurações-mais-dinâmicas">Utilizando variáveis para fazer configurações mais dinâmicas</h2>

<p>O Dockerfile permite inserir variáveis dentro da imagem e container sendo criados, isso é feito com a instrução <code class="language-plaintext highlighter-rouge">ENV</code>. Desta forma, é possível criar imagens com configurações mais dinâmicas.</p>

<p>Por exemplo, vamos incrementar o Dockerfile da seção anterior, para que esse permita alterar a porta do servidor Apache HTTP, isso pode ser feito da seguinte forma:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>vi Dockerfile
<span class="go">
FROM servidor/build_fedora_apache
MAINTAINER Luiz Arthur "luizsantos@utfpr.edu.br"
RUN dnf update -y
RUN dnf install -y openssh-server
RUN mkdir -p /var/www/html/php
</span><span class="gp">RUN echo -e "#</span><span class="o">!</span>/bin/bash <span class="se">\n</span>/sbin/sshd &amp;<span class="se">\n</span>/sbin/httpd <span class="nt">-DFOREGROUND</span> <span class="se">\n</span>/bin/read<span class="s2">"  &gt; /sbin/startServer.sh
</span><span class="go">ENV HTTP_PORT 81
COPY httpd.conf /etc/httpd/conf/httpd.conf
RUN chmod a+x /sbin/startServer.sh
RUN ssh-keygen -A
RUN adduser -ms /bin/bash admin
RUN echo "admin:123mudar" | chpasswd
CMD ["/sbin/startServer.sh"]
</span></code></pre></div></div>

<p>Neste novo Dockerfile foram incluídas as seguintes instruções/linhas:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ENV HTTP_PORT 81</code>, que será uma variável utilizada para determinar a porta do servidor HTTP;</li>
  <li><code class="language-plaintext highlighter-rouge">COPY httpd.conf /etc/httpd/conf/httpd.conf</code>, está copiando o arquivo de configuração do servidor HTTP alterado. A alteração consistem apenas em trocar <code class="language-plaintext highlighter-rouge">Listen 80</code> por <code class="language-plaintext highlighter-rouge">Listen ${HTTP_PORT}</code>, sendo que<code class="language-plaintext highlighter-rouge">${HTTP_PORT}</code> será substituído pelo conteúdo da variável <code class="language-plaintext highlighter-rouge">HTTP_PORT</code> determinado pela instrução <code class="language-plaintext highlighter-rouge">ENV</code> anterior (para obter o arquivo <code class="language-plaintext highlighter-rouge">httpd.conf</code> foi feito um <code class="language-plaintext highlighter-rouge">scp</code> para um container desta imagem).</li>
</ul>

<p>Agora ao se criar um container a partir dessa imagem, o servidor HTTP estará por padrão na porta 81, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--name</span> server1 <span class="nt">-p</span> 81:81 <span class="nt">-d</span> servidor/http
<span class="go">eeec6fb36a47ecb80f52d601e82fa3c34837a657f5951276bab4b8a1460b0c5b

</span><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE           COMMAND                  CREATED         STATUS         PORTS                               NAMES
</span><span class="gp">eeec6fb36a47   servidor/http   "/sbin/startServer.sh"   7 seconds ago   Up 6 seconds   0.0.0.0:81-&gt;</span>81/tcp, :::81-&gt;81/tcp   server1
</code></pre></div></div>

<p>Também é possível alterar essas variáveis na execução do <code class="language-plaintext highlighter-rouge">docker run</code>, com a opção <code class="language-plaintext highlighter-rouge">-e</code> ou <code class="language-plaintext highlighter-rouge">--env</code>, veja o exemplo a seguir:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> server2 <span class="nt">-e</span> <span class="nv">HTTP_PORT</span><span class="o">=</span>8080 <span class="nt">-p</span> 82:8080 <span class="nt">-d</span> servidor/http
<span class="go">bd9e590d78834d35ad85f5eb68dc5c803fa402d527ccc26adaf56c2e1507d861

</span><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS                                   NAMES
</span><span class="gp">bd9e590d7883   servidor/http   "/sbin/startServer.sh"   6 seconds ago    Up 5 seconds    0.0.0.0:82-&gt;</span>8080/tcp, :::82-&gt;8080/tcp   server2
<span class="gp">eeec6fb36a47   servidor/http   "/sbin/startServer.sh"   48 seconds ago   Up 47 seconds   0.0.0.0:81-&gt;</span>81/tcp, :::81-&gt;81/tcp       server1
</code></pre></div></div>

<p>No exemplo anterior o container foi criando com o servidor HTTP sendo executado na porta 8080 (<code class="language-plaintext highlighter-rouge">-e HTTP_PORT=8080</code>) e foi exposta no <em>host</em> hospedeiro na porta 82 (<code class="language-plaintext highlighter-rouge">-p 82:8080</code>).</p>

<p>::: important
É possível alterar variáveis com o <code class="language-plaintext highlighter-rouge">-e</code>, sem que a variável exista no Dockerfile pela instrução <code class="language-plaintext highlighter-rouge">ENV</code>.
:::</p>

<p>Ainda quanto as variáveis, é possível passar as variáveis através de um arquivo chamado <code class="language-plaintext highlighter-rouge">.env</code> utilizando a opção <code class="language-plaintext highlighter-rouge">--env-file</code>. Também é possível passar mais de uma variável no <code class="language-plaintext highlighter-rouge">docker run</code> para isso basta utilizar mais de uma vez o <code class="language-plaintext highlighter-rouge">-e</code>.</p>

<h3 id="verificando-as-variáveis-do-container">Verificando as variáveis do container</h3>

<p>Para verificar quais variáveis temos em um container, é possível executar os seguintes comandos:</p>

<ul>
  <li>Inspecionando os eventos de um container em execução:
    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect server1 <span class="nt">--format</span><span class="o">=</span><span class="s1">''</span>
<span class="go">["HTTP_PORT=8080","PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin","DISTTAG=f40container","FGC=f40","FBR=f40"]
</span></code></pre></div>    </div>
  </li>
  <li>Executando o comando <code class="language-plaintext highlighter-rouge">printenv</code> em um container em execução:
    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec </span>server1 <span class="nb">printenv</span>
<span class="go">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=dd0de51f4289
HTTP_PORT=8080
DISTTAG=f40container
FGC=f40
FBR=f40
HOME=/root
</span></code></pre></div>    </div>
  </li>
  <li>Criando um container para executar o <code class="language-plaintext highlighter-rouge">printenv</code> e deletando ele na sequência, lembrando que aqui ele provavelmente só vai executar o <code class="language-plaintext highlighter-rouge">printenv</code>, vai parar e por consequência será deletado pela opção <code class="language-plaintext highlighter-rouge">--rm</code>:
    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> servidor/http <span class="nb">printenv</span>
<span class="go">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=08929852c21d
DISTTAG=f40container
FGC=f40
FBR=f40
HTTP_PORT=81
HOME=/root
</span></code></pre></div>    </div>
  </li>
</ul>

<p>As variáveis podem ser muito úteis para criar configurações mais dinâmicas e personalizadas.</p>

<h1 id="rede-docker">Rede Docker</h1>

<p>O modelo de rede utilizado pelo Docker parece inicialmente mágica, pois é só ligar um container, que este vai estar conectado à rede e provavelmente à Internet.</p>

<p>::: note
A rede padrão Docker vai dar acesso à qualquer rede que o <em>host</em> hospedeiro estiver conectado, inclusive à Internet. Todavia, é importante perceber que o container não vai acessar, por exemplo a Internet, se o <em>host</em> hospedeiro não tiver acesso a mesma.
:::</p>

<p>No geral, a maioria das pessoas não vão precisar alterar as configurações padrão das redes Docker, mas para o administrador é bom saber como funciona a rede Docker, pois existem casos em que será necessário alterar tal rede para atender os requisitos do cliente.</p>

<p>Normalmente a rede Docker funciona através de uma placa rede virtual no modo <em>bridge</em> (Linux network <em>bridge</em>), tal placa virtual é geralmente identificada no <em>host</em> hospedeiro como sendo a placa de rede chamada de <code class="language-plaintext highlighter-rouge">docker0</code>. Tal placa de rede normalmente estará provavelmente com uma faixa de rede como: 172.17.0.0/16, ou alguma rede privada similar. A [@fig:redeDockerArquitetura] mostra mais ou menos como é a arquitetura de uma rede Docker.</p>

<p><img src="imagens/redeDockerArquitetura.svg" alt="Arquitetura da rede Docker" />{#fig:redeDockerArquitetura}</p>

<p>Analisando a [@fig:redeDockerArquitetura], observe que o <em>host</em> hospedeiro possui uma placa de rede que lhe conecta ao mundo externo, neste caso ela é representada pelo <code class="language-plaintext highlighter-rouge">eth0</code> com o IP 200.0.0.1, mas poderiam haver mais placas de redes no hospedeiro. Interligada à essa placa de rede física, temos a <em>bridge</em> Docker, chamada de <code class="language-plaintext highlighter-rouge">docker0</code>. Tal <em>bridge</em> está conectada às placas de rede Ethernets virtuais, chamadas de <code class="language-plaintext highlighter-rouge">veth</code>, que por sua vez estão ligadas às placas de redes <code class="language-plaintext highlighter-rouge">eth0</code>, que estão dentro do container. No cenário da [@fig:redeDockerArquitetura], a rede Docker tem o IP de rede 172.17.0.0/16, dentro dessa faixa, cada placa de rede do container receberá um IP, tal como: <code class="language-plaintext highlighter-rouge">docker0</code> - 172.17.0.1, <code class="language-plaintext highlighter-rouge">eth0</code> do container A 172.17.0.2, <code class="language-plaintext highlighter-rouge">eth0</code> do container B 172.17.0.3.</p>

<p>Para entender melhor tal estrutura vamos ver a saída do comando <code class="language-plaintext highlighter-rouge">ifconfig</code> do <em>host</em> hospedeiro:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>ifconfig
<span class="c">...
</span><span class="gp">wlp3s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 192.168.1.39  netmask 255.255.255.0  broadcast 192.168.1.255
</span><span class="gp">        inet6 fd1b:e114:982d:0:178e:95e1:9108:a880  prefixlen 64  scopeid 0x0&lt;global&gt;</span><span class="w">
</span><span class="gp">        inet6 fe80::5b45:9e7d:f26a:f155  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="gp">        inet6 fd1b:e114:982d::bd6  prefixlen 128  scopeid 0x0&lt;global&gt;</span><span class="w">
</span><span class="go">        ether 60:57:18:f1:b7:01  txqueuelen 1000  (Ethernet)
        RX packets 1079884  bytes 968144506 (923.2 MiB)
        RX errors 0  dropped 9443  overruns 0  frame 0
        TX packets 649598  bytes 243084853 (231.8 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
</span><span class="gp">        inet6 fe80::42:adff:fe35:6161  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 02:42:ad:35:61:61  txqueuelen 0  (Ethernet)
        RX packets 6195  bytes 490719 (479.2 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 9009  bytes 11484489 (10.9 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">veth2252825: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="gp">        inet6 fe80::2cd3:1fff:fe81:c076  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 2e:d3:1f:81:c0:76  txqueuelen 0  (Ethernet)
        RX packets 314  bytes 67348 (65.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1297  bytes 276751 (270.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">vetha7892f9: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="gp">        inet6 fe80::78b1:b0ff:fe8d:906e  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 7a:b1:b0:8d:90:6e  txqueuelen 0  (Ethernet)
        RX packets 947  bytes 108441 (105.8 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1752  bytes 3220046 (3.0 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span></code></pre></div></div>

<p>Na saída do <em>host</em> anterior, no lugar da <code class="language-plaintext highlighter-rouge">eth0</code> temos a <code class="language-plaintext highlighter-rouge">wlp3s0</code>, que é a placa física que dá acesso a outras redes, tai como a Internet. A placa de rede <code class="language-plaintext highlighter-rouge">docker0</code> com o IP 172.17.0.1, que simboliza a <em>bridge</em> Docker. Também temos duas placas <code class="language-plaintext highlighter-rouge">veth</code>, que são: <code class="language-plaintext highlighter-rouge">veth2252825</code> e <code class="language-plaintext highlighter-rouge">vetha7892f9</code>, tais placas não possuem IPs, pois os IPs são atribuídos às placas de rede que estão dentro do container (neste caso temos dois containers em execução), similar à [@fig:redeDockerArquitetura].</p>

<p>As placas de rede <code class="language-plaintext highlighter-rouge">veth</code> e sua relação com a <code class="language-plaintext highlighter-rouge">docker0</code> podem ser melhor vistas com o comando <code class="language-plaintext highlighter-rouge">brctl</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>brctl show
<span class="go">bridge name	 bridge id		    STP enabled	 interfaces
docker0		 8000.0242ad356161	no		     veth2252825
                                             vetha7892f9
</span></code></pre></div></div>

<p>Assim, quando um container é criando, o Docker cria uma placa <code class="language-plaintext highlighter-rouge">veth</code> e relaciona essa com a <code class="language-plaintext highlighter-rouge">docker0</code>, feito isso é dado ao container um IP dentro da faixa de rede utilizada pela rede Docker, bem como é inserido no container o IP do <em>gateway</em> padrão e do servidor DNS. Ao fim, o container terá capacidade de acessar outras redes - é claro se o <em>host</em> hospedeiro tiver acesso a outras redes, tal como a Internet.</p>

<p>É importante saber, que para um container acessar outras redes, o <em>host</em> hospedeiro deve funcionar como um roteador, ou seja o arquivo <code class="language-plaintext highlighter-rouge">/proc/sys/net/ipv4/ip_forward</code> deve estar com o conteúdo 1. Também, o <em>host</em> hospedeiro utilizará o <code class="language-plaintext highlighter-rouge">iptables</code> para realizar um NAT dos pacotes que forem roteados para fora da rede Docker. Essas duas configurações normalmente serão feitas automaticamente pelo <em>host</em> Docker.</p>

<p>Por padrão, todo container pode se comunicar com outro container, mas isso pode ser alterado na inicialização do Docker, configurando a opção <code class="language-plaintext highlighter-rouge">--icc</code> em como falso, tal como: <code class="language-plaintext highlighter-rouge">--icc=false</code>.</p>

<p>Agora que conhecemos um pouco mais a respeito de como funciona a rede Docker, a seguir serão apresentadas algumas características extras da configuração de rede no Docker.</p>

<h2 id="descobrindo-os-ips-rotas-e-dns-dos-containers">Descobrindo os IPs, rotas e DNS dos containers</h2>

<p>Há várias formas de descobrir IPs de containers, algumas dessas são apresentadas nas subseções a seguir.</p>

<h3 id="utilizando-o-inspect">Utilizando o <code class="language-plaintext highlighter-rouge">inspect</code></h3>

<p>Com o <code class="language-plaintext highlighter-rouge">inspect</code> do Docker é possível procurar no JSON pelas configurações de redes e chegar no IP, tal como:</p>

<p>```$ docker inspect –format ‘’ server1
172.17.0.2</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
::: note
Estamos utilizando os containers criados na seção anterior.
:::

### Utilizando o ``exec``

Utilizando o ``exec`` seguido de algum comando Linux (o comando deve estar presente no container), tal como:

* Verificando o arquivo ``/etc/hosts``:

```console
$ docker exec -ti server1 cat /etc/hosts
127.0.0.1	localhost
...
172.17.0.2	dd0de51f4289
</code></pre></div></div>

<ul>
  <li>Utilizando comandos do container para ver IP, tal como <code class="language-plaintext highlighter-rouge">ip</code> e <code class="language-plaintext highlighter-rouge">ifconfig</code>:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server1 ip addres
</code></pre></div></div>

<ul>
  <li>Executando um terminal e executando comandos diretamente no container:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server1 bash
<span class="gp">[root@dd0de51f4289 /]#</span>ifconfig
<span class="gp">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)
        RX packets 271  bytes 53964 (52.6 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;</span><span class="w">  </span>mtu 65536
<span class="go">        inet 127.0.0.1  netmask 255.0.0.0
</span><span class="gp">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><span class="w">
</span><span class="go">        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span></code></pre></div></div>

<p>Para descobrir as rotas utilizadas pelo container, é possível executar via <code class="language-plaintext highlighter-rouge">exec</code> o comando <code class="language-plaintext highlighter-rouge">route</code> ou <code class="language-plaintext highlighter-rouge">ip route</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec </span>server1 route <span class="nt">-n</span>
<span class="go">Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0
</span></code></pre></div></div>

<p>Já para identificar a configuração de servidor DNS utilizado pelo container, também é possível realizar um <code class="language-plaintext highlighter-rouge">exec</code>, só que executando um <code class="language-plaintext highlighter-rouge">cat /etc/resolv.conf</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec </span>server1 <span class="nb">cat</span> /etc/resolv.conf
<span class="go">nameserver 192.168.1.1
</span></code></pre></div></div>

<h3 id="utilizando-o-nsenter">Utilizando o <code class="language-plaintext highlighter-rouge">nsenter</code></h3>

<p>Outra ferramenta bem útil para ver IPs dos containers, bem como realizar interações em containers é o <code class="language-plaintext highlighter-rouge">nsenter</code>, na verdade á mais recomendável utilizar ela do que o <code class="language-plaintext highlighter-rouge">exec</code>. Veja a seguir como utilizar o <code class="language-plaintext highlighter-rouge">nsenter</code> para ver as informações de rede do container. Neste caso primeiro é necessário encontrar o PID do processo, isso pode ser feito da seguinte forma:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect <span class="nt">-f</span> <span class="s1">''</span> server1
<span class="go">18522
</span></code></pre></div></div>

<p>No caso o valor retornado foi <code class="language-plaintext highlighter-rouge">18522</code>, agora podemos utilizar esse PID com o <code class="language-plaintext highlighter-rouge">nsenter</code> e verificar/alterar informações a respeito do <em>namespace</em> utilizado pelo container, tal como ver a configuração de rede:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>nsenter <span class="nt">-t</span> 18522 <span class="nt">--net</span> ip address
<span class="gp">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt;</span><span class="w"> </span>mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
<span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host proto kernel_lo
       valid_lft forever preferred_lft forever
</span><span class="gp">76: eth0@if77: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span><span class="w"> </span>mtu 1500 qdisc noqueue state UP group default
<span class="go">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</span></code></pre></div></div>

<p>::: note</p>

<p>:::</p>

<p>::: important
O <code class="language-plaintext highlighter-rouge">nsenter</code> permite executar comando que estão no <em>host</em> hospedeiro e não estão no container. Por exemplo, o comando <code class="language-plaintext highlighter-rouge">ip</code> não está instalado no container, mas está instalado no <em>host</em> hospedeiro, então esse será executado do hospedeiro no <em>namespace</em> do container, e por isso o comando funcionará. Por isso, é bem interessante que o administrador pesquise e saiba como utilizar o <code class="language-plaintext highlighter-rouge">nsenter</code>.
:::</p>

<h2 id="descobrindo-portas-publicadas-ou-abertas-nos-containers">Descobrindo portas publicadas ou abertas nos containers</h2>

<p>A [@sec:portas] já apresentou como mostrar portas disponíveis em container, mas aqui são apresentadas mais algumas:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">docker ps</code>:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE           COMMAND                  CREATED        STATUS        PORTS                                   NAMES
</span><span class="gp">dd0de51f4289   servidor/http   "/sbin/startServer.sh"   12 hours ago   Up 12 hours   0.0.0.0:82-&gt;</span>8080/tcp, :::82-&gt;8080/tcp   server1
</code></pre></div></div>

<ul>
  <li>Executando <code class="language-plaintext highlighter-rouge">iptables</code> no <em>host</em> hospedeiro:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>iptables <span class="nt">-L</span> <span class="nt">-n</span> <span class="nt">-t</span> nat
<span class="c">...
</span><span class="go">Chain DOCKER (2 references)
target     prot opt source               destination
RETURN     0    --  0.0.0.0/0            0.0.0.0/0
DNAT       6    --  0.0.0.0/0            0.0.0.0/0            tcp dpt:82 to:172.17.0.2:8080
</span></code></pre></div></div>

<ul>
  <li>Procurando com o comando <code class="language-plaintext highlighter-rouge">ps</code> no <em>host</em> hospedeiro:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>ps <span class="nt">-ef</span> | <span class="nb">grep </span>docker-proxy
<span class="go">root       18474     773  0 Sep17 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 82 -container-ip 172.17.0.2 -container-port 8080
root       18481     773  0 Sep17 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 82 -container-ip 172.17.0.2 -container-port 8080
luiz       20905    5325  0 11:25 pts/1    00:00:00 grep docker-proxy
</span></code></pre></div></div>

<ul>
  <li>Inspecionando:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect <span class="nt">--format</span> <span class="s1">''</span> server1
<span class="go">map[8080/tcp:[{ 82}]]
</span></code></pre></div></div>

<ul>
  <li>Verificando os serviços de rede disponíveis no container com o <code class="language-plaintext highlighter-rouge">netstat</code> ou <code class="language-plaintext highlighter-rouge">ss</code>:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec </span>server1 netstat <span class="nt">-a</span> <span class="nt">--tcp</span> <span class="nt">-np</span>
<span class="go">Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      8/httpd
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      9/sshd: /sbin/sshd
tcp6       0      0 :::22                   :::*                    LISTEN      9/sshd: /sbin/sshd
</span></code></pre></div></div>

<h2 id="testando-a-conectividade-entre-containers">Testando a conectividade entre containers</h2>

<p>Há várias formas para se testar a conectividade. Po exemplo, dá para utilizar o <code class="language-plaintext highlighter-rouge">exec</code> para executar comandos como o <code class="language-plaintext highlighter-rouge">ping</code>, mas a seguir vamos executar um <code class="language-plaintext highlighter-rouge">bash</code>, instalar o <code class="language-plaintext highlighter-rouge">ping</code> e realizar o teste de dentro do container:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[luiz@fielDell env]$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server2 bash
<span class="c">...
</span><span class="gp">[root@05eaec227a5f /]#</span><span class="w"> </span>dnf <span class="nb">install </span>iputils
<span class="c">...
</span><span class="go">Installed:
  iputils-20240117-4.fc40.x86_64

Complete!
</span><span class="c">...
</span><span class="gp">[root@05eaec227a5f /]#</span><span class="w"> </span>ping 172.17.0.2
<span class="go">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.070 ms
64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.071 ms
64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.061 ms
64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.106 ms
64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.056 ms
</span></code></pre></div></div>

<p>Também seria possível utilizar o <code class="language-plaintext highlighter-rouge">telnet</code> para analisar várias portas, dentre outros softwares.</p>

<h2 id="criando-container-sem-interface-de-rede">Criando container sem interface de rede</h2>

<p>Pode haver algum caso, que por motivos de segurança (por exemplo), não seja recomendável que um container esteja conectado aos outros containers, nem ao <em>host</em> hospedeiro via rede. Se esse for o caso, é possível iniciar um container sem placa de rede, com a opção <code class="language-plaintext highlighter-rouge">--net=none</code>.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> server3 <span class="nt">--net</span><span class="o">=</span>none <span class="nt">-d</span> servidor/http
<span class="go">d94ab3172c6203dd62a50badda25b6332dcb62aee1c19632bd4d6296cbf34d0c
</span><span class="c">...
</span><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server3 bash
<span class="c">...
</span><span class="gp">[root@d94ab3172c62 /]#</span><span class="w"> </span>ifconfig
<span class="gp">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;</span><span class="w">  </span>mtu 65536
<span class="go">        inet 127.0.0.1  netmask 255.0.0.0
</span><span class="gp">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><span class="w">
</span><span class="go">        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span></code></pre></div></div>

<p>Tal container só tem a interface de rede de <em>loopback</em> para comunicação inter-processos.</p>

<h2 id="configurando-container-para-acessar-o-mesmo-espaço-de-rede-do-host">Configurando container para acessar o mesmo espaço de rede do <em>host</em></h2>

<p>A opção <code class="language-plaintext highlighter-rouge">--net=host</code> criará um container que compartilhará as mesmas placas de rede e configuração de rede do <em>host</em> hospedeiro. Veja o exemplo a seguir:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[luiz@fielDell env]$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> server4 <span class="nt">--net</span><span class="o">=</span>host <span class="nt">-d</span> servidor/http
<span class="go">d6785b003d38b389fc37ed4da5794c49c46308c8bd4284202bf37a94b42d1e45
</span><span class="gp">[luiz@fielDell env]$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server4 bash
<span class="gp">[root@fielDell /]#</span><span class="w"> </span>ifconfig
<span class="gp">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
</span><span class="gp">        inet6 fe80::42:adff:fe35:6161  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 02:42:ad:35:61:61  txqueuelen 0  (Ethernet)
        RX packets 6195  bytes 490719 (479.2 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 9141  bytes 11515305 (10.9 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">veth2252825: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="gp">        inet6 fe80::2cd3:1fff:fe81:c076  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 2e:d3:1f:81:c0:76  txqueuelen 0  (Ethernet)
        RX packets 314  bytes 67348 (65.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1429  bytes 307567 (300.3 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">vetha7892f9: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="gp">        inet6 fe80::78b1:b0ff:fe8d:906e  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 7a:b1:b0:8d:90:6e  txqueuelen 0  (Ethernet)
        RX packets 947  bytes 108441 (105.8 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1884  bytes 3250862 (3.1 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">wlp3s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 192.168.1.39  netmask 255.255.255.0  broadcast 192.168.1.255
</span><span class="gp">        inet6 fd1b:e114:982d:0:178e:95e1:9108:a880  prefixlen 64  scopeid 0x0&lt;global&gt;</span><span class="w">
</span><span class="gp">        inet6 fe80::5b45:9e7d:f26a:f155  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="gp">        inet6 fd1b:e114:982d::bd6  prefixlen 128  scopeid 0x0&lt;global&gt;</span><span class="w">
</span><span class="go">        ether 60:57:18:f1:b7:01  txqueuelen 1000  (Ethernet)
        RX packets 1295958  bytes 1217138862 (1.1 GiB)
        RX errors 0  dropped 10030  overruns 0  frame 0
        TX packets 738018  bytes 275237945 (262.4 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span></code></pre></div></div>

<p>Essa opção é interessante quando é preciso expor todos os serviços do container para a rede externa. Todavia utilizar o <code class="language-plaintext highlighter-rouge">--net=host</code> é extremamente perigoso, por isso não é aconselhável tal prática.</p>

<h2 id="criando-redes-docker">Criando redes Docker</h2>

<p>Por padrão o Docker tem uma rede e essa vai atender a maioria dos casos. Entretanto podem existir momentos em que é necessário uma nova rede, para por exemplo por motivo de segurança isolar um conjunto de containers de outros, etc.</p>

<p>Para criar uma rede docker, podemos utilizar o <code class="language-plaintext highlighter-rouge">docker network create</code> seguido do nome da nova rede, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker network create redeDocker
<span class="go">fd6c1bc932edcfc648c1fc23fddc6aa119de345832eeeae7675670ba46051d24
</span></code></pre></div></div>

<p>Com o comando anterior, foi criada uma rede chamada <code class="language-plaintext highlighter-rouge">redeDocker</code>. É possível ver mais detalhes dessa rede com o comando a seguir:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker network inspect redeDocker
<span class="go">[
    {
        "Name": "redeDocker",
        "Id": "fd6c1bc932edcfc648c1fc23fddc6aa119de345832 eeeae7675670ba46051d24",
        "Created": "2024-09-19T00:33:00.563334541-03:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
</span></code></pre></div></div>

<p>Na saída anterior, observe que essa rede tem o IP 172.18.0.0/26 e o <em>gateway</em>, que o <em>host</em> hospedeiro, tem o IP 172.18.0.1.
Também é possível ver essa nova rede com o comando <code class="language-plaintext highlighter-rouge">docker network ls</code>, veja a seguir:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker network <span class="nb">ls</span>
<span class="go">NETWORK ID     NAME         DRIVER    SCOPE
a972fdc75f55   bridge       bridge    local
00332d429033   host         host      local
d91b8da1f7fd   none         null      local
fd6c1bc932ed   redeDocker   bridge    local
</span></code></pre></div></div>

<p>Observe que na listagem anterior, temos os seguintes nomes de redes:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">bridge</code></strong>: que é a rede padrão do Docker;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">host</code></strong>: que quando o docker utiliza essa rede, ele na verdade vai utilizar o espaço de rede do <em>host</em> hospedeiro, ou seja, é a rede utilizada pela opção <code class="language-plaintext highlighter-rouge">--net=host</code>;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">none</code></strong>: Utilizado para configurar um container sem rede, tal como já foi feito com a opção <code class="language-plaintext highlighter-rouge">--net=none</code>;</li>
</ul>

<p>::: note
Observe também os <em>drivers</em> da listagem anterior, eles refletem a função de cada rede. Também é possível instalar e utilizar outros <em>drivers</em> e obter redes diferentes, por exemplo.
:::</p>

<p>Com a rede <code class="language-plaintext highlighter-rouge">redeDocker</code>, vamos criar também um container e conectá-lo à essa nova rede, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> server5 <span class="nt">--net</span><span class="o">=</span>redeDocker <span class="nt">-d</span> servidor/http
<span class="go">01f5a381460211fd40121dc166b40e873727c538b6b82a214924c2c60a91fc36
</span></code></pre></div></div>

<p>Com o container criado vamos verificar se ele realmente está na rede 172.18.0.0/16, que foi a faixa de IPs determinada para a rede <code class="language-plaintext highlighter-rouge">redeDocker</code>.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[luiz@fielDell env]$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server5 bash
<span class="gp">[root@01f5a3814602 /]#</span><span class="w"> </span>ifconfig
<span class="gp">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.18.0.2  netmask 255.255.0.0  broadcast 172.18.255.255
        ether 02:42:ac:12:00:02  txqueuelen 0  (Ethernet)
        RX packets 27  bytes 2978 (2.9 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span></code></pre></div></div>

<p>Bem, por padrão uma rede Docker não tem permissão de acessar outra rede Docker, isso é definido via <code class="language-plaintext highlighter-rouge">iptables</code>. Vamos verificar esse comportamento executando um <code class="language-plaintext highlighter-rouge">ping</code> do <code class="language-plaintext highlighter-rouge">server5</code> para o <code class="language-plaintext highlighter-rouge">server1</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[root@01f5a3814602 /]#</span><span class="w"> </span>dnf <span class="nb">install </span>iputils
<span class="c">...
</span><span class="gp">[root@01f5a3814602 /]#</span><span class="w"> </span>ping 172.17.0.2
<span class="go">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
^C
--- 172.17.0.2 ping statistics ---
79 packets transmitted, 0 received, 100% packet loss, time 79037ms
</span></code></pre></div></div>

<p>::: note
Note que foi necessário instalar o <code class="language-plaintext highlighter-rouge">iputlis</code> para utilizar o comando <code class="language-plaintext highlighter-rouge">ping</code>, através do pacote <code class="language-plaintext highlighter-rouge">iputils</code>.
:::</p>

<p>A saída anterior, mostra que não há conectividade entre o container da rede Docker padrão, com o container da nova rede que acabamos de criar, já que o <code class="language-plaintext highlighter-rouge">ping</code> entre o <code class="language-plaintext highlighter-rouge">server5</code> e o <code class="language-plaintext highlighter-rouge">server1</code> não obteve resposta.</p>

<h3 id="verificando-os-containers-conectados-a-uma-rede-docker">Verificando os containers conectados a uma rede Docker</h3>

<p>Agora que temos, por exemplo, o container <code class="language-plaintext highlighter-rouge">server5</code> conectado à <code class="language-plaintext highlighter-rouge">redeDocker</code>, é possível ver IP e MAC do container relacionado com a sua <em>bridge</em>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker network inspect redeDocker
<span class="go">[
    {
        "Name": "redeDocker",
</span><span class="c">...
</span><span class="go">        "Containers": {
            "01f5a381460211fd40121dc166b40e873727c538b6b82 a214924c2c60a91fc36": {
                "Name": "server5",
                "EndpointID": "bda77742a8425aee8b0d19a13c325 e692100462f73250eba0125364656285779",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]
</span></code></pre></div></div>

<p>Então o comando anterior, pode ser utilizado para descobrir os containers relacionados com cada rede Docker, bem como os IPs desses containers.</p>

<h2 id="conectando-um-container-em-execução-à-uma-rede-docker">Conectando um container em execução à uma rede Docker</h2>

<p>Outra tarefa que pode ser útil, é conectar um container já em execução à outra rede Docker. Por exemplo, vamos conectar o <code class="language-plaintext highlighter-rouge">server2</code>, que está na rede padrão Docker à <code class="language-plaintext highlighter-rouge">redeDocker</code>, que criamos anteriormente. Para isso basta executar o seguinte comando:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker network connect redeDocker server2
</code></pre></div></div>

<p>Agora vamos verificar se esse container está na rede <code class="language-plaintext highlighter-rouge">redeDocker</code>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server2 bash
<span class="go">
</span><span class="gp">[root@05eaec227a5f /]#</span><span class="w"> </span>ifconfig
<span class="gp">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)
        RX packets 2024  bytes 3281494 (3.1 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 947  bytes 108441 (105.8 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.18.0.3  netmask 255.255.0.0  broadcast 172.18.255.255
        ether 02:42:ac:12:00:03  txqueuelen 0  (Ethernet)
        RX packets 19  bytes 2042 (1.9 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span><span class="c">...
</span></code></pre></div></div>

<p>A saída anterior, mostra que o <code class="language-plaintext highlighter-rouge">server5</code> agora está conectado à rede <code class="language-plaintext highlighter-rouge">redeDocker</code> pela interface <code class="language-plaintext highlighter-rouge">eth1</code>, bem como continua conectado à rede padrão do Docker, pela interface <code class="language-plaintext highlighter-rouge">eth0</code>. Note que isso abre várias possibilidades, tal como um container que pode prover serviço para mais que uma rede Docker.</p>

<h1 id="conclusão">Conclusão</h1>

<h1 id="bibliografia">Bibliografia</h1>

<p>TURBULL, James. <strong>The Docker Book: Containerization is the New Virtualization</strong>. [s.l.]: James Turnbull, 2014.</p>
