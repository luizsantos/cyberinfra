<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>CyberInfra</title>

  <link rel="stylesheet" href="/css/main.css">
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>CyberInfra | Sistemas Operacionais, Redes de Computadores, Cibersegurança…</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="CyberInfra" />
<meta name="author" content="Luiz Arthur Feitosa dos Santos" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Sistemas Operacionais, Redes de Computadores, Cibersegurança…" />
<meta property="og:description" content="Sistemas Operacionais, Redes de Computadores, Cibersegurança…" />
<link rel="canonical" href="http://localhost:4000/docs/docker/docker-rede" />
<meta property="og:url" content="http://localhost:4000/docs/docker/docker-rede" />
<meta property="og:site_name" content="CyberInfra" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="CyberInfra" />
<script type="application/ld+json">
{"@type":"WebPage","author":{"@type":"Person","name":"Luiz Arthur Feitosa dos Santos"},"description":"Sistemas Operacionais, Redes de Computadores, Cibersegurança…","headline":"CyberInfra","url":"http://localhost:4000/docs/docker/docker-rede","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WJPJ7DKEWG"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WJPJ7DKEWG');
</script>

  
<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>luiz@CyberInfra:~#</h1>
    </a>
    <h3>Sistemas Operacionais, Redes de Computadores, Cibersegurança...</h3>
    <div class="header-links">
      <a href="/docs"><h2 class="header-link">Documentos</h2></a>
<a href="/videos"><h2 class="header-link">Videos</h2></a>
<a href="/archive"><h2 class="header-link">Postagens</h2></a>
<a href="/about"><h2 class="header-link">Sobre</h2></a>
<!-- <a href="/atom.xml"><h2 class="header-link">RSS</h2></a> -->

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <h2></h2>
  <time datetime="" class="by-line"></time>
  <h1 id="rede-docker">Rede Docker</h1>

<p>O modelo de rede utilizado pelo Docker parece inicialmente mágica, pois
é só ligar um container, que este vai estar conectado à rede e
provavelmente à Internet.</p>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    <p>A rede padrão Docker vai dar acesso à qualquer rede que o
<em>host</em> hospedeiro estiver conectado, inclusive à Internet.
Todavia, é importante perceber que o container não vai acessar, por
exemplo a Internet, se o <em>host</em> hospedeiro não tiver acesso a
mesma.</p></div></div>

<p>No geral, a maioria das pessoas não vão precisar alterar as
configurações padrão das redes Docker, mas para o administrador é bom
saber como funciona a rede Docker, pois existem casos em que será
necessário alterar tal rede para atender os requisitos do cliente.</p>

<p>Normalmente a rede Docker funciona através de uma placa rede virtual no
modo <em>bridge</em> (Linux network <em>bridge</em>), tal placa virtual é geralmente
identificada no <em>host</em> hospedeiro como sendo a placa de rede chamada de
<code class="language-plaintext highlighter-rouge">docker0</code>. Tal placa de rede normalmente estará provavelmente com uma
faixa de rede como: 172.17.0.0/16, ou alguma rede privada similar. A
Figura 12 mostra mais ou menos como é a arquitetura de uma rede Docker.</p>

<p><img src="imagens/redeDockerArquitetura.svg" alt="Figura 12: Arquitetura da rede
Docker" /></p>

<p>Analisando a Figura 12, observe que o <em>host</em> hospedeiro possui uma placa
de rede que lhe conecta ao mundo externo, neste caso ela é representada
pelo <code class="language-plaintext highlighter-rouge">eth0</code> com o IP 200.0.0.1, mas poderiam haver mais placas de redes
no hospedeiro. Interligada à essa placa de rede física, temos a <em>bridge</em>
Docker, chamada de <code class="language-plaintext highlighter-rouge">docker0</code>. Tal <em>bridge</em> está conectada às placas de
rede Ethernets virtuais, chamadas de <code class="language-plaintext highlighter-rouge">veth</code>, que por sua vez estão
ligadas às placas de redes <code class="language-plaintext highlighter-rouge">eth0</code>, que estão dentro do container. No
cenário da Figura 12, a rede Docker tem o IP de rede 172.17.0.0/16,
dentro dessa faixa, cada placa de rede do container receberá um IP, tal
como: <code class="language-plaintext highlighter-rouge">docker0</code> - 172.17.0.1, <code class="language-plaintext highlighter-rouge">eth0</code> do container A 172.17.0.2, <code class="language-plaintext highlighter-rouge">eth0</code>
do container B 172.17.0.3.</p>

<p>Para entender melhor tal estrutura vamos ver a saída do comando
<code class="language-plaintext highlighter-rouge">ifconfig</code> do <em>host</em> hospedeiro:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>ifconfig
<span class="c">...
</span><span class="gp">wlp3s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 192.168.1.39  netmask 255.255.255.0  broadcast 192.168.1.255
</span><span class="gp">        inet6 fd1b:e114:982d:0:178e:95e1:9108:a880  prefixlen 64  scopeid 0x0&lt;global&gt;</span><span class="w">
</span><span class="gp">        inet6 fe80::5b45:9e7d:f26a:f155  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="gp">        inet6 fd1b:e114:982d::bd6  prefixlen 128  scopeid 0x0&lt;global&gt;</span><span class="w">
</span><span class="go">        ether 60:57:18:f1:b7:01  txqueuelen 1000  (Ethernet)
        RX packets 1079884  bytes 968144506 (923.2 MiB)
        RX errors 0  dropped 9443  overruns 0  frame 0
        TX packets 649598  bytes 243084853 (231.8 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
</span><span class="gp">        inet6 fe80::42:adff:fe35:6161  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 02:42:ad:35:61:61  txqueuelen 0  (Ethernet)
        RX packets 6195  bytes 490719 (479.2 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 9009  bytes 11484489 (10.9 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">veth2252825: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="gp">        inet6 fe80::2cd3:1fff:fe81:c076  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 2e:d3:1f:81:c0:76  txqueuelen 0  (Ethernet)
        RX packets 314  bytes 67348 (65.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1297  bytes 276751 (270.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">vetha7892f9: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="gp">        inet6 fe80::78b1:b0ff:fe8d:906e  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 7a:b1:b0:8d:90:6e  txqueuelen 0  (Ethernet)
        RX packets 947  bytes 108441 (105.8 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1752  bytes 3220046 (3.0 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span></code></pre></div></div>

<p>Na saída do <em>host</em> anterior, no lugar da <code class="language-plaintext highlighter-rouge">eth0</code> temos a <code class="language-plaintext highlighter-rouge">wlp3s0</code>, que é
a placa física que dá acesso a outras redes, tai como a Internet. A
placa de rede <code class="language-plaintext highlighter-rouge">docker0</code> com o IP 172.17.0.1, que simboliza a <em>bridge</em>
Docker. Também temos duas placas <code class="language-plaintext highlighter-rouge">veth</code>, que são: <code class="language-plaintext highlighter-rouge">veth2252825</code> e
<code class="language-plaintext highlighter-rouge">vetha7892f9</code>, tais placas não possuem IPs, pois os IPs são atribuídos
às placas de rede que estão dentro do container (neste caso temos dois
containers em execução), similar à Figura 12.</p>

<p>As placas de rede <code class="language-plaintext highlighter-rouge">veth</code> e sua relação com a <code class="language-plaintext highlighter-rouge">docker0</code> podem ser melhor
vistas com o comando <code class="language-plaintext highlighter-rouge">brctl</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>brctl show
<span class="go">bridge name  bridge id          STP enabled  interfaces
docker0      8000.0242ad356161  no           veth2252825
                                             vetha7892f9
</span></code></pre></div></div>

<p>Assim, quando um container é criando, o Docker cria uma placa <code class="language-plaintext highlighter-rouge">veth</code> e
relaciona essa com a <code class="language-plaintext highlighter-rouge">docker0</code>, feito isso é dado ao container um IP
dentro da faixa de rede utilizada pela rede Docker, bem como é inserido
no container o IP do <em>gateway</em> padrão e do servidor DNS. Ao fim, o
container terá capacidade de acessar outras redes - é claro se o <em>host</em>
hospedeiro tiver acesso a outras redes, tal como a Internet.</p>

<p>É importante saber, que para um container acessar outras redes, o <em>host</em>
hospedeiro deve funcionar como um roteador, ou seja o arquivo
<code class="language-plaintext highlighter-rouge">/proc/sys/net/ipv4/ip_forward</code> deve estar com o conteúdo 1. Também, o
<em>host</em> hospedeiro utilizará o <code class="language-plaintext highlighter-rouge">iptables</code> para realizar um NAT dos
pacotes que forem roteados para fora da rede Docker. Essas duas
configurações normalmente serão feitas automaticamente pelo <em>host</em>
Docker.</p>

<p>Por padrão, todo container pode se comunicar com outro container, mas
isso pode ser alterado na inicialização do Docker, configurando a opção
<code class="language-plaintext highlighter-rouge">--icc</code> em como falso, tal como: <code class="language-plaintext highlighter-rouge">--icc=false</code>.</p>

<p>Agora que conhecemos um pouco mais a respeito de como funciona a rede
Docker, a seguir serão apresentadas algumas características extras da
configuração de rede no Docker.</p>

<h2 id="descobrindo-os-ips-rotas-e-dns-dos-containers">Descobrindo os IPs, rotas e DNS dos containers</h2>

<p>Há várias formas de descobrir IPs de containers, algumas dessas são
apresentadas nas subseções a seguir.</p>

<h3 id="utilizando-o-inspect">Utilizando o <code class="language-plaintext highlighter-rouge">inspect</code></h3>

<p>Com o <code class="language-plaintext highlighter-rouge">inspect</code> do Docker é possível procurar no JSON pelas
configurações de redes e chegar no IP, tal como:</p>

<p><code class="language-plaintext highlighter-rouge">$ docker inspect --format '' server1 172.17.0.2</code></p>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    <p>Estamos utilizando os containers criados na seção anterior.</p></div></div>

<h3 id="utilizando-o-exec">Utilizando o <code class="language-plaintext highlighter-rouge">exec</code></h3>

<p>Utilizando o <code class="language-plaintext highlighter-rouge">exec</code> seguido de algum comando Linux (o comando deve estar
presente no container), tal como:</p>

<ul>
  <li>Verificando o arquivo <code class="language-plaintext highlighter-rouge">/etc/hosts</code>:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server1 <span class="nb">cat</span> /etc/hosts
<span class="go">127.0.0.1   localhost
</span><span class="c">...
</span><span class="go">172.17.0.2  dd0de51f4289
</span></code></pre></div></div>

<ul>
  <li>Utilizando comandos do container para ver IP, tal como <code class="language-plaintext highlighter-rouge">ip</code> e
<code class="language-plaintext highlighter-rouge">ifconfig</code>:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server1 ip addres
</code></pre></div></div>

<ul>
  <li>Executando um terminal e executando comandos diretamente no
container:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server1 bash
<span class="gp">[root@dd0de51f4289 /]#</span>ifconfig
<span class="gp">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)
        RX packets 271  bytes 53964 (52.6 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;</span><span class="w">  </span>mtu 65536
<span class="go">        inet 127.0.0.1  netmask 255.0.0.0
</span><span class="gp">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><span class="w">
</span><span class="go">        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span></code></pre></div></div>

<p>Para descobrir as rotas utilizadas pelo container, é possível executar
via <code class="language-plaintext highlighter-rouge">exec</code> o comando <code class="language-plaintext highlighter-rouge">route</code> ou <code class="language-plaintext highlighter-rouge">ip route</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec </span>server1 route <span class="nt">-n</span>
<span class="go">Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0
</span></code></pre></div></div>

<p>Já para identificar a configuração de servidor DNS utilizado pelo
container, também é possível realizar um <code class="language-plaintext highlighter-rouge">exec</code>, só que executando um
<code class="language-plaintext highlighter-rouge">cat /etc/resolv.conf</code>, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec </span>server1 <span class="nb">cat</span> /etc/resolv.conf
<span class="go">nameserver 192.168.1.1
</span></code></pre></div></div>

<h3 id="utilizando-o-nsenter">Utilizando o <code class="language-plaintext highlighter-rouge">nsenter</code></h3>

<p>Outra ferramenta bem útil para ver IPs dos containers, bem como realizar
interações em containers é o <code class="language-plaintext highlighter-rouge">nsenter</code>, na verdade á mais recomendável
utilizar ela do que o <code class="language-plaintext highlighter-rouge">exec</code>. Veja a seguir como utilizar o <code class="language-plaintext highlighter-rouge">nsenter</code>
para ver as informações de rede do container. Neste caso primeiro é
necessário encontrar o PID do processo, isso pode ser feito da seguinte
forma:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect <span class="nt">-f</span> <span class="s1">''</span> server1
<span class="go">18522
</span></code></pre></div></div>

<p>No caso o valor retornado foi <code class="language-plaintext highlighter-rouge">18522</code>, agora podemos utilizar esse PID
com o <code class="language-plaintext highlighter-rouge">nsenter</code> e verificar/alterar informações a respeito do
<em>namespace</em> utilizado pelo container, tal como ver a configuração de
rede:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>nsenter <span class="nt">-t</span> 18522 <span class="nt">--net</span> ip address
<span class="gp">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt;</span><span class="w"> </span>mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
<span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host proto kernel_lo
       valid_lft forever preferred_lft forever
</span><span class="gp">76: eth0@if77: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span><span class="w"> </span>mtu 1500 qdisc noqueue state UP group default
<span class="go">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</span></code></pre></div></div>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    </div></div>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/important.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
    <div>
    <p>O <code>nsenter</code> permite executar comando que estão no
<em>host</em> hospedeiro e não estão no container. Por exemplo, o
comando <code>ip</code> não está instalado no container, mas está
instalado no <em>host</em> hospedeiro, então esse será executado do
hospedeiro no <em>namespace</em> do container, e por isso o comando
funcionará. Por isso, é bem interessante que o administrador pesquise e
saiba como utilizar o <code>nsenter</code>.</p></div></div>

<h2 id="descobrindo-portas-publicadas-ou-abertas-nos-containers">Descobrindo portas publicadas ou abertas nos containers</h2>

<p>A Seção 4.4 já apresentou como mostrar portas disponíveis em container,
mas aqui são apresentadas mais algumas:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">docker ps</code>:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker ps
<span class="go">CONTAINER ID   IMAGE           COMMAND                  CREATED        STATUS        PORTS                                   NAMES
</span><span class="gp">dd0de51f4289   servidor/http   "/sbin/startServer.sh"   12 hours ago   Up 12 hours   0.0.0.0:82-&gt;</span>8080/tcp, :::82-&gt;8080/tcp   server1
</code></pre></div></div>

<ul>
  <li>Executando <code class="language-plaintext highlighter-rouge">iptables</code> no <em>host</em> hospedeiro:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>iptables <span class="nt">-L</span> <span class="nt">-n</span> <span class="nt">-t</span> nat
<span class="c">...
</span><span class="go">Chain DOCKER (2 references)
target     prot opt source               destination
RETURN     0    --  0.0.0.0/0            0.0.0.0/0
DNAT       6    --  0.0.0.0/0            0.0.0.0/0            tcp dpt:82 to:172.17.0.2:8080
</span></code></pre></div></div>

<ul>
  <li>Procurando com o comando <code class="language-plaintext highlighter-rouge">ps</code> no <em>host</em> hospedeiro:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>ps <span class="nt">-ef</span> | <span class="nb">grep </span>docker-proxy
<span class="go">root       18474     773  0 Sep17 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 82 -container-ip 172.17.0.2 -container-port 8080
root       18481     773  0 Sep17 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 82 -container-ip 172.17.0.2 -container-port 8080
luiz       20905    5325  0 11:25 pts/1    00:00:00 grep docker-proxy
</span></code></pre></div></div>

<ul>
  <li>Inspecionando:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker inspect <span class="nt">--format</span> <span class="s1">''</span> server1
<span class="go">map[8080/tcp:[{ 82}]]
</span></code></pre></div></div>

<ul>
  <li>Verificando os serviços de rede disponíveis no container com o
<code class="language-plaintext highlighter-rouge">netstat</code> ou <code class="language-plaintext highlighter-rouge">ss</code>:</li>
</ul>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec </span>server1 netstat <span class="nt">-a</span> <span class="nt">--tcp</span> <span class="nt">-np</span>
<span class="go">Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      8/httpd
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      9/sshd: /sbin/sshd
tcp6       0      0 :::22                   :::*                    LISTEN      9/sshd: /sbin/sshd
</span></code></pre></div></div>

<h2 id="testando-a-conectividade-entre-containers">Testando a conectividade entre containers</h2>

<p>Há várias formas para se testar a conectividade. Po exemplo, dá para
utilizar o <code class="language-plaintext highlighter-rouge">exec</code> para executar comandos como o <code class="language-plaintext highlighter-rouge">ping</code>, mas a seguir
vamos executar um <code class="language-plaintext highlighter-rouge">bash</code>, instalar o <code class="language-plaintext highlighter-rouge">ping</code> e realizar o teste de dentro
do container:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[luiz@fielDell env]$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server2 bash
<span class="c">...
</span><span class="gp">[root@05eaec227a5f /]#</span><span class="w"> </span>dnf <span class="nb">install </span>iputils
<span class="c">...
</span><span class="go">Installed:
  iputils-20240117-4.fc40.x86_64

Complete!
</span><span class="c">...
</span><span class="gp">[root@05eaec227a5f /]#</span><span class="w"> </span>ping 172.17.0.2
<span class="go">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.070 ms
64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.071 ms
64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.061 ms
64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.106 ms
64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.056 ms
</span></code></pre></div></div>

<p>Também seria possível utilizar o <code class="language-plaintext highlighter-rouge">telnet</code> para analisar várias portas,
dentre outros softwares.</p>

<h2 id="criando-container-sem-interface-de-rede">Criando container sem interface de rede</h2>

<p>Pode haver algum caso, que por motivos de segurança (por exemplo), não
seja recomendável que um container esteja conectado aos outros
containers, nem ao <em>host</em> hospedeiro via rede. Se esse for o caso, é
possível iniciar um container sem placa de rede, com a opção
<code class="language-plaintext highlighter-rouge">--net=none</code>.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> server3 <span class="nt">--net</span><span class="o">=</span>none <span class="nt">-d</span> servidor/http
<span class="go">d94ab3172c6203dd62a50badda25b6332dcb62aee1c19632bd4d6296cbf34d0c
</span><span class="c">...
</span><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server3 bash
<span class="c">...
</span><span class="gp">[root@d94ab3172c62 /]#</span><span class="w"> </span>ifconfig
<span class="gp">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;</span><span class="w">  </span>mtu 65536
<span class="go">        inet 127.0.0.1  netmask 255.0.0.0
</span><span class="gp">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><span class="w">
</span><span class="go">        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span></code></pre></div></div>

<p>Tal container só tem a interface de rede de <em>loopback</em> para comunicação
inter-processos.</p>

<h2 id="configurando-container-para-acessar-o-mesmo-espaço-de-rede-do-host">Configurando container para acessar o mesmo espaço de rede do <em>host</em></h2>

<p>A opção <code class="language-plaintext highlighter-rouge">--net=host</code> criará um container que compartilhará as mesmas
placas de rede e configuração de rede do <em>host</em> hospedeiro. Veja o
exemplo a seguir:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[luiz@fielDell env]$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> server4 <span class="nt">--net</span><span class="o">=</span>host <span class="nt">-d</span> servidor/http
<span class="go">d6785b003d38b389fc37ed4da5794c49c46308c8bd4284202bf37a94b42d1e45
</span><span class="gp">[luiz@fielDell env]$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server4 bash
<span class="gp">[root@fielDell /]#</span><span class="w"> </span>ifconfig
<span class="gp">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
</span><span class="gp">        inet6 fe80::42:adff:fe35:6161  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 02:42:ad:35:61:61  txqueuelen 0  (Ethernet)
        RX packets 6195  bytes 490719 (479.2 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 9141  bytes 11515305 (10.9 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">veth2252825: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="gp">        inet6 fe80::2cd3:1fff:fe81:c076  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 2e:d3:1f:81:c0:76  txqueuelen 0  (Ethernet)
        RX packets 314  bytes 67348 (65.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1429  bytes 307567 (300.3 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">vetha7892f9: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="gp">        inet6 fe80::78b1:b0ff:fe8d:906e  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="go">        ether 7a:b1:b0:8d:90:6e  txqueuelen 0  (Ethernet)
        RX packets 947  bytes 108441 (105.8 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1884  bytes 3250862 (3.1 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">wlp3s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 192.168.1.39  netmask 255.255.255.0  broadcast 192.168.1.255
</span><span class="gp">        inet6 fd1b:e114:982d:0:178e:95e1:9108:a880  prefixlen 64  scopeid 0x0&lt;global&gt;</span><span class="w">
</span><span class="gp">        inet6 fe80::5b45:9e7d:f26a:f155  prefixlen 64  scopeid 0x20&lt;link&gt;</span><span class="w">
</span><span class="gp">        inet6 fd1b:e114:982d::bd6  prefixlen 128  scopeid 0x0&lt;global&gt;</span><span class="w">
</span><span class="go">        ether 60:57:18:f1:b7:01  txqueuelen 1000  (Ethernet)
        RX packets 1295958  bytes 1217138862 (1.1 GiB)
        RX errors 0  dropped 10030  overruns 0  frame 0
        TX packets 738018  bytes 275237945 (262.4 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span></code></pre></div></div>

<p>Essa opção é interessante quando é preciso expor todos os serviços do
container para a rede externa. Todavia utilizar o <code class="language-plaintext highlighter-rouge">--net=host</code> é
extremamente perigoso, por isso não é aconselhável tal prática.</p>

<h2 id="criando-redes-docker">Criando redes Docker</h2>

<p>Por padrão o Docker tem uma rede e essa vai atender a maioria dos casos.
Entretanto podem existir momentos em que é necessário uma nova rede,
para por exemplo por motivo de segurança isolar um conjunto de
containers de outros, etc.</p>

<p>Para criar uma rede docker, podemos utilizar o <code class="language-plaintext highlighter-rouge">docker network create</code>
seguido do nome da nova rede, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker network create redeDocker
<span class="go">fd6c1bc932edcfc648c1fc23fddc6aa119de345832eeeae7675670ba46051d24
</span></code></pre></div></div>

<p>Com o comando anterior, foi criada uma rede chamada <code class="language-plaintext highlighter-rouge">redeDocker</code>. É
possível ver mais detalhes dessa rede com o comando a seguir:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker network inspect redeDocker
<span class="go">[
    {
        "Name": "redeDocker",
        "Id": "fd6c1bc932edcfc648c1fc23fddc6aa119de345832 eeeae7675670ba46051d24",
        "Created": "2024-09-19T00:33:00.563334541-03:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
</span></code></pre></div></div>

<p>Na saída anterior, observe que essa rede tem o IP 172.18.0.0/26 e o
<em>gateway</em>, que o <em>host</em> hospedeiro, tem o IP 172.18.0.1. Também é
possível ver essa nova rede com o comando <code class="language-plaintext highlighter-rouge">docker network ls</code>, veja a
seguir:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker network <span class="nb">ls</span>
<span class="go">NETWORK ID     NAME         DRIVER    SCOPE
a972fdc75f55   bridge       bridge    local
00332d429033   host         host      local
d91b8da1f7fd   none         null      local
fd6c1bc932ed   redeDocker   bridge    local
</span></code></pre></div></div>

<p>Observe que na listagem anterior, temos os seguintes nomes de redes:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">bridge</code></strong>: que é a rede padrão do Docker;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">host</code></strong>: que quando o docker utiliza essa rede, ele na verdade
vai utilizar o espaço de rede do <em>host</em> hospedeiro, ou seja, é a
rede utilizada pela opção <code class="language-plaintext highlighter-rouge">--net=host</code>;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">none</code></strong>: Utilizado para configurar um container sem rede, tal
como já foi feito com a opção <code class="language-plaintext highlighter-rouge">--net=none</code>;</li>
</ul>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    <p>Observe também os <em>drivers</em> da listagem anterior, eles
refletem a função de cada rede. Também é possível instalar e utilizar
outros <em>drivers</em> e obter redes diferentes, por exemplo.</p></div></div>

<p>Com a rede <code class="language-plaintext highlighter-rouge">redeDocker</code>, vamos criar também um container e conectá-lo à
essa nova rede, tal como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker run <span class="nt">--rm</span> <span class="nt">--name</span> server5 <span class="nt">--net</span><span class="o">=</span>redeDocker <span class="nt">-d</span> servidor/http
<span class="go">01f5a381460211fd40121dc166b40e873727c538b6b82a214924c2c60a91fc36
</span></code></pre></div></div>

<p>Com o container criado vamos verificar se ele realmente está na rede
172.18.0.0/16, que foi a faixa de IPs determinada para a rede
<code class="language-plaintext highlighter-rouge">redeDocker</code>.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[luiz@fielDell env]$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server5 bash
<span class="gp">[root@01f5a3814602 /]#</span><span class="w"> </span>ifconfig
<span class="gp">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.18.0.2  netmask 255.255.0.0  broadcast 172.18.255.255
        ether 02:42:ac:12:00:02  txqueuelen 0  (Ethernet)
        RX packets 27  bytes 2978 (2.9 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span></code></pre></div></div>

<p>Bem, por padrão uma rede Docker não tem permissão de acessar outra rede
Docker, isso é definido via <code class="language-plaintext highlighter-rouge">iptables</code>. Vamos verificar esse
comportamento executando um <code class="language-plaintext highlighter-rouge">ping</code> do <code class="language-plaintext highlighter-rouge">server5</code> para o <code class="language-plaintext highlighter-rouge">server1</code>, tal
como:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">[root@01f5a3814602 /]#</span><span class="w"> </span>dnf <span class="nb">install </span>iputils
<span class="c">...
</span><span class="gp">[root@01f5a3814602 /]#</span><span class="w"> </span>ping 172.17.0.2
<span class="go">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
^C
--- 172.17.0.2 ping statistics ---
79 packets transmitted, 0 received, 100% packet loss, time 79037ms
</span></code></pre></div></div>

<div style="display: flex; align-items: center; border: 1px solid black; padding: 10px; border-radius: 5px; background-color: #333333; color: white; gap: 15px;"><div style="flex-shrink: 0;"><img src="/cyberinfra/img/note.svg" alt="Atenção" style="width: 50px; height: 50px;" /></div>
 <div>
    <p>Note que foi necessário instalar o <code>iputlis</code> para utilizar
o comando <code>ping</code>, através do pacote <code>iputils</code>.</p></div></div>

<p>A saída anterior, mostra que não há conectividade entre o container da
rede Docker padrão, com o container da nova rede que acabamos de criar,
já que o <code class="language-plaintext highlighter-rouge">ping</code> entre o <code class="language-plaintext highlighter-rouge">server5</code> e o <code class="language-plaintext highlighter-rouge">server1</code> não obteve resposta.</p>

<h3 id="verificando-os-containers-conectados-a-uma-rede-docker">Verificando os containers conectados a uma rede Docker</h3>

<p>Agora que temos, por exemplo, o container <code class="language-plaintext highlighter-rouge">server5</code> conectado à
<code class="language-plaintext highlighter-rouge">redeDocker</code>, é possível ver IP e MAC do container relacionado com a sua
<em>bridge</em>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker network inspect redeDocker
<span class="go">[
    {
        "Name": "redeDocker",
</span><span class="c">...
</span><span class="go">        "Containers": {
            "01f5a381460211fd40121dc166b40e873727c538b6b82 a214924c2c60a91fc36": {
                "Name": "server5",
                "EndpointID": "bda77742a8425aee8b0d19a13c325 e692100462f73250eba0125364656285779",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]
</span></code></pre></div></div>

<p>Então o comando anterior, pode ser utilizado para descobrir os
containers relacionados com cada rede Docker, bem como os IPs desses
containers.</p>

<h2 id="conectando-um-container-em-execução-à-uma-rede-docker">Conectando um container em execução à uma rede Docker</h2>

<p>Outra tarefa que pode ser útil, é conectar um container já em execução à
outra rede Docker. Por exemplo, vamos conectar o <code class="language-plaintext highlighter-rouge">server2</code>, que está na
rede padrão Docker à <code class="language-plaintext highlighter-rouge">redeDocker</code>, que criamos anteriormente. Para isso
basta executar o seguinte comando:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker network connect redeDocker server2
</code></pre></div></div>

<p>Agora vamos verificar se esse container está na rede <code class="language-plaintext highlighter-rouge">redeDocker</code>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>docker <span class="nb">exec</span> <span class="nt">-ti</span> server2 bash
<span class="go">
</span><span class="gp">[root@05eaec227a5f /]#</span><span class="w"> </span>ifconfig
<span class="gp">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)
        RX packets 2024  bytes 3281494 (3.1 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 947  bytes 108441 (105.8 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</span><span class="gp">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><span class="w">  </span>mtu 1500
<span class="go">        inet 172.18.0.3  netmask 255.255.0.0  broadcast 172.18.255.255
        ether 02:42:ac:12:00:03  txqueuelen 0  (Ethernet)
        RX packets 19  bytes 2042 (1.9 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</span><span class="c">...
</span></code></pre></div></div>

<p>A saída anterior, mostra que o <code class="language-plaintext highlighter-rouge">server5</code> agora está conectado à rede
<code class="language-plaintext highlighter-rouge">redeDocker</code> pela interface <code class="language-plaintext highlighter-rouge">eth1</code>, bem como continua conectado à rede
padrão do Docker, pela interface <code class="language-plaintext highlighter-rouge">eth0</code>. Note que isso abre várias
possibilidades, tal como um container que pode prover serviço para mais
que uma rede Docker.</p>

<h1 id="bibliografia">Bibliografia</h1>

<p>TURBULL, James. <strong>The Docker Book: Containerization is the New
Virtualization</strong>. [s.l.]: James Turnbull, 2014.</p>

</article>
      </section>
    </div>
  </div>

   <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
        <b>Luiz Arthur Feitosa dos Santos</b>
    </span>
    
    <span>© 2024</span>
  </a>
</footer>


</body>

</html>
