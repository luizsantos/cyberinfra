<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Prof. Dr. Luiz Arthur Feitosa dos Santos">
  <title>QoS - Quality of Service</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
<link href='https://fonts.googleapis.com/css?family=Oswald' rel='stylesheet'>

<style>
  html, .view body { background-color: black; counter-reset: slideidx; }
  body, .view section { background-color: white; border-radius: 12px }
  /* A section is a slide. It's size is 800x600, and this will never change */
  section, .view head > title {
      /* The font from Google */
      font-family: 'Oswald', arial, serif;
      font-size: 30px;
  }

  .view section:after {
    counter-increment: slideidx;
    content: counter(slideidx, decimal-leading-zero);
    position: absolute; bottom: -80px; right: 100px;
    color: white;
  }

  .view head > title {
    color: white;
    text-align: center;
    margin: 1em 0 1em 0;
  }

  h1, h2 {
    margin-top: 200px;
    text-align: center;
    font-size: 80px;
  }
  h3 {
    margin: 100px 0 50px 100px;
  }

  ul {
      margin: 50px 200px;
  }
  li > ul {
      margin: 15px 50px;
  }

  p {
    margin: 75px;
    font-size: 50px;
  }

  blockquote {
    height: 100%;
    background-color: black;
    color: white;
    font-size: 60px;
    padding: 50px;
  }
  blockquote:before {
    content: open-quote;
  }
  blockquote:after {
    content: close-quote;
  }

  /* Figures are displayed full-page, with the caption
     on top of the image/video */
  figure {
    background-color: black;
    width: 100%;
    height: 100%;
  }
  figure > * {
    position: absolute;
  }
  figure > img, figure > video {
    width: 100%; height: 100%;
  }
  figcaption {
    margin: 70px;
    font-size: 50px;
  }

  footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    padding: 40px;
    text-align: right;
    background-color: #F3F4F8;
    border-top: 1px solid #CCC;
  }

  /* Transition effect */
  /* Feel free to change the transition effect for original
     animations. See here:
     https://developer.mozilla.org/en/CSS/CSS_transitions
     How to use CSS3 Transitions: */
  section {
    -moz-transition: left 400ms linear 0s;
    -webkit-transition: left 400ms linear 0s;
    -ms-transition: left 400ms linear 0s;
    transition: left 400ms linear 0s;
  }
  .view section {
    -moz-transition: none;
    -webkit-transition: none;
    -ms-transition: none;
    transition: none;
  }

  .view section[aria-selected] {
    border: 5px red solid;
  }

  /* Before */
  section { left: -150%; }
  /* Now */
  section[aria-selected] { left: 0; }
  /* After */
  section[aria-selected] ~ section { left: +150%; }

  /* Incremental elements */

  /* By default, visible */
  .incremental > * { opacity: 1; }

  /* The current item */
  .incremental > *[aria-selected] { opacity: 1; }

  /* The items to-be-selected */
  .incremental > *[aria-selected] ~ * { opacity: 0; }

  /* The progressbar, at the bottom of the slides, show the global
     progress of the presentation. */
  #progress-bar {
    height: 2px;
    background: #AAA;
  }
</style>
</head>
<body>
<section class="title">
  <h1 class="title">QoS - Quality of Service</h1>
  <footer>
    <span class="author">Prof. Dr. Luiz Arthur Feitosa dos Santos</span> · 
  </footer>
</section>
<section id="introdução" class="slide level2">
<h2>Introdução</h2>
<p>Qualidade de serviços ou QoS (<em>Quality of Service</em>) normalmente significa melhorar os serviços de rede…. (<strong>terminar</strong>)</p>
<p>QoS é um assunto controverso em redes de computadores. Redes como TCP/IP são comutadas por pacotes, o que torna muito complicado implementar QoS de forma eficiente. Já que um equipamento de rede só sabe “o que é” e “de quem é” um pacote, quando esse já for processado pelo mesmo, ou seja, quando já consumiu recursos (largura de banda, memória e processamento) para tratá-lo.</p>
<p>A ideia principal, normalmente, é dar mais prioridade para pacotes de rede relacionados com serviços essenciais para empresas (VoIP, HTTP, SSH, etc) e reduzir o uso da rede por parte de <em>hosts</em> ou serviços que atrapalhem o bom andamento da rede (Torrent, Serviços de <em>streaming</em>, etc). É claro que determinar o que é bom ou ruim depende de cada caso/empresa/rede e isso também dificulta a implementação de QoS.</p>
</section>
<section id="modelagem-de-tráfego-no-openbsd" class="slide level2">
<h2>Modelagem de tráfego no OpenBSD</h2>
<p>O <a href="https://www.openbsd.org/">OpenBSD</a> possui um <em>firewall</em> chamado <a href="https://www.openbsd.org/faq/pf/">PF</a>, que implementa facilmente modelagem de tráfego de rede (<strong><em>traffic shaping</em></strong>), aqui chamaremos isso também de: <strong>controle de tráfego de rede</strong> ou <strong>controle de banda</strong>. O controle de banda é feito através de <strong>filas (<em>queue</em>)</strong>. Assim, administradores de redes podem criar esquemas para <strong>reorganizar pacotes de rede por prioridade e/ou controle de largura de banda</strong>, tentando atender de forma mais eficiente os requisitos da rede.</p>
<p>Para que a modelagem de tráfego seja feita no PF, é necessário criar pelo menos uma fila, mas é possível ter várias filas. Na verdade é possível criar um esquema de árvore, com filas <strong>pais (<em>parent</em>)</strong> e filhas (<em>child</em> ou <em>leaf</em>), formando um esquema hierárquico. Cada fila terá configurações próprias (ex. largura de banda) que serão compartilhadas com suas filhas (caso existam).</p>
<blockquote>
<p><strong>Atenção</strong> - Lembrando que redes de computadores já funcionam normalmente utilizando fila (FIFO - <em>Fisrt In First Out</em>), só que é “uma grande fila”, por onde os pacote são enfileirados e enviados. O que está sendo feito aqui é dar a possibilidade de criar/configurar filas que atendem melhor os requisitos de pessoas, serviços, hosts e/ou redes de computadores.</p>
</blockquote>
<p>Para que os pacotes de rede sejam atribuídos as filas criadas, é necessário <strong>criar regras</strong> de firewall (PF), que utilizando atributos dos pacotes (IP, protocolo, porta de rede, etc) os relacionem com as filas criadas. Também é <strong>obrigatório</strong> ter uma fila padrão (<em>default</em>), que será destinada para pacote que não casem com as regras criadas no <em>firewall</em>. Ou seja, destinados à pacotes que não tiverem uma fila especificamente designada. Outra exigência, é que <strong>a fila raiz/principal/pai de todas precisa especificar pelo menos uma interface de rede</strong> e as filas filhas devem especificar seu pai (<em>parent</em>).</p>
<h3 id="criando-filas">Criando filas</h3>
<p>Para criar as filas no PF, basta criar/editar o arquivo <code>/etc/pf.conf</code>, que é o padrão. Neste exemplo iremos utilizar outro nome de arquivo, que será: (<code>/etc/pf-qos.conf</code>).</p>
<p>Exemplo:</p>
<pre class="console"><code>openbsd# vi /etc/pf-qos.conf </code></pre>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource console numberLines"><code class="sourceCode"><a class="sourceLine" id="cb2-1" title="1">queue fila0 on em1  bandwidth 100M  </a>
<a class="sourceLine" id="cb2-2" title="2">queue fila5M parent fila0 bandwidth 5M </a>
<a class="sourceLine" id="cb2-3" title="3">queue fila10M parent fila0 bandwidth 10M default</a>
<a class="sourceLine" id="cb2-4" title="4">queue fila30M parent fila0 bandwidth 30M </a>
<a class="sourceLine" id="cb2-5" title="5">queue controle parent fila0 bandwidth 55M</a></code></pre></div>
<p>No arquivo de exemplo anterior: * A primeira linha do arquivo (<code>queue fila0 on em1 bandwidth 100M</code>), cria a fila raiz, que chamamos aqui de <code>fila0</code>, tal fila está relacionada com a interface de rede <code>em1</code> e define 100Mbps como largura de banda (<code>bandwidth 100M</code>) - <strong>é obrigatório criar uma fila nesses moldes</strong>; * A segunda linha cria a fila chamada <code>fila5M</code>, que é filha da fila <code>fila0</code>. A <code>fila5M</code> como o nome sugere terá 5Mb dos 100Mb da fila pai; * A próxima fila criada é a <code>fila10M</code>. Ela também é filha de <code>fila0</code>, mas tem 10Mb de largura de banda. Principalmente, essa fila foi atribuída como <code>default</code>, ou seja, se não houver nenhuma regra para atribuir pacotes para uma fila específica, tais pacotes serão submetidos a essa fila - <strong>lembrando que é obrigatório criar pelo menos uma fila filha e <code>default</code></strong>; * A <code>fila30M</code>, também é criada como fila filha de <code>fila0</code> e para essa foi dado 30Mb de largura de banda; * Por fim, a fila <code>controle</code> que possui a maior largura de banda entre as filas, que é 55Mb.</p>
<h3 id="aplicando-o-controle-de-banda-no-pf">Aplicando o controle de banda no PF</h3>
<p>Com o arquivo de exemplo anterior pronto, o próximo passo é aplicar as filas no PF. Isso é feito executando seguinte comando:</p>
<pre class="console"><code>openbsd# pfctl -f /etc/pf-qos.conf</code></pre>
<p>Se o arquivo estiver correto nenhuma mensagem será retornada. Caso contrário encontre os erros e corrija o arquivo. Um exemplo de erro seria não ter a interface de rede <code>em1</code> - sua interface pode ter outro nome. Lembrando que é possível ver as interfaces de rede com o comando <code>ifconfig</code>.</p>
<h3 id="testando-o-controle-de-banda">Testando o controle de banda</h3>
<p>Há várias formas de realizar testes com o controle de largura de banda. Aqui iremos utilizar um servidor <a href="https://httpd.apache.org/">HTTP Apache</a>. Assim, basicamente é necessário instalar um servidor HTTP no OpenBSD (onde acabamos de configurar as filas) e depois usar no cliente (outro <em>host</em>) um comando tal como o <a href="https://www.gnu.org/software/wget/">Wget</a>. A seguir são dados mais detalhes das configurações para o teste:</p>
<ul class="incremental">
<li><a href="QoSTesteApache.md">Configuração do ambiente de teste</a></li>
</ul>
<h4 id="teste-1---teste-sem-controle-de-banda">Teste 1 - Teste sem controle de banda</h4>
<p>O primeiro teste foi realizado sem aplicar o controle de banda. Para isso, é possível desativar o PF com o comando:</p>
<pre class="console"><code>openbsd# pfctl -d</code></pre>
<p>Neste cenário ao se executar o comando <code>wget</code>, no cliente o resultado deste é:</p>
<pre class="console"><code>$ wget http://192.168.56.111:8080/100.txt
--2020-01-03 22:53:41--  http://192.168.56.111:8080/100.txt
Conectando-se a 192.168.56.111:8080... conectado.
A requisiÃ§Ã£o HTTP foi enviada, aguardando resposta... 200 OK
Tamanho: 104857600 (100M) [text/plain]
Salvando em: â100.txtâ

100.txt               100%[========================&gt;] 100,00M  50,3MB/s    em 2,0s    

2020-01-03 22:53:43 (50,3 MB/s) - â100.txtâ salvo [104857600/104857600]</code></pre>
<p>Neste teste a taxa transferência de dados foi de aproximadamente 50 Mbps, segundo o <code>wget</code>. No teste não vamos utilizar arquivos muito grandes para não sobrecarregar a máquina durante os testes.</p>
<p>Tal teste produziu o seguinte fluxo de rede capturado pelo Wireshark:</p>
<figure>
<img src="imagens/semControle.png" alt="Sem controle de banda" /><figcaption>Sem controle de banda</figcaption>
</figure>
<p><strong>Observação</strong> - Para obter o gráfico foi usado o <code>tcpdump</code> para capturar o tráfego de rede e o <code>tcpstat</code> para extrair as informações. Exemplo:</p>
<ul class="incremental">
<li><code>tcpdump</code>:</li>
</ul>
<pre class="console"><code># tcpdump -i vboxnet0 -w /tmp/testeQos.pcap</code></pre>
<ul class="incremental">
<li><code>tcpstat</code>:</li>
</ul>
<pre class="console"><code># tcpstat -f &#39;port 8080&#39; -r /tmp/testeQos.pcap -o &quot;%R;%N\n&quot; 1
1;58772185
2;51336842
3;156</code></pre>
<p>Posteriormente os dados obtidos com o <code>tcpstat</code> foram enviados para o LibreOffice e os gráficos foram gerados.</p>
<h4 id="teste-2---com-o-controle-e-banda-ativado">Teste 2 - Com o controle e banda ativado</h4>
<p>Para este teste, vamos usar o mesmo cenário, mas com as regras do PF de controle de banda ativados. Para isso, vamos ligar o PF novamente e depois recarregar as regras criadas:</p>
<pre class="console"><code>openbsd# pfctl -e 
pf enabled
openbsd# pfctl -f /etc/pf-qos.conf                                                        </code></pre>
<p>Após isso repetimos o <code>wget</code> do lado cliente, não esquecendo de monitorar com o <code>tcpdump</code>.</p>
<p>Saída do <code>wget</code>:</p>
<pre class="console"><code>$ wget http://192.168.56.111:8080/100.txt
--2020-01-03 23:08:34--  http://192.168.56.111:8080/100.txt
Conectando-se a 192.168.56.111:8080... conectado.
A requisiÃ§Ã£o HTTP foi enviada, aguardando resposta... 200 OK
Tamanho: 104857600 (100M) [text/plain]
Salvando em: â100.txt.1â

100.txt.1             100%[========================&gt;] 100,00M  60,6MB/s    em 1,6s    

2020-01-03 23:08:36 (60,6 MB/s) - â100.txt.1â salvo [104857600/104857600]</code></pre>
<p>Gráfico do fluxo de rede capturado:</p>
<figure>
<img src="imagens/comControleSemMax.png" alt="Com controle de largura de banda" /><figcaption>Com controle de largura de banda</figcaption>
</figure>
<p>Bem, neste teste nota-se que não houve alterações nos fluxos de rede com ou sem controle de banda. Isso provavelmente deve-se ao fato de que só há uma única conexão de rede ativa e o PF está emprestando banda de outros fluxos. Então, por motivos de teste, vamos ditar limites para o PF dizer que ele não deve passar desses limites estabelecidos.</p>
<h4 id="teste-3---com-o-controle-e-banda-ativado-e-usando-limites">Teste 3 - Com o controle e banda ativado e usando limites</h4>
<p>Bem, para conseguir ver melhor os resultados, vamos especificar melhor os limites de largura de banda para cada fila que criamos no PF. Vamos deixar o arquivo da seguintes forma:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource console numberLines"><code class="sourceCode"><a class="sourceLine" id="cb10-1" title="1">openbsd# vi /etc/pf-qos.conf </a>
<a class="sourceLine" id="cb10-2" title="2">queue fila0 on em1  bandwidth 100M max 100M </a>
<a class="sourceLine" id="cb10-3" title="3">queue fila5M parent fila0 bandwidth 5M min 5M max 5M</a>
<a class="sourceLine" id="cb10-4" title="4">queue fila10M parent fila0 bandwidth 10M min 10M max 10M default </a>
<a class="sourceLine" id="cb10-5" title="5">queue fila30M parent fila0 bandwidth 30M min 30M max 30M  </a>
<a class="sourceLine" id="cb10-6" title="6">queue controle parent fila0 bandwidth 55M min 55M max 55M</a></code></pre></div>
<p>Nessa nova configuração: * Na <code>fila0</code>, informamos que o máximo de largura de banda é 100Mbps (<code>max 100M</code>), não importa se houver mais, a banda disponível não deve exceder esse limite. * Nas filas filhas: <code>fila5M</code>, <code>fila10M</code>, <code>fila30M</code> e <code>controle</code> foram configuradas para ter respectivamente no mínimo (<code>min</code>) e no máximo (<code>max</code>) 5Mb, 10Mb, 30Mb e 55Mb. <strong>Os valores máximo e mínimos podem ser diferentes, mas para testes mais concisos foram utilizados valores iguais</strong>.</p>
<p>Lembre de recarregar as regras, após as alterações nas filas:</p>
<pre class="console"><code>openbsd# pfctl -f /etc/pf-qos.conf                                                        </code></pre>
<p>E execute os testes novamente:</p>
<pre class="console"><code>$ wget http://192.168.56.111:8080/100.txt
--2020-01-03 23:21:45--  http://192.168.56.111:8080/100.txt
Conectando-se a 192.168.56.111:8080... conectado.
A requisiÃ§Ã£o HTTP foi enviada, aguardando resposta... 200 OK
Tamanho: 104857600 (100M) [text/plain]
Salvando em: â100.txt.2â

100.txt.2             100%[========================&gt;] 100,00M  1,14MB/s    em 89s     

2020-01-03 23:23:14 (1,12 MB/s) - â100.txt.2â salvo [104857600/104857600]</code></pre>
<figure>
<img src="imagens/comControleComMax.png" alt="Com controle de largura de banda e limites" /><figcaption>Com controle de largura de banda e limites</figcaption>
</figure>
<p>Bem com a saída do comando e com a figura anterior, é possível notar que a taxa de transferência de banda foi reduzida drasticamente, caindo de ~50Mbps para ~1Mbps. Outra grande mudança foi quanto ao tempo, sem o controle o tempo para o download de um arquivo de 100MB foi de 3 segundos, já com o controle/limites aplicados o tempo para fazer o download do mesmo arquivo foi de 90 segundos. Lembrando que neste teste o fluxo de rede do download foi submetido a <code>fila10M</code>, que é a fila padrão (<code>default</code>) que tem 10Mb de largura de banda.</p>
<h4 id="teste-4---atribuindo-fluxos-de-rede-as-filas-criadas">Teste 4 - Atribuindo fluxos de rede as filas criadas</h4>
<p>No exemplo anterior, não há nenhuma regra de <em>firewall</em> atribuindo os fluxos de rede às filas criadas. Assim, todos os pacotes de rede estão indo para a fila padrão, que é a <code>fila10M</code>. Desta forma, todos os pacotes na rede tem apenas 10Mb de largura de banda. Agora vamos criar regras do PF para atribuir fluxos diferentes para filas com largura de banda diferentes.</p>
<p>Vamos criar as seguintes regras: 1. Uma para pacotes TCP na porta 8080, que devem ser encaminhados para <code>fila30M</code>, recebendo assim 30Mb de largura de banda. 2. Outra para pacotes TCP na porta 8081, que serão destinados a <code>fila5M</code>, recebendo apenas 5Mb de largura de banda. 3. Uma terceira regra, que atribui pacotes SSH fila <code>controle</code>, que tem 55Mb disponível. 3. Qualquer outro pacote será atribuído à <code>fila10M</code>, já que não possuem regras e serão destinados a fila padrão. Vai ser o caso dos testes com pacotes TCP na porta 80 (porta HTTP padrão).</p>
<p>As regras são apresentadas na prática a seguir:</p>
<pre class="console"><code>openbsd# cat /etc/pf-qos.conf      
queue fila0 on em1  bandwidth 100M max 100M 
queue fila5M parent fila0 bandwidth 5M min 5M max 5M
queue fila10M parent fila0 bandwidth 10M min 10M max 10M default 
queue fila30M parent fila0 bandwidth 30M min 30M max 30M  
queue controle parent fila0 bandwidth 55M min 55M max 55M

pass in on em1 proto tcp from any to any port 8080 set queue fila30M 
pass in on em1 proto tcp from any to any port 8081 set queue fila5M 
pass in on em1 proto tcp from any to any port 22 set queue control</code></pre>
<ul class="incremental">
<li>Regra <code>pass in on em1 proto tcp from any to any port 8080 set queue fila30M</code>, informa que serão aceitos pacotes tcp entrando pela placa de rede <code>em1</code>, vindos de qualquer host destinados para qualquer host na porta TCP/8080, tais pacotes serão atribuídos a <code>fila30M</code>.</li>
<li>As demais regras são parecidas só alterando a porta e o nome da fila.</li>
</ul>
<blockquote>
<p><strong>Atenção</strong> - normalmente regras de controle de banda só podem ser controladas nas saída (<code>out</code>) e não na entrada (<code>in</code>). Contudo, nesta versão do PF, os teste não funcionaram com a saída, mas sim com a entrada (<code>in</code>).</p>
</blockquote>
<p>Recarregue as regras, após a criação das regras no PF:</p>
<pre class="console"><code>openbsd# pfctl -f /etc/pf-qos.conf                                                        </code></pre>
<p>Para testar vamos executar um script para que sejam criados fluxos de rede simultaneamente para TCP/8080, TCP/8081 e TCP/80. O script terá o seguinte conteúdo:</p>
<pre class="console"><code>$ cat testeQoS.sh 
xterm -e &quot;wget http://192.168.56.111:80/100.txt &amp;&amp; read&quot; &amp;
xterm -e &quot;wget http://192.168.56.111:8081/100.txt &amp;&amp; read&quot; &amp;
xterm -e &quot;wget http://192.168.56.111:8080/100.txt &amp;&amp; read&quot; &amp;</code></pre>
<p>Após isso é só executar o script e ver o resultado de cada <code>wget</code>:</p>
<ul class="incremental">
<li>Script:</li>
</ul>
<pre class="console"><code>$ sh testeQoS.sh</code></pre>
<ul class="incremental">
<li><code>wget http://192.168.56.111:8080/100.txt</code>:</li>
</ul>
<pre class="console"><code>--2020-01-03 23:51:11--  http://192.168.56.111:8080/100.txt
Conectando-se a 192.168.56.111:8080... conectado.
A requisição HTTP foi enviada, aguardando resposta... 200 OK
Tamanho: 104857600 (100M) [text/plain]
Salvando em: “100.txt.17.1”

100.txt.17.1        100%[===================&gt;] 100,00M  2,80MB/s    em 39s     

2020-01-03 23:51:50 (2,58 MB/s) - “100.txt.17.1” salvo [104857600/104857600</code></pre>
<ul class="incremental">
<li><code>wget http://192.168.56.111:80/100.txt</code>:</li>
</ul>
<pre class="console"><code>20-01-03 23:51:11--  http://192.168.56.111/100.txt
Conectando-se a 192.168.56.111:80... conectado.
A requisição HTTP foi enviada, aguardando resposta... 200 OK
Tamanho: 104857600 (100M) [text/plain]
Salvando em: “100.txt.16”

100.txt.16          100%[===================&gt;] 100,00M  1,14MB/s    em 89s     

2020-01-03 23:52:40 (1,12 MB/s) - “100.txt.16” salvo [104857600/104857600</code></pre>
<ul class="incremental">
<li><code>wget http://192.168.56.111:8081/100.txt</code></li>
</ul>
<pre class="console"><code>--2020-01-03 23:51:11--  http://192.168.56.111:8081/100.txt
Conectando-se a 192.168.56.111:8081... conectado.
A requisição HTTP foi enviada, aguardando resposta... 200 OK
Tamanho: 104857600 (100M) [text/plain]
Salvando em: “100.txt.17”

100.txt.17          100%[===================&gt;] 100,00M   583KB/s    em 2m 56s  

2020-01-03 23:54:07 (581 KB/s) - “100.txt.17” salvo [104857600/104857600</code></pre>
<p>Analisando as saídas, observa-se que o fluxo TCP/8080 terminou primeiro, com 39 segundos e 2,58MB/s. Em segundo lugar o fluxo TCP/80, com 89 segundos e 1,12 MB/s. Por último, o fluxo TCP/8081, com 2 minutos e 56 segundos, e uma taxa de transferência de dados de apenas 581KB/s. O que é coerente já que respectivamente foram atribuídos as filas com 30Mb, 10Mb e 5Mb. O gráfico a seguir ajuda a mostrar como foi ditado o controle de banda para cada um dos fluxos:</p>
<figure>
<img src="imagens/comControleLimitesRegras.png" alt="comControleLimitesRegras" /><figcaption>comControleLimitesRegras</figcaption>
</figure>
<p>Utilizando o esquema anterior, é possível, por exemplo, atribuir uma largura de banda mínima para serviços indesejados na rede, tal como torrent (que neste caso foi representado pelo fluxo TCP/8081). Já fluxos que necessitam de velocidade também seriam identificados, como por exemplo o TCP/8080 e TCP/22 (SSH), do nosso exemplo. Já o restante seguiria utilizando uma largura de banda moderada (no exemplo foi o fluxo HTTP, na porta TCP/80).</p>
<h4 id="teste-5---compartilhando-a-largura-de-banda---sem-usar-limite">Teste 5 - Compartilhando a largura de banda - sem usar limite</h4>
<p>Nos teste anteriores foi utilizado limite mínimo (<code>min</code>) e máximo (<code>max</code>). Bem, isso não é obrigatório, caso não se use o limite as filas emprestam largura de banda das filas ociosas e na prática isso normalmente é mais interessante.</p>
<p>Vamos apresentar aqui um exemplo mais simples de filas, veja o arquivo a seguir:</p>
<pre class="console"><code>openbsd# cat /etc/pf-qos2.conf
queue fila0 on em1  bandwidth 50M max 50M
queue fila1M parent fila0 bandwidth 1M
queue fila49M parent fila0 bandwidth 49M default

pass in on em1 proto tcp from any to any port 8081 set queue fila1M</code></pre>
<p>Neste arquivo novo a <code>fila0</code> tem uma largura de banda de 50M e há apenas duas filas filhas com 1Mb e 49Mb. Também só há uma regra que atribui fluxo TCP/8081 a fila de 1Mb, os demais fluxos vão para a fila de 49M.</p>
<p>Neste caso em um teste as filas compartilham a largura de banda, caso uma das filas estejam ociosas. Exemplo, ao se executar dois <code>wget</code> simultâneos, um na porta TCP/8080 e outro na porta TCP/8081, quando o <code>wget</code> da porta TCP/8080 terminar o da porta TCP/8081 pegará toda a largura de banda para sí. Veja os comandos e gráfico a seguir:</p>
<ul class="incremental">
<li><code>wget</code> da port 8080:</li>
</ul>
<pre class="console"><code>--2020-01-04 01:02:09--  http://192.168.56.111:8080/100.txt
Conectando-se a 192.168.56.111:8080... conectado.
A requisição HTTP foi enviada, aguardando resposta... 200 OK
Tamanho: 104857600 (100M) [text/plain]
Salvando em: “100.txt”

100.txt             100%[===================&gt;] 100,00M  3,87MB/s    em 27s     

2020-01-04 01:02:37 (3,68 MB/s) - “100.txt” salvo [104857600/104857600]</code></pre>
<ul class="incremental">
<li><code>wget</code> da porta 8081:</li>
</ul>
<pre class="console"><code>--2020-01-04 01:02:09--  http://192.168.56.111:8081/100.txt
Conectando-se a 192.168.56.111:8081... conectado.
A requisição HTTP foi enviada, aguardando resposta... 200 OK
Tamanho: 104857600 (100M) [text/plain]
Salvando em: “100.txt.1”

100.txt.1           100%[===================&gt;] 100,00M  3,08MB/s    em 54s     

2020-01-04 01:03:03 (1,86 MB/s) - “100.txt.1” salvo [104857600/104857600]</code></pre>
<p>Ao final esses comandos produzem os seguintes fluxos de rede:</p>
<figure>
<img src="imagens/comControleSemLimites.png" alt="comControleSemLimites" /><figcaption>comControleSemLimites</figcaption>
</figure>
<p>Ou seja, de inicio o fluxo TCP/8080 consome a banda destinada/reservada para ele (45Mb), mas tão logo o download termine o fluxo TCP/8081 pode usar toda a largura de banda disponível para ele e terminar o seu download mais rápido se comparado com os testes anteriores, nos quais foram utilizados limites.</p>
<h4 id="teste-6---compartilhando-a-largura-de-banda-de-outras-filas-no-inicio">Teste 6 - Compartilhando a largura de banda de outras filas no inicio</h4>
<p>No PF, há como dar mais largura de banda no inicio de uma conexão, mas caso essa não termine logo, o que pode significar um fluxo indesejado (torrent, YouTube, Netflix, etc) o PF atribui uma largura de banda menor. Para isso basta utilizar a opção <code>burst</code> em um tempo em milissegundos (<code>200ms</code>), na frente da regra que cria as filas. Por exemplo:</p>
<pre class="console"><code>openbsd# cat /etc/pf-qos2.conf
queue fila0 on em1  bandwidth 50M max 50M
queue fila1M parent fila0 bandwidth 1M burst 49M for 5000ms
queue fila49M parent fila0 bandwidth 49M default

pass in on em1 proto tcp from any to any port 8081 set queue fila5M</code></pre>
<p>O arquivo é o mesmo do exemplo anterior, só foi acrescido o <code>busrt</code>. Neste caso a <code>fila1M</code> terá de inicio 49Mb por 5 segundos, depois a largura de banda irá para apenas 1Mb (<code>queue fila1M parent fila0 bandwidth 1M burst 49M for 5000ms</code>).</p>
<p>Vamos testar com apenas dois fluxos TCP/8080 e TCP/8081:</p>
<ul class="incremental">
<li><code>wget</code> da port 8080:</li>
</ul>
<pre class="console"><code>--2020-01-04 01:09:53--  http://192.168.56.111:8080/100.txt
Conectando-se a 192.168.56.111:8080... conectado.
A requisição HTTP foi enviada, aguardando resposta... 200 OK
Tamanho: 104857600 (100M) [text/plain]
Salvando em: “100.txt.3”

100.txt.3           100%[===================&gt;] 100,00M  3,92MB/s    em 29s     

2020-01-04 01:10:22 (3,43 MB/s) - “100.txt.3” salvo [104857600/104857600]</code></pre>
<ul class="incremental">
<li><code>wget</code> da port 8081:</li>
</ul>
<pre class="console"><code>--2020-01-04 01:09:53--  http://192.168.56.111:8081/100.txt
Conectando-se a 192.168.56.111:8081... conectado.
A requisição HTTP foi enviada, aguardando resposta... 200 OK
Tamanho: 104857600 (100M) [text/plain]
Salvando em: “100.txt.2”

100.txt.2           100%[===================&gt;] 100,00M  3,32MB/s    em 43s     

2020-01-04 01:10:35 (2,33 MB/s) - “100.txt.2” salvo [104857600/104857600]</code></pre>
<p>Tais comandos produzem os seguintes fluxos de rede:</p>
<figure>
<img src="imagens/comControleSemLimitesBurst.png" alt="comControleSemLimitesBurst" /><figcaption>comControleSemLimitesBurst</figcaption>
</figure>
<p>Na figura nota-se que inicialmente os fluxos 8080 e 8081 brigam pela largura de banda disponível. Todavia, depois de uns 10 segundos, o fluxo 8080 ganha a maior fatia para ele (note que não é exatamente o que determinamos no arquivo, mas funciona). Quando o fluxo 8080 termina de fazer o download do arquivo o fluxo 8081 ganha novamente o direito de usar toda a largura de banda.</p>
</section>
<section id="referências" class="slide level2">
<h2>Referências</h2>
<ul class="incremental">
<li><a href="https://www.openbsd.org/faq/pf/" class="uri">https://www.openbsd.org/faq/pf/</a></li>
<li><a href="https://man.openbsd.org/pf.conf.5#QUEUEING" class="uri">https://man.openbsd.org/pf.conf.5#QUEUEING</a></li>
</ul>
</section>
<!-- {{{{ dzslides core
#
#
#     __  __  __       .  __   ___  __
#    |  \  / /__` |    | |  \ |__  /__`
#    |__/ /_ .__/ |___ | |__/ |___ .__/ core :€
#
#
# The following block of code is not supposed to be edited.
# But if you want to change the behavior of these slides,
# feel free to hack it!
#
-->

<div id="progress-bar"></div>

<!-- Default Style -->
<style>
  * { margin: 0; padding: 0; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
  [role="note"] { display: none; }
  body {
    width: 800px; height: 600px;
    margin-left: -400px; margin-top: -300px;
    position: absolute; top: 50%; left: 50%;
    overflow: hidden;
    display: none;
  }
  .view body {
    position: static;
    margin: 0; padding: 0;
    width: 100%; height: 100%;
    display: inline-block;
    overflow: visible; overflow-x: hidden;
    /* undo Dz.onresize */
    transform: none !important;
    -moz-transform: none !important;
    -webkit-transform: none !important;
    -o-transform: none !important;
    -ms-transform: none !important;
  }
  .view head, .view head > title { display: block }
  section {
    position: absolute;
    pointer-events: none;
    width: 100%; height: 100%;
  }
  .view section {
    pointer-events: auto;
    position: static;
    width: 800px; height: 600px;
    margin: -150px -200px;
    float: left;

    transform: scale(.4);
    -moz-transform: scale(.4);
    -webkit-transform: scale(.4);
    -o-transform: scale(.4);
    -ms-transform: scale(.4);
  }
  .view section > * { pointer-events: none; }
  section[aria-selected] { pointer-events: auto; }
  html { overflow: hidden; }
  html.view { overflow: visible; }
  body.loaded { display: block; }
  .incremental {visibility: hidden; }
  .incremental[active] {visibility: visible; }
  #progress-bar{
    bottom: 0;
    position: absolute;
    -moz-transition: width 400ms linear 0s;
    -webkit-transition: width 400ms linear 0s;
    -ms-transition: width 400ms linear 0s;
    transition: width 400ms linear 0s;
  }
  .view #progress-bar {
    display: none;
  }
</style>

<script>
  var Dz = {
    remoteWindows: [],
    idx: -1,
    step: 0,
    html: null,
    slides: null,
    progressBar : null,
    params: {
      autoplay: "1"
    }
  };

  Dz.init = function() {
    document.body.className = "loaded";
    this.slides = Array.prototype.slice.call($$("body > section"));
    this.progressBar = $("#progress-bar");
    this.html = document.body.parentNode;
    this.setupParams();
    this.onhashchange();
    this.setupTouchEvents();
    this.onresize();
    this.setupView();
  }

  Dz.setupParams = function() {
    var p = window.location.search.substr(1).split('&');
    p.forEach(function(e, i, a) {
      var keyVal = e.split('=');
      Dz.params[keyVal[0]] = decodeURIComponent(keyVal[1]);
    });
  // Specific params handling
    if (!+this.params.autoplay)
      $$.forEach($$("video"), function(v){ v.controls = true });
  }

  Dz.onkeydown = function(aEvent) {
    // Don't intercept keyboard shortcuts
    if (aEvent.altKey
      || aEvent.ctrlKey
      || aEvent.metaKey
      || aEvent.shiftKey) {
      return;
    }
    if ( aEvent.keyCode == 37 // left arrow
      || aEvent.keyCode == 38 // up arrow
      || aEvent.keyCode == 33 // page up
    ) {
      aEvent.preventDefault();
      this.back();
    }
    if ( aEvent.keyCode == 39 // right arrow
      || aEvent.keyCode == 40 // down arrow
      || aEvent.keyCode == 34 // page down
    ) {
      aEvent.preventDefault();
      this.forward();
    }
    if (aEvent.keyCode == 35) { // end
      aEvent.preventDefault();
      this.goEnd();
    }
    if (aEvent.keyCode == 36) { // home
      aEvent.preventDefault();
      this.goStart();
    }
    if (aEvent.keyCode == 32) { // space
      aEvent.preventDefault();
      this.toggleContent();
    }
    if (aEvent.keyCode == 70) { // f
      aEvent.preventDefault();
      this.goFullscreen();
    }
    if (aEvent.keyCode == 79) { // o
      aEvent.preventDefault();
      this.toggleView();
    }
  }

  /* Touch Events */

  Dz.setupTouchEvents = function() {
    var orgX, newX;
    var tracking = false;

    var db = document.body;
    db.addEventListener("touchstart", start.bind(this), false);
    db.addEventListener("touchmove", move.bind(this), false);

    function start(aEvent) {
      aEvent.preventDefault();
      tracking = true;
      orgX = aEvent.changedTouches[0].pageX;
    }

    function move(aEvent) {
      if (!tracking) return;
      newX = aEvent.changedTouches[0].pageX;
      if (orgX - newX > 100) {
        tracking = false;
        this.forward();
      } else {
        if (orgX - newX < -100) {
          tracking = false;
          this.back();
        }
      }
    }
  }

  Dz.setupView = function() {
    document.body.addEventListener("click", function ( e ) {
      if (!Dz.html.classList.contains("view")) return;
      if (!e.target || e.target.nodeName != "SECTION") return;

      Dz.html.classList.remove("view");
      Dz.setCursor(Dz.slides.indexOf(e.target) + 1);
    }, false);
  }

  /* Adapt the size of the slides to the window */

  Dz.onresize = function() {
    var db = document.body;
    var sx = db.clientWidth / window.innerWidth;
    var sy = db.clientHeight / window.innerHeight;
    var transform = "scale(" + (1/Math.max(sx, sy)) + ")";

    db.style.MozTransform = transform;
    db.style.WebkitTransform = transform;
    db.style.OTransform = transform;
    db.style.msTransform = transform;
    db.style.transform = transform;
  }


  Dz.getNotes = function(aIdx) {
    var s = $("section:nth-of-type(" + aIdx + ")");
    var d = s.$("[role='note']");
    return d ? d.innerHTML : "";
  }

  Dz.onmessage = function(aEvent) {
    var argv = aEvent.data.split(" "), argc = argv.length;
    argv.forEach(function(e, i, a) { a[i] = decodeURIComponent(e) });
    var win = aEvent.source;
    if (argv[0] === "REGISTER" && argc === 1) {
      this.remoteWindows.push(win);
      this.postMsg(win, "REGISTERED", document.title, this.slides.length);
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
      return;
    }
    if (argv[0] === "BACK" && argc === 1)
      this.back();
    if (argv[0] === "FORWARD" && argc === 1)
      this.forward();
    if (argv[0] === "START" && argc === 1)
      this.goStart();
    if (argv[0] === "END" && argc === 1)
      this.goEnd();
    if (argv[0] === "TOGGLE_CONTENT" && argc === 1)
      this.toggleContent();
    if (argv[0] === "SET_CURSOR" && argc === 2)
      window.location.hash = "#" + argv[1];
    if (argv[0] === "GET_CURSOR" && argc === 1)
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
    if (argv[0] === "GET_NOTES" && argc === 1)
      this.postMsg(win, "NOTES", this.getNotes(this.idx));
  }

  Dz.toggleContent = function() {
    // If a Video is present in this new slide, play it.
    // If a Video is present in the previous slide, stop it.
    var s = $("section[aria-selected]");
    if (s) {
      var video = s.$("video");
      if (video) {
        if (video.ended || video.paused) {
          video.play();
        } else {
          video.pause();
        }
      }
    }
  }

  Dz.setCursor = function(aIdx, aStep) {
    // If the user change the slide number in the URL bar, jump
    // to this slide.
    aStep = (aStep != 0 && typeof aStep !== "undefined") ? "." + aStep : ".0";
    window.location.hash = "#" + aIdx + aStep;
  }

  Dz.onhashchange = function() {
    var cursor = window.location.hash.split("#"),
        newidx = 1,
        newstep = 0;
    if (cursor.length == 2) {
      newidx = ~~cursor[1].split(".")[0];
      newstep = ~~cursor[1].split(".")[1];
      if (newstep > Dz.slides[newidx - 1].$$('.incremental > *').length) {
        newstep = 0;
        newidx++;
      }
    }
    this.setProgress(newidx, newstep);
    if (newidx != this.idx) {
      this.setSlide(newidx);
    }
    if (newstep != this.step) {
      this.setIncremental(newstep);
    }
    for (var i = 0; i < this.remoteWindows.length; i++) {
      this.postMsg(this.remoteWindows[i], "CURSOR", this.idx + "." + this.step);
    }
  }

  Dz.back = function() {
    if (this.idx == 1 && this.step == 0) {
      return;
    }
    if (this.step == 0) {
      this.setCursor(this.idx - 1,
                     this.slides[this.idx - 2].$$('.incremental > *').length);
    } else {
      this.setCursor(this.idx, this.step - 1);
    }
  }

  Dz.forward = function() {
    if (this.idx >= this.slides.length &&
        this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
        return;
    }
    if (this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
      this.setCursor(this.idx + 1, 0);
    } else {
      this.setCursor(this.idx, this.step + 1);
    }
  }

  Dz.goStart = function() {
    this.setCursor(1, 0);
  }

  Dz.goEnd = function() {
    var lastIdx = this.slides.length;
    var lastStep = this.slides[lastIdx - 1].$$('.incremental > *').length;
    this.setCursor(lastIdx, lastStep);
  }

  Dz.toggleView = function() {
    this.html.classList.toggle("view");

    if (this.html.classList.contains("view")) {
      $("section[aria-selected]").scrollIntoView(true);
    }
  }

  Dz.setSlide = function(aIdx) {
    this.idx = aIdx;
    var old = $("section[aria-selected]");
    var next = $("section:nth-of-type("+ this.idx +")");
    if (old) {
      old.removeAttribute("aria-selected");
      var video = old.$("video");
      if (video) {
        video.pause();
      }
    }
    if (next) {
      next.setAttribute("aria-selected", "true");
      if (this.html.classList.contains("view")) {
        next.scrollIntoView();
      }
      var video = next.$("video");
      if (video && !!+this.params.autoplay) {
        video.play();
      }
    } else {
      // That should not happen
      this.idx = -1;
      // console.warn("Slide doesn't exist.");
    }
  }

  Dz.setIncremental = function(aStep) {
    this.step = aStep;
    var old = this.slides[this.idx - 1].$('.incremental > *[aria-selected]');
    if (old) {
      old.removeAttribute('aria-selected');
    }
    var incrementals = $$('.incremental');
    if (this.step <= 0) {
      $$.forEach(incrementals, function(aNode) {
        aNode.removeAttribute('active');
      });
      return;
    }
    var next = this.slides[this.idx - 1].$$('.incremental > *')[this.step - 1];
    if (next) {
      next.setAttribute('aria-selected', true);
      next.parentNode.setAttribute('active', true);
      var found = false;
      $$.forEach(incrementals, function(aNode) {
        if (aNode != next.parentNode)
          if (found)
            aNode.removeAttribute('active');
          else
            aNode.setAttribute('active', true);
        else
          found = true;
      });
    } else {
      setCursor(this.idx, 0);
    }
    return next;
  }

  Dz.goFullscreen = function() {
    var html = $('html'),
        requestFullscreen = html.requestFullscreen || html.requestFullScreen || html.mozRequestFullScreen || html.webkitRequestFullScreen;
    if (requestFullscreen) {
      requestFullscreen.apply(html);
    }
  }
  
  Dz.setProgress = function(aIdx, aStep) {
    var slide = $("section:nth-of-type("+ aIdx +")");
    if (!slide)
      return;
    var steps = slide.$$('.incremental > *').length + 1,
        slideSize = 100 / (this.slides.length - 1),
        stepSize = slideSize / steps;
    this.progressBar.style.width = ((aIdx - 1) * slideSize + aStep * stepSize) + '%';
  }
  
  Dz.postMsg = function(aWin, aMsg) { // [arg0, [arg1...]]
    aMsg = [aMsg];
    for (var i = 2; i < arguments.length; i++)
      aMsg.push(encodeURIComponent(arguments[i]));
    aWin.postMessage(aMsg.join(" "), "*");
  }
  
  function init() {
    Dz.init();
    window.onkeydown = Dz.onkeydown.bind(Dz);
    window.onresize = Dz.onresize.bind(Dz);
    window.onhashchange = Dz.onhashchange.bind(Dz);
    window.onmessage = Dz.onmessage.bind(Dz);
  }

  window.onload = init;
</script>


<script> // Helpers
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {

      // closest thing possible to the ECMAScript 5 internal IsCallable
      // function 
      if (typeof this !== "function")
      throw new TypeError(
        "Function.prototype.bind - what is trying to be fBound is not callable"
      );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
            return fToBind.apply( this instanceof fNOP ? this : oThis || window,
                   aArgs.concat(Array.prototype.slice.call(arguments)));
          };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
  }

  var $ = (HTMLElement.prototype.$ = function(aQuery) {
    return this.querySelector(aQuery);
  }).bind(document);

  var $$ = (HTMLElement.prototype.$$ = function(aQuery) {
    return this.querySelectorAll(aQuery);
  }).bind(document);

  $$.forEach = function(nodeList, fun) {
    Array.prototype.forEach.call(nodeList, fun);
  }

</script>
<!-- vim: set fdm=marker: }}} -->
</body>
</html>
